<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xungerrrr&#39;s Site</title>
  
  <subtitle>Every Little Counts.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xungerrrr.github.io/"/>
  <updated>2019-10-12T09:30:53.636Z</updated>
  <id>https://xungerrrr.github.io/</id>
  
  <author>
    <name>Xunyan Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单镜头也能测深度？</title>
    <link href="https://xungerrrr.github.io/2019/10/11/%E5%8D%95%E9%95%9C%E5%A4%B4%E4%B9%9F%E8%83%BD%E6%B5%8B%E6%B7%B1%E5%BA%A6%EF%BC%9F/"/>
    <id>https://xungerrrr.github.io/2019/10/11/单镜头也能测深度？/</id>
    <published>2019-10-11T03:48:49.000Z</published>
    <updated>2019-10-12T09:30:53.636Z</updated>
    
    <content type="html"><![CDATA[<p>传统的相机只能捕捉二维画面，丢失了环境的深度信息。而且，仅凭照片无法获得任何尺度信息。深度相机是一种新式的传感器，它能感知场景的立体结构，相比于普通相机多获取了一维的信息，从而能进行距离测量、速度测量等。利用这些额外的信息，还能做出非常多的应用，例如实时背景虚化、增强现实、人体追踪等。深度信息的获取在很多领域都具有重要的意义，如自动驾驶、机器人等等。</p><p>不过，这些事情离开了深度相机就没办法完成吗？目前，深度感知受到了越来越多的关注，已经有非常多的方法可以用于获取场景的三维数据，其中当然不乏使用普通相机的例子。苹果的ARKit就是一个非常成功的例子。今天，我们就来看看深度感知都有哪些技术，探讨一下深度相机与苹果ARKit技术的异同，并且对它们的利弊进行分析。</p><h1 id="深度相机"><a href="#深度相机" class="headerlink" title="深度相机"></a>深度相机</h1><p>顾名思义，深度相机就是能够测量物体到相机距离（深度）的相机。我们之前介绍过的Azure Kinect就配备了一台深度相机。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先，我们来简单了解一下深度相机的原理。从原理上将，深度相机可以分为两大类：</p><ol><li><p>基于特征匹配的深度相机。</p><p> 这种相机使用了三角形的几何性质来计算深度信息。简单来说，这种相机会得到一左一右两个图像，首先，相机对两个图形进行特征点匹配，然后利用匹配点的坐标差异，用三角测量计算出深度信息。根据实现方法不同，这种相机可进一步分为以下两种：</p><ul><li><p>主动投射结构光深度相机</p><p>  为了令特征点的匹配更简单，这种相机采用了投射编码条纹或点阵的方法，主动向场景投射自定义的特征点，然后使用另一个视角的相机进行拍摄，将照片中的特征点与投射的特征点进行匹配。苹果推出的FaceID人脸识别就是使用这种技术。FaceID将红外点阵投影到人脸上，然后通过红外相机进行捕捉，通过特征匹配计算出人脸的深度信息，从而获得人脸的三维模型。微软的Kinect也曾使用过这种相机。</p><p>  由于采用投射光源，这种相机可以在黑暗环境下使用，而在户外使用则需要有足够的功率去克服强光的影响。同时，如果场景存在较强的反射现象，则会影响测量的精准度。通过合理设计投射的特征，这种相机可以获得较高的精度。</p>  <img src="/2019/10/11/单镜头也能测深度？/Structured_Light_Imaging_01.png" title="Structured_Light_Imaging_01"></li><li><p>被动双目深度相机</p><p>  与主动投射结构光深度相机不同，这种相机不向外投射特征点，而是模拟人眼的结构，使用一左一右两个相机，拍摄两个视角的图像，然后直接匹配图像中的特征。特征匹配完成后，深度的计算过程与结构光相机是类似的。</p><p>  双目深度相机仅依赖实时图像进行特征匹配，所以只能用于特征明显、光线充足的条件中。由于图像特征匹配是一项很难的任务，需要大量的计算量，因此这种相机的测量准确度可能随着场景的变化而有所波动。</p>  <img src="/2019/10/11/单镜头也能测深度？/zed-mini.jpg" title="zed-mini"></li></ul></li><li><p>基于反射时间的深度相机。</p><p> 这种相机就是我们常说的ToF相机，原理是利用光线的飞行时间 (Time of Flight) 来获得距离信息。这种相机首先将调制光投射到物体上，然后测量光线经场景反射后返回的时间差，得到深度信息。微软推出的Azure Kinect使用了这种深度相机。</p> <img src="/2019/10/11/单镜头也能测深度？/ToF.jpg" title="ToF"><p> 大家都知道，光速是非常快的，少量的时间误差就会导致严重的距离误差，因此ToF相机对时间测量的精度要求非常高。受制于电子元件的精度，目前ToF相机的精度一般只能达到厘米级，不能应用在高精度测量的领域。</p></li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>下面的表格比较了不同种类的深度相机的一些特点。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">结构光深度相机</th><th style="text-align:center">双目深度相机</th><th style="text-align:center">ToF深度相机</th></tr></thead><tbody><tr><td style="text-align:center">测量精度</td><td style="text-align:center">近距离能达到0.01mm-1mm</td><td style="text-align:center">近距离能达到毫米级</td><td style="text-align:center">最高可达厘米级</td></tr><tr><td style="text-align:center">测量范围</td><td style="text-align:center">一般在10m内</td><td style="text-align:center">一般在2m内</td><td style="text-align:center">较远，一般在100m内</td></tr><tr><td style="text-align:center">分辨率</td><td style="text-align:center">中等</td><td style="text-align:center">最高</td><td style="text-align:center">较低</td></tr><tr><td style="text-align:center">功耗</td><td style="text-align:center">中等</td><td style="text-align:center">较低</td><td style="text-align:center">较高</td></tr><tr><td style="text-align:center">户外影响</td><td style="text-align:center">有影响</td><td style="text-align:center">无影响</td><td style="text-align:center">影响较大</td></tr></tbody></table><p>结构光深度相机的测量精度是三者中最高的，因此它能用在人脸识别等精细的领域上。而ToF只能做到厘米级，不能用于高精度的工业生产中。</p><p>由于结构光相机和双目相机都是基于视觉特征匹配进行深度测量，所以它们的测量范围比较近，而且随着距离的增大，误差也会增大。ToF相机则是通过测量光线传播时间来测量深度，相对来说能测量更远的范围。</p><p>受限于电子元件的大小，ToF相机的分辨率一般不高，而结构光和双目相机是采用视觉特征识别，分辨率会相对高一些。不过随着技术的进步，ToF相机的分辨率已经在逐步提高。Azure Kinect的深度相机就已经达到了1024×1024的分辨率。</p><p>在功耗方面，由于结构光相机和ToF相机都需要主动投射出光源，所以功率会较高。双目深度相机主要使用软件进行计算，功率相对较低。同样，结构光相机的ToF相机在户外使用时会受到外界强光和外界反射的干扰，所以更适合在室内使用。</p><h1 id="ARKit"><a href="#ARKit" class="headerlink" title="ARKit"></a>ARKit</h1><p>从前面的内容来看，深度相机需要使用多个摄像头捕获不同视角的照片，或者使用特殊的红外光发射器和接收器。只用一个摄像头能不能实现三维的感知？答案是肯定的，而这里不得不提及苹果的ARKit。</p><p>近年来，苹果不断致力于完善自己的AR平台，鼓励开发者参与到AR开发中来。在2017年，苹果推出了ARKit。借助这套开发工具，开发者能够简单地在应用中添加AR功能，而不需要复杂的深度相机和场景标记。虽然今年推出的iPhone 11 Pro拥有了后置三摄，但是ARKit在仅有单个摄像头的苹果设备上也是能够使用的。使用ARKit不仅能够获取到3D信息，还能获取到计量尺度信息。这背后有什么秘密武器？下面我们简单了解一下ARKit的原理。</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>ARKit的技术主要基于视觉惯性测量 (VIO)。顾名思义，VIO包含视觉系统和惯性系统两部分。也就是说，ARKit不仅用到了摄像头，还使用了手机的惯性测量单元 (IMU)。在视觉上，摄像头通过匹配帧与帧之间的特征点，追踪场景的变化；另一方面，加速度计和陀螺仪提供了手机运动的数据。</p><p>本质上来说，VIO在视觉上的原理和被动双目深度相机是类似的，都是通过特征点的匹配来计算深度。VIO的好处是采用了两套系统来同时追踪设备的运动信息，这两套系统相对独立，没有相互依赖的关系，而且在一定程度上能起到互补的作用。当设备剧烈运动，画面变化剧烈时，或者是图像特征不明显时，视觉系统很难进行特征匹配，这时候，惯性系统能够更好地判断设备的移动情况；当设备静止时，视觉系统受到的干扰会更小，能够提供更稳定的追踪信息。通过这两个系统的协调，可以追踪设备在空间中六个自由度的运动情况，包括沿xyz三轴的平移运动和绕三轴的旋转运动。</p><p>那么，既然视觉上的原理和被动双目深度相机类似，ARKit为什么能够在单镜头下工作呢？苹果靠的是镜头的移动。一个摄像头可以先拍摄一帧，移动后再拍摄另一帧，这样就获得了两个视角的画面。可是，双目深度相机能够计算深度是因为两个摄像头的相对位置是确定的，单目摄像头怎么获取两帧之间的距离呢。这个可以用惯性系统来计算，不过对精度的要求相当高。通过IMU给出的加速度和时间等数据，可以计算出速度，进而计算出两帧之间的移动距离。当惯性系统的误差非常小时，能够得到精准的测量值。苹果ARKit的强大之处就在于其很好地移除了IMU的误差，将计量尺度误差减小到10%以下。</p><h2 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h2><p>下面使用苹果推出的测距仪App来试试ARKit的测量效果。正如上面所说，ARKit靠镜头运动来计算尺度信息，因此ARKit需要移动设备来进行初始化。</p><img src="/2019/10/11/单镜头也能测深度？/move.PNG" title="move"><p>经过短暂的移动后，就可以开始测量了。下面尝试测量三星S8手机的尺寸：</p><img src="/2019/10/11/单镜头也能测深度？/test.PNG" title="test"><p>测量的结果显示，手机长15cm，宽7cm。手机真实的长宽为14.89cm和6.81cm。可以看出，ARKit的测量结果只有1~2毫米的误差，非常准确。</p><h1 id="深度相机能被取代吗？"><a href="#深度相机能被取代吗？" class="headerlink" title="深度相机能被取代吗？"></a>深度相机能被取代吗？</h1><p>在ARKit这样强大的SDK的加持下，普通的手机摄像头也能实现深度感知了，那它们能否取代深度相机呢？我觉得，这在目前是不行的，也没有必要。</p><p>从原理来看，不同的相机有不同的优缺点，自然也会有不同的适用场景。单目VIO系统确实有其独特的优点，例如制造成本低、功耗低、准确度高、分辨率高等等，但它不能在昏暗的环境下使用，面对特征不明显的场景会出现很大的误差。而且，单目VIO系统需要的计算量是很大的，导致其实时性较差。这些都是单目VIO系统无法避免的缺点。下图是我用9.7寸iPad Pro进行的测试，它配备了A9X处理器和单摄像头。当测试的线条达到这个数量时，设备已经出现了明显的卡顿和发热，可见ARKit对设备的计算能力要求很高，计算能力不足会严重影响性能。相比之下，ToF深度相机是通过物理测量获得深度信息的，因此实时性很高，同时，它不依靠特征进行测量，所以能够在昏暗和特征不明显的场景中使用，对于边缘和尺寸的测量也会更加精准。双目深度相机可以捕获更多的视觉信息，并且计算量会比单目VIO系统要小，因为两个摄像头的相对位置是固定的。</p><img src="/2019/10/11/单镜头也能测深度？/lag.PNG" title="lag"><p>从上面的角度来看，要是想提高测量的精度，将两者结合倒是一个不错的想法。深度相机能给VIO系统带来很多好处。对于特征点不明显的场景，ToF相机能辅助进行边缘检测、平面检测和尺度检测，能够增加测量精度的稳定性。反过来，在户外光照强烈的地方，VIO系统能够弥补ToF相机的不足。添加相机的数量能增加视觉范围，捕获更多的光学特征。现在许多手机都配备了多个摄像头，通过校准这些摄像头，能够优化近距离的深度测量精度。最近，也有手机厂商开始在手机上配备ToF镜头，用来提高相机的虚化能力，以及提升AR的准确性，例如三星Note 10和华为P30 Pro。</p><p>对于手机这样的小型设备来说，使用单目VIO系统已经能胜任很多使用场景了。而且，ToF深度相机的功耗相对较大，目前使用在手机上的都是小功率的型号，只能起到简单的辅助作用。这样来看，深度相机似乎可以被取代。然而，三维感知不仅用在消费级产品上，还要用在工业生产中。工业使用对环境、精度都提出更高的要求。像Azure Kinect就是一款针对商用领域的产品，其配备了高规格的ToF相机，能够提供比单目VIO系统更全面的深度感知能力。因此，即使单镜头VIO在手机上有足够多的优点，它仍无法在所有使用场景取代深度相机。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;传统的相机只能捕捉二维画面，丢失了环境的深度信息。而且，仅凭照片无法获得任何尺度信息。深度相机是一种新式的传感器，它能感知场景的立体结构，相比于普通相机多获取了一维的信息，从而能进行距离测量、速度测量等。利用这些额外的信息，还能做出非常多的应用，例如实时背景虚化、增强现实、
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用Azure Kinect DK追踪人体运动</title>
    <link href="https://xungerrrr.github.io/2019/10/08/%E7%94%A8Azure-Kinect-DK%E8%BF%BD%E8%B8%AA%E4%BA%BA%E4%BD%93%E8%BF%90%E5%8A%A8/"/>
    <id>https://xungerrrr.github.io/2019/10/08/用Azure-Kinect-DK追踪人体运动/</id>
    <published>2019-10-08T03:00:46.000Z</published>
    <updated>2019-10-12T06:59:43.597Z</updated>
    
    <content type="html"><![CDATA[<p>上次我们在介绍Azure Kinect DK时，提到它包含了一个人体追踪SDK。Kinect人体追踪应该不算新鲜，之前Xbox上的体感游戏就已经用到了Kinect的人体追踪功能。新的Azure Kinect DK将人体追踪功能整合到了一个SDK中，方便开发者对人体追踪数据进行操作。今天我们就来探索一下Azure Kinect DK的人体追踪功能。</p><h1 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h1><h2 id="人体追踪关节"><a href="#人体追踪关节" class="headerlink" title="人体追踪关节"></a>人体追踪关节</h2><p>每个追踪的关节都有其位置和方向，它们决定了关节自身的坐标系。人体追踪骨架共包含26个关节，层次结构按照从人体中心骨盆(PELVIS)向四肢的流向分布。每个连接（骨骼）将父关节与子关节链接起来。下图演示了关节坐标以及相对于人体的层次结构。</p><img src="/2019/10/08/用Azure-Kinect-DK追踪人体运动/joint-coordinates.png" title="joint-coordinates"><h2 id="人体索引映射"><a href="#人体索引映射" class="headerlink" title="人体索引映射"></a>人体索引映射</h2><p>人体索引映射是一张分割图像，将深度图按照人体划分成不同的区域。它用不同的像素值表示不同的人体，其像素与深度图一一对应。</p><img src="/2019/10/08/用Azure-Kinect-DK追踪人体运动/body-index-map.png" title="body-index-map"><h2 id="人体帧包含的内容"><a href="#人体帧包含的内容" class="headerlink" title="人体帧包含的内容"></a>人体帧包含的内容</h2><p>人体帧是人体追踪的结果，它包含以下三个关键的部分：</p><ol><li>人体结构的集合</li><li>2D人体索引映射</li><li>生成此结果的输入捕获</li></ol><img src="/2019/10/08/用Azure-Kinect-DK追踪人体运动/body-frame.png" title="body-frame"><h1 id="人体追踪"><a href="#人体追踪" class="headerlink" title="人体追踪"></a>人体追踪</h1><p>使用Azure Kinect DK的人体追踪SDK，可以直接追踪人体骨架，不需要进行额外的训练。先下载和安装<a href="https://docs.microsoft.com/zh-cn/azure/kinect-dk/body-sdk-download" target="_blank" rel="noopener">人体追踪SDK</a>，然后连接好Kinect设备，就可以开始探索了！</p><h2 id="人体追踪演示"><a href="#人体追踪演示" class="headerlink" title="人体追踪演示"></a>人体追踪演示</h2><p>安装好SDK后，我们就可以直接运行其附带的小工具来演示追踪过程。工具位于安装目录下的tools/k4abt_simple_3d_viewer.exe。</p><p>下面是演示的效果。可以看到，这个程序将3D深度图、人体骨架和人体索引映射同时展示出来，追踪效果相当不错。</p><img src="/2019/10/08/用Azure-Kinect-DK追踪人体运动/bt.gif" title="bt"><h2 id="人体追踪的操作过程"><a href="#人体追踪的操作过程" class="headerlink" title="人体追踪的操作过程"></a>人体追踪的操作过程</h2><p>光看演示还不够，我们还需要了解人体追踪的具体操作过程。下面，我们用C++的API来说明这个过程。一般来说，Azure Kinect DK的人体追踪分为以下步骤：</p><ol><li><p>打开设备，配置并启动相机</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">k4a_device_t</span> device = <span class="literal">nullptr</span>;</span><br><span class="line">VERIFY(k4a_device_open(<span class="number">0</span>, &amp;device), <span class="string">"Open K4A Device failed!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start camera. Make sure depth camera is enabled.</span></span><br><span class="line"><span class="keyword">k4a_device_configuration_t</span> deviceConfig = K4A_DEVICE_CONFIG_INIT_DISABLE_ALL;</span><br><span class="line">deviceConfig.depth_mode = K4A_DEPTH_MODE_WFOV_2X2BINNED;</span><br><span class="line">deviceConfig.color_resolution = K4A_COLOR_RESOLUTION_OFF;</span><br><span class="line">VERIFY(k4a_device_start_cameras(device, &amp;deviceConfig), <span class="string">"Start K4A cameras failed!"</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建人体追踪器</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get calibration information</span></span><br><span class="line"><span class="keyword">k4a_calibration_t</span> sensorCalibration;</span><br><span class="line">VERIFY(k4a_device_get_calibration(device, deviceConfig.depth_mode, deviceConfig.color_resolution, &amp;sensorCalibration),</span><br><span class="line">    <span class="string">"Get depth camera calibration failed!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create Body Tracker</span></span><br><span class="line"><span class="keyword">k4abt_tracker_t</span> tracker = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">k4abt_tracker_configuration_t</span> tracker_config = K4ABT_TRACKER_CONFIG_DEFAULT;</span><br><span class="line">VERIFY(k4abt_tracker_create(&amp;sensorCalibration, tracker_config, &amp;tracker), <span class="string">"Body tracker initialization failed!"</span>);</span><br></pre></td></tr></table></figure></li><li><p>从设备中获取捕获</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">k4a_capture_t</span> sensorCapture = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">k4a_wait_result_t</span> getCaptureResult = k4a_device_get_capture(device, &amp;sensorCapture, <span class="number">0</span>); <span class="comment">// timeout_in_ms is set to 0</span></span><br></pre></td></tr></table></figure></li><li><p>将捕获排入队列并弹出结果（人体帧）</p><p> 人体追踪器在内部维护了一个输入队列和一个输出队列，以便更有效地以异步方式处理Azure Kinect DK捕获。我们只需要将捕获排入队列，然后从队列弹出结果，就能获得一个人体帧结果。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add capture to tracker process queue</span></span><br><span class="line"><span class="keyword">k4a_wait_result_t</span> queueCaptureResult = k4abt_tracker_enqueue_capture(tracker, sensorCapture, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop Result from Body Tracker</span></span><br><span class="line"><span class="keyword">k4abt_frame_t</span> bodyFrame = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">k4a_wait_result_t</span> popFrameResult = k4abt_tracker_pop_result(tracker, &amp;bodyFrame, <span class="number">0</span>); <span class="comment">// timeout_in_ms is set to 0</span></span><br></pre></td></tr></table></figure></li><li><p>访问人体帧数据</p><p> 下面的例子显示了如何访问人体帧中的原始捕获。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Obtain original capture that generates the body tracking result</span></span><br><span class="line"><span class="keyword">k4a_capture_t</span> originalCapture = k4abt_frame_get_capture(bodyFrame);</span><br></pre></td></tr></table></figure></li></ol><h2 id="简单应用：跳跃分析"><a href="#简单应用：跳跃分析" class="headerlink" title="简单应用：跳跃分析"></a>简单应用：跳跃分析</h2><p>示例工程<a href="https://github.com/microsoft/Azure-Kinect-Samples/tree/master/body-tracking-samples/jump_analysis_sample" target="_blank" rel="noopener">jump_analysis_sample</a>展示了一个有趣的应用。这个应用通过分析跳跃过程中的人体帧数据，计算出跳跃高度、起跳下蹲距离、起跳速度和下蹲膝盖角度等信息。同时，根据这些信息，它还展示出在准备起跳时和在最高点时的状态图，以及整个跳跃过程的动画回放。</p><h3 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h3><p>如何计算速度是整个应用的关键之处。通过速度信息，结合跳跃运动的物理特征，可以获得运动过程各个关键点的位置，例如起跳点和落地点、最高点和最低点。由于人体追踪产生的每一个人体帧都包含所有关节的三维坐标和时间戳信息，该应用巧妙地利用了高度（y方向）对时间的一次导数来计算出垂直速度信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First derivate of height array</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; heightDerivative = DSP::FirstDerivate(heightFiltered);</span><br><span class="line"></span><br><span class="line"><span class="comment">// First derivate of timestamp array</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; timeFirstDerivate = DSP::FirstDerivate(timestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate unit velocity by dh/dt</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; velocityY = DSP::DivideTwoArrays(heightDerivative, timeFirstDerivate);</span><br></pre></td></tr></table></figure><p>有了速度信息之后，可以进一步结合跳跃运动的物理特征，来得出一些有趣的信息。例如，上升过程中最大的速度即为起跳速度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum velocity</span></span><br><span class="line">IndexValueTuple maxVelocityInMmPerUsec = DSP::FindMaximum(velocityY, <span class="number">0</span>, velocityY.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> UsecToSecond = <span class="number">1e-6</span>f;</span><br><span class="line"><span class="comment">// Push off velocity</span></span><br><span class="line">jumpResults.PushOffVelocity = maxVelocityInMmPerUsec.Value / UsecToSecond;</span><br></pre></td></tr></table></figure><h3 id="体感控制"><a href="#体感控制" class="headerlink" title="体感控制"></a>体感控制</h3><p>利用关节信息，还可以用动作来控制程序运行。在这个应用中，只要将双手举过头顶，就可以控制跳跃动作捕获的开始和结束。原理很简单，将手腕关节和头部的y坐标值进行比较就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Notice: y direction is pointing towards the ground! So jointA.y &lt; jointB.y means jointA is higher than jointB</span></span><br><span class="line"><span class="keyword">bool</span> bothHandsAreRaised = leftWristJoint.xyz.y &lt; headJoint.xyz.y &amp;&amp; </span><br><span class="line">                            rightWristJoint.xyz.y &lt; headJoint.xyz.y;</span><br></pre></td></tr></table></figure><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>连接好Kinect，运行程序，看到下方的提示文本，就可以开始尝试啦。</p><img src="/2019/10/08/用Azure-Kinect-DK追踪人体运动/tips.png" title="tips.png"><p>将双手举过头顶，开始录制。完成跳跃后，再次将双手举过头顶结束录制。屏幕上会显示跳跃数据、起跳点和最高点的关键帧以及跳跃回放。</p><img src="/2019/10/08/用Azure-Kinect-DK追踪人体运动/jump-result.png" title="jump-result.png"><img src="/2019/10/08/用Azure-Kinect-DK追踪人体运动/pose.png" title="pose.png"><img src="/2019/10/08/用Azure-Kinect-DK追踪人体运动/replay.gif" title="replay"><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>从上面的例子可以看到，Azure Kinect DK中的人体追踪SDK可以直接用来追踪人体骨架、识别人体位置，能够实时生成关节的三维坐标和方位。不管是离线使用，还是结合Azure使用，都有着丰富的应用场景。</p><ul><li><p>运动员动作分析</p><p>  在运动员的训练中，利用人体追踪数据分析运动动作的准确性和有效性，帮助运动员提升训练成绩。例如，上述的跳跃分析程序就能够用于跳高运动员的动作分析。在训练的时候，运动员可以设定训练目标，例如平均起跳速度、平均跳跃高度、最大跳跃高度等等，然后用Azure Kinect进行人体追踪，多次训练之后计算出平均结果和最优成绩。利用录制功能，运动员还能够结合多次跳跃的回放，分析出最佳起跳点、最佳弧线、最佳动作等等。</p>  <img src="/2019/10/08/用Azure-Kinect-DK追踪人体运动/Highjumpanalysis.jpg" title="Highjumpanalysis"></li><li><p>病人情况监测</p><p>  在医院，监测卧床病人的肢体状况，及时通知医护人员。利用关节的坐标位置，可以判断病人的动作，实现自动化监测与预警。例如，当病人的手腕关节高于头部一定的高度时，可以认为病人举起了手，病人可能需要寻求医护人员的帮助；当病人的部分关节低于床铺高度时，可认为病人有摔下床的风险，应及时通知医护人员。</p>  <img src="/2019/10/08/用Azure-Kinect-DK追踪人体运动/hospital-1.png" title="hospital-1">  <img src="/2019/10/08/用Azure-Kinect-DK追踪人体运动/hospital-2.png" title="hospital-2"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上次我们在介绍Azure Kinect DK时，提到它包含了一个人体追踪SDK。Kinect人体追踪应该不算新鲜，之前Xbox上的体感游戏就已经用到了Kinect的人体追踪功能。新的Azure Kinect DK将人体追踪功能整合到了一个SDK中，方便开发者对人体追踪数据进
      
    
    </summary>
    
    
      <category term="Azure" scheme="https://xungerrrr.github.io/tags/Azure/"/>
    
      <category term="Computer Vision" scheme="https://xungerrrr.github.io/tags/Computer-Vision/"/>
    
  </entry>
  
  <entry>
    <title>用Azure Kinect DK进行深度测量</title>
    <link href="https://xungerrrr.github.io/2019/09/27/%E7%94%A8Azure-Kinect-DK%E8%BF%9B%E8%A1%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E9%87%8F/"/>
    <id>https://xungerrrr.github.io/2019/09/27/用Azure-Kinect-DK进行深度测量/</id>
    <published>2019-09-27T03:01:27.000Z</published>
    <updated>2019-10-12T06:59:32.741Z</updated>
    
    <content type="html"><![CDATA[<p>你可能曾经听说过Kinect，它最初是由微软推出的一款体感外设，主要用在Xbox上，为游戏带来体感交互功能。在2019年，微软更新了Kinect的产品线，推出了全新的Azure Kinect DK。与之前的Kinect不同，Azure Kinect DK并不是针对普通消费者和游戏场景推出，而是专注于商用领域的应用开发，并且强调与AI的融合。</p><p>目前，现有的Kinect for Windows v2应用程序不能直接与Azure Kinect DK配合工作，需要移植到新的SDK。因此，开发者需要了解和学习使用新的SDK。下面，我们先了解一下Azure Kinect DK的基本内容，然后围绕深度测量这一主题来进行探索和学习。</p><h1 id="Azure-Kinect-DK概述"><a href="#Azure-Kinect-DK概述" class="headerlink" title="Azure Kinect DK概述"></a>Azure Kinect DK概述</h1><p>Azure Kinect DK是微软推出的一款开发人员工具包，由配有先进AI传感器的Kinect设备和配套的软件开发工具包（SDK）组成。</p><h2 id="Kinect设备"><a href="#Kinect设备" class="headerlink" title="Kinect设备"></a>Kinect设备</h2><img src="/2019/09/27/用Azure-Kinect-DK进行深度测量/kinect-dk.jpg" title="kinect-dk"><p>Azure Kinect DK硬件主要包含以下的内容：</p><ol><li>100万像素深度传感器，具有宽、窄视场角(FOV)选项，可获取场景的深度数据</li><li>7麦克风阵列，可用于远场语音和声音捕获</li><li>1200万像素RGB摄像头，提供和深度数据匹配的彩色图像数据流</li><li>加速计和陀螺仪(IMU)，可用于传感器方向和空间跟踪</li><li>外部同步引脚，可轻松同步多个Kinect设备的传感器数据流</li></ol><img src="/2019/09/27/用Azure-Kinect-DK进行深度测量/whats-inside.jpg" title="whats-inside"><p>与Kinect for Windows相比，Azure Kinect设备具有更高的硬件规格，同时具备音频、视频、深度和运动传感器，可以全方位感知环境，构建丰富的解决方案。在本文中，我们只关注深度相机和RGB相机的使用。</p><h2 id="软件开发工具包"><a href="#软件开发工具包" class="headerlink" title="软件开发工具包"></a>软件开发工具包</h2><p>Azure Kinect DK的开发环境包含以下的内容：</p><ul><li>用于访问低级别传感器和设备的<a href="https://docs.microsoft.com/zh-cn/azure/kinect-dk/sensor-sdk-download" target="_blank" rel="noopener">传感器SDK</a></li><li>用于跟踪3D人体的<a href="https://docs.microsoft.com/zh-cn/azure/kinect-dk/body-sdk-download" target="_blank" rel="noopener">人体跟踪SDK</a></li><li>用于启用麦克风访问和基于Azure云的语音服务的语音认知服务SDK</li></ul><p>此外，我们还可以结合使用Azure提供的认知视觉服务，为应用赋予强大的视觉感知能力。在本文中，我们只使用了传感器SDK和Azure认知视觉服务。</p><h1 id="深度相机的原理"><a href="#深度相机的原理" class="headerlink" title="深度相机的原理"></a>深度相机的原理</h1><p>深度相机有很多种，Azure Kinect配备的深度相机使用了调幅连续波(AMCW)进行时差测距(ToF)。相机向场景中发射近红外(IR)频谱中的调制光，然后测量光线经场景反射后返回的时间差，从而获取到场景的深度信息。深度相机将原始的调制IR图像传输到电脑主机，电脑通过GPU加速的深度引擎软件将原始信号转换为深度图。深度图是图像每个像素的一组Z坐标值，以毫米为单位。</p><img src="/2019/09/27/用Azure-Kinect-DK进行深度测量/IR.gif" title="IR"><p>Azure Kinect的深度相机支持窄视场(NFOV)和宽视场(WFOV)两种视场模式。窄视场适合X、Y维度范围较小，但Z维度范围较大的场景。宽视场适合X、Y维度范围较大，但Z维度范围较小的场景。如下图，左为窄视场，右为宽视场。</p><img src="/2019/09/27/用Azure-Kinect-DK进行深度测量/FOV.jpg" title="FOV"><h1 id="深度测量"><a href="#深度测量" class="headerlink" title="深度测量"></a>深度测量</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>要使用Azure Kinect DK，首先需要下载和安装<a href="https://docs.microsoft.com/zh-cn/azure/kinect-dk/sensor-sdk-download" target="_blank" rel="noopener">传感器SDK</a>。</p><p>安装完成后，我们通过一份示例代码来演示深度测量的过程。从<a href="https://github.com/microsoft/Azure-Kinect-Samples/tree/master/build2019/csharp" target="_blank" rel="noopener">GitHub</a>下载这里用到的C#示例代码。</p><h2 id="获取图像"><a href="#获取图像" class="headerlink" title="获取图像"></a>获取图像</h2><p>深度测量的第一步是获取图像。通常，深度测量需要用到彩色照片，以便人们直观地理解深度信息与场景内容的对应关系，因此，我们首先要从Kinect设备中获取彩色图像。目录1 - AcquiringImages中的代码演示了这一过程。一般来说，从Kinect中获取图像（彩色图像或深度图），可以分为以下四个步骤。</p><ol><li><p>找到并打开设备</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open the default device</span></span><br><span class="line"><span class="keyword">this</span>.kinect = Device.Open();</span><br></pre></td></tr></table></figure></li><li><p>配置并启动相机</p><p> 这一步主要进行相机的初始化配置，例如颜色空间、分辨率、深度取景模式等等。</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Configure camera modes</span></span><br><span class="line"><span class="keyword">this</span>.kinect.StartCameras(<span class="keyword">new</span> DeviceConfiguration</span><br><span class="line">&#123;</span><br><span class="line">    ColorFormat = ImageFormat.ColorBGRA32,</span><br><span class="line">    ColorResolution = ColorResolution.R1080p,</span><br><span class="line">    DepthMode = DepthMode.NFOV_2x2Binned,</span><br><span class="line">    SynchronizedImagesOnly = <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>从设备获取捕获(Capture)</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Capture capture = <span class="keyword">await</span> Task.Run(() =&gt; &#123; <span class="keyword">return</span> <span class="keyword">this</span>.kinect.GetCapture(); &#125;)</span><br></pre></td></tr></table></figure></li><li><p>从捕获中获取图像</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = capture.Color;</span><br></pre></td></tr></table></figure></li></ol><p>捕获和图像的关系是什么呢？简单来说，捕获包含了图像。图像是以关联的方式捕获的，每一个捕获包含了一个时间戳所对应的一组深度图、IR图像和彩色图像。下面是从捕获中获取的一张彩色图像。</p><img src="/2019/09/27/用Azure-Kinect-DK进行深度测量/1-AcquiringImages.png" title="1-AcquiringImages"><h2 id="图像转换"><a href="#图像转换" class="headerlink" title="图像转换"></a>图像转换</h2><p>深度相机和彩色相机是相互独立的传感器，因此它们有各自独立的坐标系，视角和视点也会有所不同。通常，我们希望将两种图像的数据结合起来使用，以方便理解深度信息。图像转换的目的就是通过一定的变换，将一个相机的视点转换到另一个相机的视点上。</p><p>传感器SDK为我们提供了这样的转换函数。目录2 - TransformDepthToColor中的代码演示了从深度相机到彩色相机的视点转换。这个过程可以大致分为以下三个步骤。</p><ol><li><p>首先，加载Azure Kinect的图像转换引擎</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> Azure Kinect transformation engine</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> Transformation transform = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>初始化一个空图像，用来存放转换后的深度图</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Image transformedDepth = <span class="keyword">new</span> Image(</span><br><span class="line">    ImageFormat.Depth16, colorWidth, colorHeight, colorWidth * <span class="keyword">sizeof</span>(UInt16))</span><br></pre></td></tr></table></figure></li><li><p>调用SDK函数DepthImageToColorCamera，传入捕获和空图像进行转换</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.transform.DepthImageToColorCamera(capture, transformedDepth);</span><br></pre></td></tr></table></figure></li></ol><p>这样就可以将深度图像变换到彩色相机的视点上，使深度图和彩色图的像素能够一一对应。下面是转换后的深度图。</p><img src="/2019/09/27/用Azure-Kinect-DK进行深度测量/2-TransformDepthToColor.png" title="2-TransformDepthToColor"><p>有了转换后的深度图像和对应的彩色图像，我们就可以开始进行深度测量了。通过深度图的像素值，我们就可以获取彩色图上任意一点(x, y)的深度了！像这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transformedDepth.GetPixel&lt;<span class="keyword">ushort</span>&gt;(y, x)</span><br></pre></td></tr></table></figure><h2 id="简单的深度测量应用"><a href="#简单的深度测量应用" class="headerlink" title="简单的深度测量应用"></a>简单的深度测量应用</h2><h3 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h3><p>利用深度信息，一个简单的应用是前景背景的分割。目录3 - SegmentColor中的代码演示了分割图像前景的过程。</p><p>由于拥有深度信息，我们可以设置一个距离阈值（如1000，单位为毫米）。当像素的深度值小于阈值，则认为其属于前景，保持像素颜色不变。反之则属于背景，将像素的颜色值置为0。这样就实现了简单的前景分割。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.colorHeight * <span class="keyword">this</span>.colorWidth; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (depthPixels[i] &lt; <span class="number">1000</span> &amp;&amp;</span><br><span class="line">        depthPixels[i] != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    colorPixels[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能将前景分割出来啦。</p><img src="/2019/09/27/用Azure-Kinect-DK进行深度测量/3-SegmentColor.png" title="3-SegmentColor"><h3 id="测量物体的距离"><a href="#测量物体的距离" class="headerlink" title="测量物体的距离"></a>测量物体的距离</h3><p>有了丰富的场景数据，如果能加上一点图像理解的能力就更好了。使用微软Azure的认知服务，能够很方便地为应用添加智能。在这里，我们使用Azure上的计算机视觉服务，可以直接使用预训练好的通用视觉模型，为应用增加视觉感知能力。</p><p>目录4 - CognitiveServices中的工程演示了一个测量人体距离的应用。要测量人体距离，当然需要先进行人体检测。使用认知视觉服务，对彩色图片进行分析，可以轻松进行物体检测。当在图片中检测到人体时，利用深度信息就可以计算出摄像头到人的距离了。为了方便拍摄，我对识别的目标做了一点小修改，将识别人体改为识别背包。同时，为了方便理解，我将视觉服务返回的物体位置用红色矩形标记了出来。</p><p>如果你想要自己跑这个程序，需要有有效的Azure订阅，并且创建一个计算机视觉资源。之后，还要将代码中的subscriptionKey和Endpoint替换为自己资源中的信息。</p><p>应用的逻辑可以划分为以下几个步骤：</p><ol><li><p>实例化计算机视觉客户端</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the computer vision client</span></span><br><span class="line">computerVision = <span class="keyword">new</span> ComputerVisionClient(</span><br><span class="line">    <span class="keyword">new</span> ApiKeyServiceClientCredentials(subscriptionKey),</span><br><span class="line">    <span class="keyword">new</span> System.Net.Http.DelegatingHandler[] &#123; &#125;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// You must use the same region as you used to get  </span></span><br><span class="line">        <span class="comment">// your subscription keys. </span></span><br><span class="line">        Endpoint = <span class="string">"YourEndpoint"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>转换深度图像到彩色相机视点</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.transform.DepthImageToColorCamera(capture, transformedDepth);</span><br></pre></td></tr></table></figure></li><li><p>分析图像，获取背包物体的包围盒</p><p> 在图像分析的结果里，有一个物体的集合，里面包含了检测出的所有物体。每一个物体都有一个属性和表示位置的矩形，这里我用”Luggage and bags”属性来检测背包，并且将矩形绘制出来。</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_ = computerVision.AnalyzeImageInStreamAsync(stream, MainWindow.features).ContinueWith((Task&lt;ImageAnalysis&gt; analysis) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> analysis.Result.Objects)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.ObjectProperty == <span class="string">"Luggage and bags"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.boundingBox = item.Rectangle;</span><br><span class="line">                rectangle.Rect = <span class="keyword">new</span> Rect(<span class="keyword">this</span>.boundingBox.X, <span class="keyword">this</span>.boundingBox.Y, <span class="keyword">this</span>.boundingBox.W, <span class="keyword">this</span>.boundingBox.H);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (System.Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.StatusText = ex.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, TaskScheduler.FromCurrentSynchronizationContext());</span><br></pre></td></tr></table></figure></li><li><p>取包围盒的中心点的深度值，得到摄像头到背包的距离</p><p> 从计算过程来看，x和y分别是矩形中心的横坐标和纵坐标。通过获取这个坐标的深度值，就得到了背包的距离。</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (boundingBox != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> y = (boundingBox.Y + boundingBox.H / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> x = (boundingBox.X + boundingBox.W / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.StatusText = <span class="string">"The bag is: "</span> + transformedDepth.GetPixel&lt;<span class="keyword">ushort</span>&gt;(y, x) + <span class="string">"mm away"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>最终的显示效果是这样的，红色矩形标识了背包的位置，下方的文字显示背包距离摄像头601毫米。</p><img src="/2019/09/27/用Azure-Kinect-DK进行深度测量/bag.png" title="bag"><p>通过下面的3D图像能更容易理解这个过程。首先，计算机视觉服务在二维图片中识别出了一个背包，用矩形标记了背包的位置。我们可能会将这个矩形想象成一个平面图形，即图中的黄色矩形。但是，从深度相机（红色圆点）的角度来看，这个矩形包含了三维中的一个锥形空间，即图中的红色区域。红色圆点到白色曲面上不同点的距离，组成了场景的深度信息。通过获取矩形中心点的深度值，我们实际上获得了图中蓝色线段的长度。</p><img src="/2019/09/27/用Azure-Kinect-DK进行深度测量/3D.png" title="3D"><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>从上面的例子可以看到，传感器SDK提供了对硬件传感器流的低级访问，使用SDK可以获得一些基础数据，例如深度图、音频流和陀螺仪数据等。利用转换后的深度图，我们可以进行深度测量、图像分割，结合Azure认知服务还可以测量特定物体的距离。在实际的商用领域中，深度测量能有怎样的应用场景呢？下面给出一些设想和实现思路。</p><h2 id="物流信息自动识别"><a href="#物流信息自动识别" class="headerlink" title="物流信息自动识别"></a>物流信息自动识别</h2><p>在物流仓库，可以结合Azure的计算机视觉服务，自动测量包裹的尺寸。将Kinect设置在物流流水线上，持续将捕获画面上传到云端进行分析。当有包裹经过时，云端会返回物体识别的结果，包括包裹的边缘位置信息。利用包裹的边缘位置，深度相机可以获取包裹四个顶点的深度值，然后计算出包裹的长宽大小。根据测量的大小，可以统计出所有包裹的尺寸，合理设置车辆的装箱方案。</p><p>此外，可以结合文本识别服务，实现光学字符识别（OCR），自动识别出包裹的运单信息，快速分发包裹。例如，某物流公司的运单信息都贴在包裹的一个指定位置上。当有包裹经过时，我们将包裹图片上传到文本识别服务。云服务可以针对运单信息的部分进行字符识别，并返回识别结果。这样，可以自动将包裹分类，提高物流管理速度。</p><img src="/2019/09/27/用Azure-Kinect-DK进行深度测量/shipment.png" title="shipment"><h2 id="环境三维重建"><a href="#环境三维重建" class="headerlink" title="环境三维重建"></a>环境三维重建</h2><p>仅通过一个Kinect设备在一个角度进行采集，获得的数据是不足够的。在某些情况下，深度测量会出现失效，例如多径干扰、信号饱和或信号强度过低。通过多个Kinect设备，多次采集场景数据，能够避免出现测量死角。</p><img src="/2019/09/27/用Azure-Kinect-DK进行深度测量/capture-3D.png" title="capture-3D"><p>将多次测量的深度数据整合起来，甚至可以重建场景的三维模型。这对于文物保存、建筑评估等领域是非常有用的。</p><img src="/2019/09/27/用Azure-Kinect-DK进行深度测量/reconstruction.jpeg" title="reconstruction"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Azure Kinect DK和之前的Kinect for Windows有什么不同？一方面，Azure Kinect有着更高规格的硬件，例如更强的陀螺仪和更丰富的深度相机模式，更适合于工业使用。另一方面，Azure Kinect将基本功能集成在两个SDK中，而更高级的功能，例如人脸追踪、语音识别等，则通过与Azure认知服务连接来实现。通过Azure云计算，能够更快地进行数据分析和处理，服务的部署也更方便。</p><p>从上手来看，目前Azure Kinect DK主要涉及Azure认知服务的视觉和语音服务，但是，深度相机和云的结合还不是很密切。深度信息的分析和处理，例如深度图的生成，都是在本地运算生成。官网给出的样例中，视觉服务只用于分析彩色图片，没有利用到深度图片。将深度数据与认知服务结合，可能会有更多的应用前景，例如，利用深度数据的变化预测物体的运动轨迹。相信随着SDK的不断完善，Azure Kinect DK会在工业落地实际应用中发挥更大的潜力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你可能曾经听说过Kinect，它最初是由微软推出的一款体感外设，主要用在Xbox上，为游戏带来体感交互功能。在2019年，微软更新了Kinect的产品线，推出了全新的Azure Kinect DK。与之前的Kinect不同，Azure Kinect DK并不是针对普通消费者
      
    
    </summary>
    
    
      <category term="Azure" scheme="https://xungerrrr.github.io/tags/Azure/"/>
    
      <category term="Computer Vision" scheme="https://xungerrrr.github.io/tags/Computer-Vision/"/>
    
  </entry>
  
  <entry>
    <title>用例建模总结</title>
    <link href="https://xungerrrr.github.io/2019/06/30/%E7%94%A8%E4%BE%8B%E5%BB%BA%E6%A8%A1%E6%80%BB%E7%BB%93/"/>
    <id>https://xungerrrr.github.io/2019/06/30/用例建模总结/</id>
    <published>2019-06-30T05:22:24.000Z</published>
    <updated>2019-09-27T03:07:06.431Z</updated>
    
    <content type="html"><![CDATA[<p>需求分析是软件生命周期的一项重要内容，它是每一次项目迭代的开端，奠定了软件设计的基础。在系统分析与设计的课程项目“挣闲钱”中，我使用了用例建模的方法进行需求分析。在项目中，我第一次接触系统性的需求分析方法，了解到了用例建模的重要性。本文对项目中的用例建模方法进行了总结。</p><h2 id="用例建模的制品"><a href="#用例建模的制品" class="headerlink" title="用例建模的制品"></a>用例建模的制品</h2><p>相对于传统的软件需求规约，用例建模的优点是能够从用户的角度出发，使用自然语言文本和图表来描述系统业务的功能，清晰表达系统需求。用例建模一般包含以下制品：</p><ul><li>系统上下文图</li><li>用例描述<ul><li>用例文本</li><li>业务流程</li><li>故事板</li></ul></li></ul><p>在本项目中，系统上下文图采用了面向对象的UML用例图。业务流程使用UML活动图表示。由于我没有参与UI设计，因此故事板部分不展开描述。</p><h2 id="UML用例图"><a href="#UML用例图" class="headerlink" title="UML用例图"></a>UML用例图</h2><p>用例图使用<a href="https://www.umlet.com/" target="_blank" rel="noopener">UMLet</a>绘制。</p><p>绘制用例图是一个识别需求的过程，能够帮助组织确定系统的范围、对象、外部系统，也能够方便工作量的评估。</p><p>用例图的绘制分为以下几个步骤：</p><ol><li>确定系统</li></ol><p>系统是我们研究问题的边界，应包含涉及到的所有用例。在“挣闲钱”项目中，我们的系统命名为挣闲钱系统。</p><ol start="2"><li>识别Actors</li></ol><p>系统参与者，用actor符号表示，放在系统左边。挣闲钱系统的受众是大学生，用户既可以发布任务也可以接受任务，因此我们的用例图只有一类参与者。</p><p>外部系统，用NeighbourSystem框表示。一个系统不可能是大而全的，它应该只包含与核心功能直接相关的用例，其余逻辑交由外部系统来完成。在我的建模中，用户管理和交易管理两部分比较复杂，因此抽离出来成为独立的外部系统。</p><ol start="3"><li>识别用例</li></ol><p>首先要确定的是用户级别的用例，即最顶层的用例。在我们的迭代会议中，初步确定了问卷填写和有赏问答两大业务。据此我提出了一些与用户直接相关的用例，如完成问答任务、发起提问等，也考虑了一系列的manage用例，例如管理提问、管理余额等等。</p><p>接下来需要识别子功能级别的用例，一般是将父用例进行功能分解。识别过程要注意父用例和子用例的关系，一般有&lt;<include>&gt;和&lt;<extend>&gt;两种。前者表示父用例必不可少的部分，后者表示可选用例。例如在输入问卷时，添加问题是一个必须的场景，删除已经添加的问题则不是一个必做功能。</extend></include></p><ol start="4"><li>建立Actor与用例之间的关联</li></ol><p>使用无方向连线，表示双向交互的协议。</p><p>下面是我针对“挣闲钱系统”绘制的系统用例图。</p><img src="/2019/06/30/用例建模总结/use_case_v2.png" title="use_case_v2"><h2 id="用例描述"><a href="#用例描述" class="headerlink" title="用例描述"></a>用例描述</h2><p>用例图只是简单的理清了用例之间的关系。为了详细对用例进行建模，还需要对用例的描述。我主要完成了用例文本和UML活动图两部分。</p><h3 id="用例文本"><a href="#用例文本" class="headerlink" title="用例文本"></a>用例文本</h3><p>RUP用例规约模板包含以下内容：</p><ul><li><p>简要说明 (Brief Description) </p><p>简要介绍该用例的作用和目的。</p></li><li><p>事件流 (Flow of Event) </p><p>包括基本流和备选流，事件流应该表示出所有的场景。</p></li><li><p>用例场景 (Use-Case Scenario) </p><p>包括成功场景和失败场景，场景主要是由基本流和备选流组合而成的。</p></li><li><p>特殊需求 (Special Requirement) </p><p>描述与该用例相关的非功能性需求（包括性能、可靠性、可用性和可扩展性等）和设计约束（所使用的操作系统、开发工具等）。</p></li><li><p>前置条件 (Pre-Condition) </p><p>执行用例之前系统必须所处的状态。</p></li><li><p>后置条件 (Post-Condition) </p><p>用例执行完毕后系统可能处于的一组状态。</p></li></ul><p>根据该模板可以用文本详细描述一个用例。以最简单的注册登录为例，用例可以描述为：</p><table><thead><tr><th style="text-align:center">用例名称</th><th style="text-align:center">注册登录</th></tr></thead><tbody><tr><td style="text-align:center">范围</td><td style="text-align:center">Web网页</td></tr><tr><td style="text-align:center">级别</td><td style="text-align:center">用户目标</td></tr><tr><td style="text-align:center">主要参与者</td><td style="text-align:center">用户</td></tr><tr><td style="text-align:center">涉众及其关注点</td><td style="text-align:center">用户：希望能注册为挣闲钱平台的用户，登录系统发布任务或接收任务，获得收益</td></tr><tr><td style="text-align:center">前置条件</td><td style="text-align:center">用户了解登录注册的流程和需要填写的信息</td></tr><tr><td style="text-align:center">后置条件</td><td style="text-align:center">用户填写的信息无误，邮箱不与已有邮箱冲突</td></tr><tr><td style="text-align:center">主成功场景</td><td style="text-align:center">用户打开网页，填写昵称、邮箱和密码进行注册，邮箱不重复则注册成功；用户通过注册的邮箱和密码进行登录。</td></tr><tr><td style="text-align:center">扩展</td><td style="text-align:center">两次输入密码不一致，提醒密码错误；邮箱重复，提醒邮箱已注册。</td></tr><tr><td style="text-align:center">特殊需求</td><td style="text-align:center">界面美观，有明显的报错提醒</td></tr><tr><td style="text-align:center">发生频率</td><td style="text-align:center">经常发生</td></tr><tr><td style="text-align:center">未决问题</td><td style="text-align:center">邮箱验证问题</td></tr></tbody></table><h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><p>文本往往不能很好地描述用例的事件流，使用活动图可以更清晰地表达复杂的流程。以注册登录为例，用例涉及邮箱重复、密码不一致等判断过程，活动图表示更为直观。</p><img src="/2019/06/30/用例建模总结/register_login.png" title="register_login"><p>另外，如果用例涉及到多个角色，可以采用多泳道图来更清晰地表示角色之间的交互业务。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用例建模从用户的角度出发，将分析和设计分离，能清晰表达系统的业务和功能需求。用例图清晰地展示了系统的功能组成，客户可以清楚地看到系统与自己的要求是否相符。同时，客户可以简单修改用例图来表达需求变更的想法。用例图明确地表达了用户的需求，因此系统架构的设计可以更加准确，同时系统的工作量评估也变得方便。在测试阶段，测试人员也可以根据用例设计测试用例，对系统进行全面的测试。</p><p>不过，用例建模需要的工作量是很大的，特别是当系统需要复杂和严谨的结构时，用例建模会花费大量的时间，在小型项目的开发上可能会降低开发效率。</p><h2 id="项目文档"><a href="#项目文档" class="headerlink" title="项目文档"></a>项目文档</h2><p><a href="https://code-flows-in-you.github.io/Dashboard/" target="_blank" rel="noopener">Earning Money</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://sysu-swsad.github.io/swad-guide/05-first-iteration" target="_blank" rel="noopener">软件系统分析与设计指南：组织第一次迭代</a></p><p>[2] <a href="https://sysu-swsad.github.io/swad-guide/06-usecase-modeling" target="_blank" rel="noopener">软件系统分析与设计指南：用例建模 - 绘制用例图</a></p><p>[3] <a href="https://sysu-swsad.github.io/swad-guide/07-usecase-modeling" target="_blank" rel="noopener">软件系统分析与设计指南：用例建模 - 业务建模方法</a></p><p>[4] <a href="https://www.ibm.com/developerworks/cn/rational/r-usecase-atm/" target="_blank" rel="noopener">用例建模指南</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;需求分析是软件生命周期的一项重要内容，它是每一次项目迭代的开端，奠定了软件设计的基础。在系统分析与设计的课程项目“挣闲钱”中，我使用了用例建模的方法进行需求分析。在项目中，我第一次接触系统性的需求分析方法，了解到了用例建模的重要性。本文对项目中的用例建模方法进行了总结。&lt;/
      
    
    </summary>
    
    
      <category term="SE" scheme="https://xungerrrr.github.io/tags/SE/"/>
    
  </entry>
  
  <entry>
    <title>Bezier Curve</title>
    <link href="https://xungerrrr.github.io/2019/05/29/Bezier-Curve/"/>
    <id>https://xungerrrr.github.io/2019/05/29/Bezier-Curve/</id>
    <published>2019-05-29T09:51:34.000Z</published>
    <updated>2019-05-29T11:13:06.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><h3 id="捕捉指针的移动"><a href="#捕捉指针的移动" class="headerlink" title="捕捉指针的移动"></a>捕捉指针的移动</h3><p>定义一个回调函数mouse_callback，记录指针的位置信息。用glfwSetCursorPosCallback绑定回调函数，就能在鼠标移动时，捕捉到指针的实时坐标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span> </span>&#123;</span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetCursorPosCallback(window, mouse_callback);</span><br></pre></td></tr></table></figure><h3 id="捕捉鼠标的点击"><a href="#捕捉鼠标的点击" class="headerlink" title="捕捉鼠标的点击"></a>捕捉鼠标的点击</h3><p>定义一个回调函数mouse_button_callback，处理鼠标的点击事件。首先，要将指针坐标转换成OpenGL的标准坐标，范围是[-1, 1]。然后，根据按键的不同调用不同的函数。点击左键时，调用addPoint添加一个控制点；点击右键时，调用deletePoint删除最后一个控制点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_button_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> button, <span class="keyword">int</span> action, <span class="keyword">int</span> mods)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == GLFW_PRESS) &#123;</span><br><span class="line">        <span class="keyword">float</span> clickX = (lastX - windowWidth / <span class="number">2</span>) / (windowWidth / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">float</span> clickY = -(lastY - windowHeight / <span class="number">2</span>) / (windowHeight / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">switch</span> (button) &#123;</span><br><span class="line">            <span class="keyword">case</span> GLFW_MOUSE_BUTTON_LEFT:</span><br><span class="line">                addPoint(clickX, clickY);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GLFW_MOUSE_BUTTON_RIGHT:</span><br><span class="line">                deletePoint();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用glfwSetMouseButtonCallback绑定回调函数，就能捕获鼠标点击事件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetMouseButtonCallback(window, mouse_button_callback);</span><br></pre></td></tr></table></figure><h2 id="控制点的变化"><a href="#控制点的变化" class="headerlink" title="控制点的变化"></a>控制点的变化</h2><h3 id="控制点的增加"><a href="#控制点的增加" class="headerlink" title="控制点的增加"></a>控制点的增加</h3><p>要增加控制点，先按照顶点数组的格式创建一个包含坐标信息的vector，然后将这个vector插入到控制点vector中。添加完之后，调用calculateBezier函数重新计算bezier曲线，做到实时更新曲线。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addPoint</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; newPoint = &#123; x, y, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    controlPoints.insert(controlPoints.end(), newPoint.begin(), newPoint.end());</span><br><span class="line">    calculateBezier();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制点的删除"><a href="#控制点的删除" class="headerlink" title="控制点的删除"></a>控制点的删除</h3><p>根据定义的顶点数组格式，要删除最后一个控制点，只需要删除控制点vector最后6个元素即可。删除之后，调用calculateBezier函数重新计算bezier曲线，做到实时更新曲线。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletePoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!controlPoints.empty()) &#123;</span><br><span class="line">        controlPoints.erase(controlPoints.begin() + controlPoints.size() - <span class="number">6</span>, controlPoints.end());</span><br><span class="line">        calculateBezier();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bezier曲线的计算"><a href="#Bezier曲线的计算" class="headerlink" title="Bezier曲线的计算"></a>Bezier曲线的计算</h2><p>首先，要清空原有的bezier曲线。然后，根据Bezier曲线的公式计算即可，其中bernstein函数是伯恩斯坦基函数。t的增加步长设为0.0001。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculateBezier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bezierPoints.clear();</span><br><span class="line">    <span class="keyword">int</span> n = controlPoints.size() / <span class="number">6</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">float</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t += <span class="number">0.0001</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">float</span> b = bernstein(i, n, t);</span><br><span class="line">                x += controlPoints[i * <span class="number">6</span>] * b;</span><br><span class="line">                y += controlPoints[i * <span class="number">6</span> + <span class="number">1</span>] * b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; newPoint = &#123; x, y, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">            bezierPoints.insert(bezierPoints.end(), newPoint.begin(), newPoint.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">bernstein</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">float</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        result *= ((<span class="keyword">float</span>)(n - j) / (<span class="keyword">float</span>)(i - j));</span><br><span class="line">    &#125;</span><br><span class="line">    result *= <span class="built_in">pow</span>(t, i) * <span class="built_in">pow</span>(<span class="number">1</span> - t, n - i);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><h3 id="显示控制点"><a href="#显示控制点" class="headerlink" title="显示控制点"></a>显示控制点</h3><p>用GL_POINTS图元，绘制控制点数组中的所有点，用GL_LINE_STRIP图元绘制相邻控制点的连线。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!controlPoints.empty()) &#123;</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, windowWidth, windowHeight);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;pointVBO);</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;pointVAO);</span><br><span class="line">    glBindVertexArray(pointVAO);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, pointVBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * controlPoints.size(), &amp;controlPoints[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">    glPointSize(<span class="number">10</span>);</span><br><span class="line">    glDrawArrays(GL_POINTS, <span class="number">0</span>, controlPoints.size() / <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; controlPoints.size() / <span class="number">6</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        glDrawArrays(GL_LINE_STRIP, i, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显示Bezier曲线"><a href="#显示Bezier曲线" class="headerlink" title="显示Bezier曲线"></a>显示Bezier曲线</h3><p>用GL_POINTS图元，绘制Bezier曲线数组里面的所有点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!bezierPoints.empty()) &#123;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;bezierVBO);</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;bezierVAO);</span><br><span class="line">    glBindVertexArray(bezierVAO);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, bezierVBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(<span class="keyword">float</span>)* bezierPoints.size(), &amp;bezierPoints[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">    glPointSize(<span class="number">1</span>);</span><br><span class="line">    glDrawArrays(GL_POINTS, <span class="number">0</span>, bezierPoints.size() / <span class="number">6</span>);</span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2019/05/29/Bezier-Curve/result.gif" title="result"><h2 id="Bonus：动态呈现Bezier曲线的生成过程"><a href="#Bonus：动态呈现Bezier曲线的生成过程" class="headerlink" title="Bonus：动态呈现Bezier曲线的生成过程"></a>Bonus：动态呈现Bezier曲线的生成过程</h2><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>根据Bezier曲线的原理，每一层的辅助线由该层相邻的辅助点连接而成，每一层的辅助点是由上一层的每一条辅助线取比例t所得，最顶层的辅助点和辅助线是之前画出的控制点和控制线，最底层的辅助点就是比例t对应的Bezier曲线上的点。根据这个原理和t的值，可以通过两层循环算出所有的辅助点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getVisualizePoints</span><span class="params">(<span class="keyword">float</span> t)</span> </span>&#123;</span><br><span class="line">    visualizePoints = <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;(controlPoints);</span><br><span class="line">    <span class="keyword">int</span> n = controlPoints.size() / <span class="number">6</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">float</span> x = (<span class="number">1</span> - t) * visualizePoints[(j + offset) * <span class="number">6</span>] + t * visualizePoints[(j + <span class="number">1</span> + offset) * <span class="number">6</span>];</span><br><span class="line">            <span class="keyword">float</span> y = (<span class="number">1</span> - t) * visualizePoints[(j + offset) * <span class="number">6</span> + <span class="number">1</span>] + t * visualizePoints[(j + <span class="number">1</span> + offset) * <span class="number">6</span> + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; newPoint = &#123; x, y, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">            visualizePoints.insert(visualizePoints.end(), newPoint.begin(), newPoint.end());</span><br><span class="line">        &#125;</span><br><span class="line">        offset += (n - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显示-1"><a href="#显示-1" class="headerlink" title="显示"></a>显示</h3><p>在渲染循环中，通过时间来控制t的值，使t从0到1循环变化。然后，调用getVisualizePoints获得所有的辅助点。最后，用GL_LINE_STRIP图元绘制所有的辅助线，用GL_POINTS图元绘制所有的辅助点。绘制过程与控制点的绘制类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> t = (<span class="keyword">float</span>)(time - (<span class="keyword">int</span>)time / <span class="number">10</span> * <span class="number">10</span>) / <span class="number">10</span>;</span><br><span class="line">getVisualizePoints(t);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!visualizePoints.empty()) &#123;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;visualizeVBO);</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;visualizeVAO);</span><br><span class="line">    glBindVertexArray(visualizeVAO);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, visualizeVBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(<span class="keyword">float</span>)* visualizePoints.size(), &amp;visualizePoints[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n = controlPoints.size() / <span class="number">6</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">float</span> offset = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            glDrawArrays(GL_LINE_STRIP, j + offset, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        offset += (n - i);</span><br><span class="line">    &#125;</span><br><span class="line">    glPointSize(<span class="number">5</span>);</span><br><span class="line">    glDrawArrays(GL_POINTS, <span class="number">0</span>, visualizePoints.size() / <span class="number">6</span>);</span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2019/05/29/Bezier-Curve/bonus.gif" title="bonus">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;鼠标事件&quot;&gt;&lt;a href=&quot;#鼠标事件&quot; class=&quot;headerlink&quot; title=&quot;鼠标事件&quot;&gt;&lt;/a&gt;鼠标事件&lt;/h2&gt;&lt;h3 id=&quot;捕捉指针的移动&quot;&gt;&lt;a href=&quot;#捕捉指针的移动&quot; class=&quot;headerlink&quot; title=&quot;捕捉指
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Shadow Mapping</title>
    <link href="https://xungerrrr.github.io/2019/05/13/Shadow-Mapping/"/>
    <id>https://xungerrrr.github.io/2019/05/13/Shadow-Mapping/</id>
    <published>2019-05-13T06:27:28.000Z</published>
    <updated>2019-05-13T15:38:18.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shadow-Mapping阴影渲染"><a href="#Shadow-Mapping阴影渲染" class="headerlink" title="Shadow Mapping阴影渲染"></a>Shadow Mapping阴影渲染</h2><p>Shadow Mapping阴影渲染分为两个步骤：</p><ol><li>以光源视角渲染场景，得到深度图（Shadow Map)，存储为纹理；</li><li>以观察视角再次渲染场景，将每个点的深度值和Shadow Map中的深度值进行比较，判断点是否在阴影内。</li></ol><h3 id="获取Shadow-Map"><a href="#获取Shadow-Map" class="headerlink" title="获取Shadow Map"></a>获取Shadow Map</h3><h4 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h4><p>首先来设计着色器。因为要在光源视角渲染场景，所以顶点着色器只需要将坐标变换到光源视角空间并输出即可。使用一个变换矩阵即可完成变换。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> lightSpaceMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = lightSpaceMatrix * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于片段着色器，因为只需要获取深度信息而不需要颜色信息，所以可以使用一个空的片段着色器。</p><h4 id="存储Shadow-Map"><a href="#存储Shadow-Map" class="headerlink" title="存储Shadow Map"></a>存储Shadow Map</h4><p>为了获得Shadow Map，我们需要将渲染的深度信息存到一个2D纹理中。需要借助帧缓冲对象和纹理来实现。</p><p>首先，创建一个2D纹理。因为我们只需要存储深度值，所以将纹理格式设置为GL_DEPTH_COMPONENT。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> depthMap;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SHADOW_WIDTH = <span class="number">4096</span>, SHADOW_HEIGHT = <span class="number">4096</span>;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;depthMap);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, depthMap);</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT,</span><br><span class="line">    SHADOW_WIDTH, SHADOW_HEIGHT, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br></pre></td></tr></table></figure><p>然后，创建一个帧缓冲对象，将纹理绑定为帧缓冲的深度缓冲。因为不需要颜色缓冲，所以通过调用glDrawBuffer(GL_NONE)和glReadBuffer(GL_NONE)说明不用颜色进行渲染。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> depthMapFBO;</span><br><span class="line">glGenFramebuffers(<span class="number">1</span>, &amp;depthMapFBO);</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line">glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, <span class="number">0</span>);</span><br><span class="line">glDrawBuffer(GL_NONE);</span><br><span class="line">glReadBuffer(GL_NONE);</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="光源空间变换"><a href="#光源空间变换" class="headerlink" title="光源空间变换"></a>光源空间变换</h4><p>在顶点着色器中，用到了一个变换矩阵，将世界坐标变换到光源视角。变换矩阵由投影矩阵和视角矩阵相乘得到。</p><p>对于平行光，可以采用正交投影，通过glm::ortho定义矩阵。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> near_plane = <span class="number">1.0f</span>, far_plane = <span class="number">100.0f</span>;</span><br><span class="line">glm::mat4 lightProjection = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">lightProjection = glm::ortho(<span class="number">-10.0f</span>, <span class="number">10.0f</span>, <span class="number">-10.0f</span>, <span class="number">10.0f</span>, near_plane, far_plane);</span><br></pre></td></tr></table></figure><p>通过glm::lookAt函数，创建观察矩阵，从光源位置看向坐标原点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::<span class="function">vec3 <span class="title">lightPos</span><span class="params">(<span class="number">-3.0f</span>, <span class="number">4.0f</span>, <span class="number">-1.0f</span>)</span></span>;</span><br><span class="line">glm::mat4 lightView = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">lightView = glm::lookAt(lightPos, glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>));</span><br></pre></td></tr></table></figure><p>相乘得到变换矩阵。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 lightSpaceMatrix = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">lightSpaceMatrix = lightProjection * lightView;</span><br></pre></td></tr></table></figure><h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>通过glBindFramebuffer绑定帧缓冲，在函数renderScene中渲染场景。渲染完成后深度信息就存储到了纹理中，得到Shadow Map。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">depthShader.use();</span><br><span class="line">depthShader.setMat4(<span class="string">"lightSpaceMatrix"</span>, lightSpaceMatrix);</span><br><span class="line"></span><br><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line">glClear(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">renderScene(depthShader, planeVAO, cubeVAO);</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="阴影计算（Shadow-Mapping算法）"><a href="#阴影计算（Shadow-Mapping算法）" class="headerlink" title="阴影计算（Shadow Mapping算法）"></a>阴影计算（Shadow Mapping算法）</h3><p>下一步，需要从观察视角进行渲染，从光源视角对像素深度和Shadow Map中对应位置的值进行比较。如果深度大于Shadow Map的值，说明该点在其他物体后，处在阴影内。反之则不在阴影内。</p><h4 id="着色器-1"><a href="#着色器-1" class="headerlink" title="着色器"></a>着色器</h4><p>顶点着色器与实现Phong光照模型的顶点着色器相似。不过，因为要比较深度值判断片段是否在阴影内，所以顶点着色器还需要输出片段变换到光源视角空间的坐标。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs_out.FragPosLightSpace = lightSpaceMatrix * <span class="type">vec4</span>(vs_out.FragPos, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>片段着色器与实现Phong光照模型的片段着色器相似。不过，片段着色器还需要计算片段是否在阴影内。</p><p>首先，需要将光源视角空间的坐标进行标准化，变换到[0, 1]之间。z坐标即是当前的深度。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"><span class="type">float</span> currentDepth = projCoords.z;</span><br></pre></td></tr></table></figure><p>然后，获取Shadow Map中的深度信息。比较当前深度和最近深度，判断片段是否在阴影内。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> closestDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy).r; </span><br><span class="line"><span class="type">float</span> shadow = currentDepth &gt; closestDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><p>如果在阴影内，则只显示环境光。否则按照Phong光照模型进行渲染。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> lighting = (ambient + (<span class="number">1.0</span> - shadow) * (diffuse + specular)) * color;</span><br></pre></td></tr></table></figure><h4 id="渲染-1"><a href="#渲染-1" class="headerlink" title="渲染"></a>渲染</h4><p>渲染的方法与之前的类似。在渲染前，需要绑定两个纹理。一个是物体的纹理，这里使用了木地板纹理。另一个是第一步得到的Shadow Map，用于计算阴影。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, woodTexture);</span><br><span class="line">glActiveTexture(GL_TEXTURE1);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, depthMap);</span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><img src="/2019/05/13/Shadow-Mapping/1.png" title="pic1"><h2 id="增加光源在透视投影下的Shadow-Mapping"><a href="#增加光源在透视投影下的Shadow-Mapping" class="headerlink" title="增加光源在透视投影下的Shadow Mapping"></a>增加光源在透视投影下的Shadow Mapping</h2><p>通过ImGui选择投影方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ImGui::Begin(<span class="string">"Projection Type"</span>);</span><br><span class="line">ImGui::BeginGroup();</span><br><span class="line">ImGui::RadioButton(<span class="string">"Orthogonal"</span>, &amp;projectionType, <span class="number">1</span>);</span><br><span class="line">ImGui::RadioButton(<span class="string">"Perspective"</span>, &amp;projectionType, <span class="number">2</span>);</span><br><span class="line">ImGui::EndGroup();</span><br><span class="line">ImGui::End();</span><br></pre></td></tr></table></figure><p>根据投影方式创建不同的投影矩阵。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (projectionType == <span class="number">1</span>)</span><br><span class="line">    lightProjection = glm::ortho(<span class="number">-10.0f</span>, <span class="number">10.0f</span>, <span class="number">-10.0f</span>, <span class="number">10.0f</span>, near_plane, far_plane);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (projectionType == <span class="number">2</span>)</span><br><span class="line">    lightProjection = glm::perspective(glm::radians(<span class="number">120.0f</span>), <span class="number">1.0f</span>, near_plane, far_plane);</span><br></pre></td></tr></table></figure><p>让光源动起来，使效果明显。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lightPos.z = <span class="built_in">sin</span>(time) * <span class="number">10.0f</span>;</span><br><span class="line">lightPos.y = <span class="built_in">sin</span>(time/ <span class="number">2.0f</span>) * <span class="number">2</span> + <span class="number">4.0f</span>;</span><br></pre></td></tr></table></figure><h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p>正交投影：</p><img src="/2019/05/13/Shadow-Mapping/2.png" title="pic2"><p>透视投影：</p><img src="/2019/05/13/Shadow-Mapping/3.png" title="pic3"><h2 id="优化阴影"><a href="#优化阴影" class="headerlink" title="优化阴影"></a>优化阴影</h2><h3 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h3><p>通过加入偏移量，避免了由于Shadow Map分辨率不足导致的阴影失真。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="number">0.005</span>;</span><br><span class="line"><span class="type">float</span> shadow = currentDepth - bias  &gt; closestDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><p>优化前：</p><img src="/2019/05/13/Shadow-Mapping/4.png" title="pic4"><p>优化后：</p><img src="/2019/05/13/Shadow-Mapping/5.png" title="pic5"><h3 id="悬浮"><a href="#悬浮" class="headerlink" title="悬浮"></a>悬浮</h3><p>在渲染Shadow Map的时候，通过正面剔除，减轻了悬浮的现象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glCullFace(GL_FRONT);</span><br><span class="line">renderScene(depthShader, planeVAO, cubeVAO);</span><br><span class="line">glCullFace(GL_BACK);</span><br></pre></td></tr></table></figure><h3 id="锯齿"><a href="#锯齿" class="headerlink" title="锯齿"></a>锯齿</h3><p>通过使用5*5的模板进行均值滤波，减轻了阴影的锯齿化现象。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> texelSize = <span class="number">1.0</span> / <span class="built_in">textureSize</span>(shadowMap, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-2</span>; x &lt;= <span class="number">2</span>; ++x) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-2</span>; y &lt;= <span class="number">2</span>; ++y) &#123;</span><br><span class="line">        <span class="type">float</span> pcfDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy + <span class="type">vec2</span>(x, y) * texelSize).r;</span><br><span class="line">        shadow += currentDepth - bias &gt; pcfDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">shadow /= <span class="number">25.0</span>;</span><br></pre></td></tr></table></figure><p>优化前：</p><img src="/2019/05/13/Shadow-Mapping/6.png" title="pic6"><p>优化后：</p><img src="/2019/05/13/Shadow-Mapping/7.png" title="pic7">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Shadow-Mapping阴影渲染&quot;&gt;&lt;a href=&quot;#Shadow-Mapping阴影渲染&quot; class=&quot;headerlink&quot; title=&quot;Shadow Mapping阴影渲染&quot;&gt;&lt;/a&gt;Shadow Mapping阴影渲染&lt;/h2&gt;&lt;p&gt;Shadow
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Lights and Shading</title>
    <link href="https://xungerrrr.github.io/2019/05/07/Lights-and-Shading/"/>
    <id>https://xungerrrr.github.io/2019/05/07/Lights-and-Shading/</id>
    <published>2019-05-07T12:47:38.000Z</published>
    <updated>2019-05-07T14:14:34.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现Phong光照模型"><a href="#实现Phong光照模型" class="headerlink" title="实现Phong光照模型"></a>实现Phong光照模型</h2><h3 id="Phong-Shading"><a href="#Phong-Shading" class="headerlink" title="Phong Shading"></a>Phong Shading</h3><p>Phong Shading在每个像素根据法向量计算光照，而每个像素的法向量由顶点的法向量插值求得。因此，要实现Phong Shading，顶点着色器需要输出顶点的位置和法向量。输出的位置由世界坐标表示，所以要用model矩阵进行变换后输出。为避免缩放后法向量不垂直于平面，要用法线矩阵对法向量进行变换后输出。顶点着色器的代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> Normal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragPos = <span class="type">vec3</span>(model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>));</span><br><span class="line">    Normal = <span class="type">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(model))) * aNormal;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Phong Shading在片段着色器根据法向量计算光照，要在片段着色器中计算环境光、漫反射和镜面反射三种光照效果。环境光强度仅由全局变量ambientStrength决定。漫反射光的强度由全局变量diffuseStrength以及光线与法向量的夹角决定。夹角的cos值，可以通过法向量的单位向量与入射点到光源方向的单位向量的点乘求得，且cos值不小于0。镜面反射光强度由全局变量specularStrength以及入射点到摄像机方向与全反射光方向的夹角决定，夹角的cos值也是通过单位向量的点乘求得。三种光照强度相加后，与物体颜色和光照颜色相乘，得到显示的颜色。实现的代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> objectColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> ambientStrength;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> diffuseStrength;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> specularStrength;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    <span class="type">vec3</span> ambient = ambientStrength * lightColor;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// diffuse </span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">vec3</span> diffuse = diffuseStrength * diff * lightColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);</span><br><span class="line">    <span class="type">vec3</span> specular = specularStrength * spec * lightColor;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> result = (ambient + diffuse + specular) * objectColor;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Gouraud-Shading"><a href="#Gouraud-Shading" class="headerlink" title="Gouraud Shading"></a>Gouraud Shading</h3><p>与Phong Shadings不同，Gouraud Shading在顶点处计算光照，其他像素的颜色由顶点颜色插值得到，所以光照的计算放在顶点着色器中。具体的计算方法与Phong Shading类似。顶点着色器最终输出光照的颜色。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> LightingColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> ambientStrength;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> diffuseStrength;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> specularStrength;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> Position = <span class="type">vec3</span>(model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>));</span><br><span class="line">    <span class="type">vec3</span> Normal = <span class="type">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(model))) * aNormal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    <span class="type">vec3</span> ambient = ambientStrength * lightColor;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// diffuse </span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - Position);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">vec3</span> diffuse = diffuseStrength * diff * lightColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - Position);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);</span><br><span class="line">    <span class="type">vec3</span> specular = specularStrength * spec * lightColor;</span><br><span class="line"></span><br><span class="line">    LightingColor = ambient + diffuse + specular;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>光线颜色输入到片段着色器中，与物体颜色相乘，得到显示的颜色：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> LightingColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> objectColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(LightingColor * objectColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用GUI，使参数可调节，效果实时更改"><a href="#使用GUI，使参数可调节，效果实时更改" class="headerlink" title="使用GUI，使参数可调节，效果实时更改"></a>使用GUI，使参数可调节，效果实时更改</h2><h3 id="Shading切换"><a href="#Shading切换" class="headerlink" title="Shading切换"></a>Shading切换</h3><p>创建两个shader对象，使用GUI进行切换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Shader <span class="title">phongLightingShader</span><span class="params">(<span class="string">"phong.vs"</span>, <span class="string">"phong.fs"</span>)</span></span>;</span><br><span class="line"><span class="function">Shader <span class="title">gouraudLightingShader</span><span class="params">(<span class="string">"gouraud.vs"</span>, <span class="string">"gouraud.fs"</span>)</span></span>;</span><br><span class="line">Shader *lightingShader = &amp;phongLightingShader;</span><br></pre></td></tr></table></figure><p>在渲染循环中切换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ImGui::Begin(<span class="string">"Shading Type"</span>);</span><br><span class="line">ImGui::BeginGroup();</span><br><span class="line">ImGui::RadioButton(<span class="string">"Phong"</span>, &amp;shadingType, <span class="number">1</span>);</span><br><span class="line">ImGui::RadioButton(<span class="string">"Gouraud"</span>, &amp;shadingType, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (shadingType == <span class="number">1</span>) &#123;</span><br><span class="line">    lightingShader = &amp;phongLightingShader;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (shadingType == <span class="number">2</span>) &#123;</span><br><span class="line">    lightingShader = &amp;gouraudLightingShader;</span><br><span class="line">&#125;</span><br><span class="line">ImGui::EndGroup();</span><br><span class="line">ImGui::End();</span><br></pre></td></tr></table></figure><h3 id="参数可调节"><a href="#参数可调节" class="headerlink" title="参数可调节"></a>参数可调节</h3><p>用SliderFloat调节三个参数，然后设置全局变量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ImGui::Begin(<span class="string">"Light Strength"</span>);</span><br><span class="line">ImGui::SliderFloat(<span class="string">"Ambient Strength"</span>, &amp;ambientStrength, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">ImGui::SliderFloat(<span class="string">"Diffuse Strength"</span>, &amp;diffuseStrength, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">ImGui::SliderFloat(<span class="string">"Specular Strength"</span>, &amp;specularStrength, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">ImGui::End();</span><br><span class="line"></span><br><span class="line">lightingShader-&gt;setFloat(<span class="string">"ambientStrength"</span>, ambientStrength);</span><br><span class="line">lightingShader-&gt;setFloat(<span class="string">"diffuseStrength"</span>, diffuseStrength);</span><br><span class="line">lightingShader-&gt;setFloat(<span class="string">"specularStrength"</span>, specularStrength);</span><br></pre></td></tr></table></figure></p><h2 id="Bonus：移动光源"><a href="#Bonus：移动光源" class="headerlink" title="Bonus：移动光源"></a>Bonus：移动光源</h2><p>用三角函数可以实现光源在x方向的来回移动：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> time = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line"><span class="keyword">if</span> (ImGui::MenuItem(<span class="string">"move"</span>, <span class="literal">NULL</span>, &amp;move)) &#123;</span><br><span class="line">    moveTime = time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (move)</span><br><span class="line">    lightPos.x = <span class="built_in">sin</span>(time - moveTime + <span class="number">3.14</span> / <span class="number">6</span>) * <span class="number">2.0f</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    lightPos.x = <span class="number">1.0f</span>;</span><br><span class="line">lightingShader-&gt;setVec3(<span class="string">"lightPos"</span>, lightPos);</span><br></pre></td></tr></table></figure><h2 id="渲染效果"><a href="#渲染效果" class="headerlink" title="渲染效果"></a>渲染效果</h2><h3 id="Phong-Shading-1"><a href="#Phong-Shading-1" class="headerlink" title="Phong Shading"></a>Phong Shading</h3><img src="/2019/05/07/Lights-and-Shading/1.png" title="Phong"><h3 id="Gouraud-Shading-1"><a href="#Gouraud-Shading-1" class="headerlink" title="Gouraud Shading"></a>Gouraud Shading</h3><img src="/2019/05/07/Lights-and-Shading/2.png" title="Gouraud"><h3 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h3><img src="/2019/05/07/Lights-and-Shading/demo1.gif" title="Demo1"><h3 id="运动光源"><a href="#运动光源" class="headerlink" title="运动光源"></a>运动光源</h3><img src="/2019/05/07/Lights-and-Shading/demo2.gif" title="Demo1">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实现Phong光照模型&quot;&gt;&lt;a href=&quot;#实现Phong光照模型&quot; class=&quot;headerlink&quot; title=&quot;实现Phong光照模型&quot;&gt;&lt;/a&gt;实现Phong光照模型&lt;/h2&gt;&lt;h3 id=&quot;Phong-Shading&quot;&gt;&lt;a href=&quot;#Phon
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>领域建模 - 对象状态</title>
    <link href="https://xungerrrr.github.io/2019/05/04/%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1-%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81/"/>
    <id>https://xungerrrr.github.io/2019/05/04/领域建模-对象状态/</id>
    <published>2019-05-04T14:47:37.000Z</published>
    <updated>2019-06-02T16:44:05.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用UMLet建模"><a href="#使用UMLet建模" class="headerlink" title="使用UMLet建模"></a>使用UMLet建模</h1><h2 id="使用类图，分别对Asg-RH文档中Make-Reservation用例以及Payment用例开展领域建模。然后，根据上述模型，给出建议的数据表以及主要字段，特别是主键和外键"><a href="#使用类图，分别对Asg-RH文档中Make-Reservation用例以及Payment用例开展领域建模。然后，根据上述模型，给出建议的数据表以及主要字段，特别是主键和外键" class="headerlink" title="使用类图，分别对Asg_RH文档中Make Reservation用例以及Payment用例开展领域建模。然后，根据上述模型，给出建议的数据表以及主要字段，特别是主键和外键"></a>使用类图，分别对Asg_RH文档中Make Reservation用例以及Payment用例开展领域建模。然后，根据上述模型，给出建议的数据表以及主要字段，特别是主键和外键</h2><blockquote><p>注意事项：</p><ul><li>对象必须是名词、特别是技术名词、报表、描述类的处理；</li><li>关联必须有多重性、部分有名称与导航方向；</li><li>属性要注意计算字段；</li><li>数据建模，为了简化描述仅需要给出表清单，例如：<ul><li>Hotel（ID/Key，Name，LoctionID/Fkey，Address…）</li></ul></li></ul></blockquote><h3 id="Make-Reservation"><a href="#Make-Reservation" class="headerlink" title="Make Reservation"></a>Make Reservation</h3><img src="/2019/05/04/领域建模-对象状态/reservation.png" title="reservation"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traveler(TravelerID/Key, Name, EmailAdress)</span><br><span class="line">Hotel(HotelID/Key, Name, Address)</span><br><span class="line">Room(RoomID/Key, HotelID/Fkey, Type, Availability)</span><br><span class="line">ReservationItem(ReservationID/Key, RoomID/Fkey, BasketID/Fkey, CheckInDate, CheckOutDate, NumberOfAdults, NumberOfChildren, Price, IsSmoking, SpecialRequirements)</span><br><span class="line">ReservationBasket(BasketID/Key, TravelerID/FKey)</span><br><span class="line">RoomDescription(DescriptionID/FKey, Total, Price, Description)</span><br></pre></td></tr></table></figure><h3 id="Payment"><a href="#Payment" class="headerlink" title="Payment"></a>Payment</h3><img src="/2019/05/04/领域建模-对象状态/payment.png" title="payment"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Payment(PaymentID/Key, ReservationID/Fkey, CardID/Fkey, price)</span><br><span class="line">ReservationItem(ReservationID/Key, PaymentID/Fkey, RoomID/Fkey, BasketID/Fkey, CheckInDate, CheckOutDate, NumberOfAdults, NumberOfChildren, Price, IsSmoking, SpecialRequirements)</span><br><span class="line">CreditCard(CardID/Key, CardHolderID/Fkey, Type, CardNumber, CardSecurityCode, ExpiryDate)</span><br><span class="line">CardHolder(CardHolderID/key, Title, FirstName, LastName, Address1, Address2, City, CountyOrState, Country, Postcode, DaytimeTelephone, EveningTelephone)</span><br></pre></td></tr></table></figure><h2 id="使用UML-State-Model，对每个订单对象生命周期建模"><a href="#使用UML-State-Model，对每个订单对象生命周期建模" class="headerlink" title="使用UML State Model，对每个订单对象生命周期建模"></a>使用UML State Model，对每个订单对象生命周期建模</h2><blockquote><p>建模对象： 参考Asg_RH文档， 对Reservation/Order对象建模。<br>建模要求： 参考练习不能提供足够信息帮助你对订单对象建模，请参考现在定旅馆的旅游网站，尽可能分析围绕订单发生的各种情况，直到订单通过销售事件（柜台销售）结束订单。</p></blockquote><img src="/2019/05/04/领域建模-对象状态/activity.png" title="activity">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用UMLet建模&quot;&gt;&lt;a href=&quot;#使用UMLet建模&quot; class=&quot;headerlink&quot; title=&quot;使用UMLet建模&quot;&gt;&lt;/a&gt;使用UMLet建模&lt;/h1&gt;&lt;h2 id=&quot;使用类图，分别对Asg-RH文档中Make-Reservation用例以及
      
    
    </summary>
    
    
      <category term="SE" scheme="https://xungerrrr.github.io/tags/SE/"/>
    
  </entry>
  
  <entry>
    <title>用例建模 - 业务建模方法</title>
    <link href="https://xungerrrr.github.io/2019/05/04/%E7%94%A8%E4%BE%8B%E5%BB%BA%E6%A8%A1-%E4%B8%9A%E5%8A%A1%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95/"/>
    <id>https://xungerrrr.github.io/2019/05/04/用例建模-业务建模方法/</id>
    <published>2019-05-04T02:08:40.000Z</published>
    <updated>2019-06-02T16:44:04.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-UMLet-建模"><a href="#使用-UMLet-建模" class="headerlink" title="使用 UMLet 建模"></a>使用 UMLet 建模</h1><h2 id="根据订旅馆建模文档，Asg-RH-pdf："><a href="#根据订旅馆建模文档，Asg-RH-pdf：" class="headerlink" title="根据订旅馆建模文档，Asg-RH.pdf："></a>根据订旅馆建模文档，<a href="https://sysu-swsad.github.io/swad-guide/material/Asg_RH.pdf" target="_blank" rel="noopener">Asg-RH.pdf</a>：</h2><h3 id="绘制用例图模型（到子用例）"><a href="#绘制用例图模型（到子用例）" class="headerlink" title="绘制用例图模型（到子用例）"></a>绘制用例图模型（到子用例）</h3><img src="/2019/05/04/用例建模-业务建模方法/usecase.png" title="usecase"><h3 id="给出make-reservation用例的活动图"><a href="#给出make-reservation用例的活动图" class="headerlink" title="给出make reservation用例的活动图"></a>给出make reservation用例的活动图</h3><img src="/2019/05/04/用例建模-业务建模方法/activity.png" title="activity"><h2 id="根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景"><a href="#根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景" class="headerlink" title="根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景"></a>根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景</h2><h3 id="分别用多泳道图建模三个场景的业务过程"><a href="#分别用多泳道图建模三个场景的业务过程" class="headerlink" title="分别用多泳道图建模三个场景的业务过程"></a>分别用多泳道图建模三个场景的业务过程</h3><h4 id="x科技公司发明了投递柜，它们自建了投递柜以及远程控制系统。注册的投递员在推广期免费使用投递柜。由于缺乏资源，仅能使用y移动平台向客户发送短信通知。"><a href="#x科技公司发明了投递柜，它们自建了投递柜以及远程控制系统。注册的投递员在推广期免费使用投递柜。由于缺乏资源，仅能使用y移动平台向客户发送短信通知。" class="headerlink" title="x科技公司发明了投递柜，它们自建了投递柜以及远程控制系统。注册的投递员在推广期免费使用投递柜。由于缺乏资源，仅能使用y移动平台向客户发送短信通知。"></a>x科技公司发明了投递柜，它们自建了投递柜以及远程控制系统。注册的投递员在推广期免费使用投递柜。由于缺乏资源，仅能使用y移动平台向客户发送短信通知。</h4><img src="/2019/05/04/用例建模-业务建模方法/case1.png" title="case1"><h4 id="随着产品推广，x公司与各大快递z公司达成协议。x公司在快递柜上添加了二维码扫描装置，z公司的快递员不仅可在快递柜上登陆（由z公司提供认证服务），且可扫描快递单号，投递入柜后自动由z公司发短信给客户。客户取件后，自动发送给z公司投递完成。"><a href="#随着产品推广，x公司与各大快递z公司达成协议。x公司在快递柜上添加了二维码扫描装置，z公司的快递员不仅可在快递柜上登陆（由z公司提供认证服务），且可扫描快递单号，投递入柜后自动由z公司发短信给客户。客户取件后，自动发送给z公司投递完成。" class="headerlink" title="随着产品推广，x公司与各大快递z公司达成协议。x公司在快递柜上添加了二维码扫描装置，z公司的快递员不仅可在快递柜上登陆（由z公司提供认证服务），且可扫描快递单号，投递入柜后自动由z公司发短信给客户。客户取件后，自动发送给z公司投递完成。"></a>随着产品推广，x公司与各大快递z公司达成协议。x公司在快递柜上添加了二维码扫描装置，z公司的快递员不仅可在快递柜上登陆（由z公司提供认证服务），且可扫描快递单号，投递入柜后自动由z公司发短信给客户。客户取件后，自动发送给z公司投递完成。</h4><img src="/2019/05/04/用例建模-业务建模方法/case2.png" title="case2"><h4 id="x公司进一步优化服务，开发了微信小程序实现扫码取快递。如果用户关注了该公司公众号，直接通过过公众号推送给用户取件码等信息。不再发送短信。"><a href="#x公司进一步优化服务，开发了微信小程序实现扫码取快递。如果用户关注了该公司公众号，直接通过过公众号推送给用户取件码等信息。不再发送短信。" class="headerlink" title="x公司进一步优化服务，开发了微信小程序实现扫码取快递。如果用户关注了该公司公众号，直接通过过公众号推送给用户取件码等信息。不再发送短信。"></a>x公司进一步优化服务，开发了微信小程序实现扫码取快递。如果用户关注了该公司公众号，直接通过过公众号推送给用户取件码等信息。不再发送短信。</h4><img src="/2019/05/04/用例建模-业务建模方法/case3.png" title="case3"><h3 id="根据上述流程，给出快递柜系统最终的用例图模型"><a href="#根据上述流程，给出快递柜系统最终的用例图模型" class="headerlink" title="根据上述流程，给出快递柜系统最终的用例图模型"></a>根据上述流程，给出快递柜系统最终的用例图模型</h3><p>用正常色彩表示第一个业务流程反映的用例，用绿色背景表述第二个业务场景添加或修改的用例，以及支持Actor，用黄色背景表述第三个业务场景添加或修改的用例，以及支持Actor。</p><img src="/2019/05/04/用例建模-业务建模方法/usecase2.png" title="usecase2">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用-UMLet-建模&quot;&gt;&lt;a href=&quot;#使用-UMLet-建模&quot; class=&quot;headerlink&quot; title=&quot;使用 UMLet 建模&quot;&gt;&lt;/a&gt;使用 UMLet 建模&lt;/h1&gt;&lt;h2 id=&quot;根据订旅馆建模文档，Asg-RH-pdf：&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="SE" scheme="https://xungerrrr.github.io/tags/SE/"/>
    
  </entry>
  
  <entry>
    <title>Camera</title>
    <link href="https://xungerrrr.github.io/2019/04/17/Camera/"/>
    <id>https://xungerrrr.github.io/2019/04/17/Camera/</id>
    <published>2019-04-17T06:24:07.000Z</published>
    <updated>2019-04-17T14:30:48.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="投影（Projection"><a href="#投影（Projection" class="headerlink" title="投影（Projection)"></a>投影（Projection)</h1><h2 id="把上次作业绘制的cube放置在-1-5-0-5-1-5-位置，要求6个面颜色不一致"><a href="#把上次作业绘制的cube放置在-1-5-0-5-1-5-位置，要求6个面颜色不一致" class="headerlink" title="把上次作业绘制的cube放置在(-1.5, 0.5, -1.5)位置，要求6个面颜色不一致"></a>把上次作业绘制的cube放置在(-1.5, 0.5, -1.5)位置，要求6个面颜色不一致</h2><p>因为放置在(-1.5, 0.5, -1.5)时透视投影效果不明显，我将立方体放置在了(-3.5, 2.5, -1.5)位置。用glm::translate即可实现平移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = glm::translate(model, glm::vec3(<span class="number">-3.5</span>, <span class="number">2.5f</span>, <span class="number">-1.5f</span>));</span><br></pre></td></tr></table></figure><h2 id="正交投影（orthographic-projection-：实现正交投影，使用多组（left-right-bottom-top-near-far）参数，比较结果差异"><a href="#正交投影（orthographic-projection-：实现正交投影，使用多组（left-right-bottom-top-near-far）参数，比较结果差异" class="headerlink" title="正交投影（orthographic projection)：实现正交投影，使用多组（left, right, bottom, top, near, far）参数，比较结果差异"></a>正交投影（orthographic projection)：实现正交投影，使用多组（left, right, bottom, top, near, far）参数，比较结果差异</h2><p>先设计一个GUI交互界面，可以选择投影类型，并输入不同的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> left = <span class="number">-12.0f</span>, right = <span class="number">12.0f</span>, bottom = <span class="number">-9.0f</span>, top = <span class="number">9.0f</span>, nearDist = <span class="number">0.1f</span>, farDist = <span class="number">100.0f</span>;</span><br><span class="line">ImGui::Begin(<span class="string">"Projection Type"</span>);</span><br><span class="line">ImGui::BeginGroup();</span><br><span class="line">ImGui::RadioButton(<span class="string">"Orthographic"</span>, &amp;projectionType, <span class="number">1</span>);</span><br><span class="line">ImGui::PushItemWidth(<span class="number">60</span>);</span><br><span class="line"><span class="keyword">if</span> (projectionType == <span class="number">1</span>) &#123;</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Left"</span>, &amp;left);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Right"</span>, &amp;right);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Bottom"</span>, &amp;bottom);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Top"</span>, &amp;top);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Near"</span>, &amp;nearDist);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Far"</span>, &amp;farDist);</span><br><span class="line">    projection = glm::ortho(left, right, bottom, top, nearDist, farDist);</span><br><span class="line">&#125;</span><br><span class="line">ImGui::RadioButton(<span class="string">"Perspective"</span>, &amp;projectionType, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (projectionType == <span class="number">2</span>) &#123;</span><br><span class="line">    ImGui::InputFloat(<span class="string">"FOV"</span>, &amp;fov);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Aspect Ratio"</span>, &amp;ratio);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Near"</span>, &amp;nearDist);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Far"</span>, &amp;farDist);</span><br><span class="line">    projection = glm::perspective(fov, ratio, nearDist, farDist);</span><br><span class="line">&#125;</span><br><span class="line">ImGui::EndGroup();</span><br><span class="line">ImGui::End();</span><br></pre></td></tr></table></figure><p>效果：<br><img src="/2019/04/17/Camera/GUI.png" title="GUI"></p><p>多组参数的结果：</p><p>改变left、right、bottom和top，这决定了视口的左右范围和上下范围。数值范围越大，显示的范围也越大，物体也就越小。</p><img src="/2019/04/17/Camera/1.png" title="1.1"><img src="/2019/04/17/Camera/2.png" title="1.2"><p>如果长宽比与窗口相同，则显示的内容与真实的比例相同，否则会发生比例的变化。</p><img src="/2019/04/17/Camera/4.png" title="1.4"><p>near和far参数是显示的最近距离和最远距离。摄像机的z坐标是15，立方体中心的z坐标是-1.5，立方体的边长为4，立方体的正面离摄像机的距离是14.5。所以当把near设为15时，立方体的正面便不会显示出来，而显示立方体的背面。</p><img src="/2019/04/17/Camera/3.png" title="1.3"><h2 id="透视投影（perspective-projection）：实现透视投影，使用多组参数，比较结果差异"><a href="#透视投影（perspective-projection）：实现透视投影，使用多组参数，比较结果差异" class="headerlink" title="透视投影（perspective projection）：实现透视投影，使用多组参数，比较结果差异"></a>透视投影（perspective projection）：实现透视投影，使用多组参数，比较结果差异</h2><p>多组参数的结果：</p><p>fov代表了视角大小，视角越小，看到的范围越小，物体就越大。</p><img src="/2019/04/17/Camera/5.png" title="2.1"><img src="/2019/04/17/Camera/6.png" title="2.2"><p>aspect ratio代表了宽高比，如果与窗口相同，则显示的内容与真实的比例相同，否则会发生比例的变化。</p><img src="/2019/04/17/Camera/7.png" title="2.3"><p>near和far决定了显示的前后范围。当把far设为17时，立方体的后半部分不显示。</p><img src="/2019/04/17/Camera/8.png" title="2.4"><p>当把near设为15时，立方体的前半部分不显示。</p><img src="/2019/04/17/Camera/9.png" title="2.5"><h1 id="视角变换（View-Changing）"><a href="#视角变换（View-Changing）" class="headerlink" title="视角变换（View Changing）"></a>视角变换（View Changing）</h1><h2 id="把cube放置在-0-0-0-处，做透视投影，使摄像机围绕cube旋转，并且时刻看着cube中心"><a href="#把cube放置在-0-0-0-处，做透视投影，使摄像机围绕cube旋转，并且时刻看着cube中心" class="headerlink" title="把cube放置在(0, 0, 0)处，做透视投影，使摄像机围绕cube旋转，并且时刻看着cube中心"></a>把cube放置在(0, 0, 0)处，做透视投影，使摄像机围绕cube旋转，并且时刻看着cube中心</h2><p>使摄像机位置始终在半径为15的圆周上，可以用三角函数实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ImGui::RadioButton(<span class="string">"View Changing"</span>, &amp;function, <span class="number">2</span>)) &#123;</span><br><span class="line">    rotateTime = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">float</span> time = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line"><span class="keyword">float</span> radius = <span class="number">15.0f</span>;</span><br><span class="line"><span class="keyword">float</span> camX = <span class="built_in">sin</span>(time - rotateTime) * radius;</span><br><span class="line"><span class="keyword">float</span> camZ = <span class="built_in">cos</span>(time - rotateTime) * radius;</span><br></pre></td></tr></table></figure><p>使用摄像机位置，创建LookAt矩阵，令摄像机始终看着(0, 0, 0)。投影矩阵使用透视投影。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view = glm::lookAt(glm::vec3(camX, <span class="number">0.0</span>, camZ), glm::vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>));</span><br><span class="line">projection = glm::perspective(glm::radians(<span class="number">45.0f</span>), (<span class="keyword">float</span>)windowWidth / windowHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/04/17/Camera/rotate.gif" title="旋转"><h1 id="在现实生活中，我们一般将摄像机摆放的空间View-matrix和被拍摄的物体摆设的空间Model-matrix分开，但是在OpenGL中却将两个合二为一设为ModelView-matrix，通过上面的作业启发，你认为是为什么呢？"><a href="#在现实生活中，我们一般将摄像机摆放的空间View-matrix和被拍摄的物体摆设的空间Model-matrix分开，但是在OpenGL中却将两个合二为一设为ModelView-matrix，通过上面的作业启发，你认为是为什么呢？" class="headerlink" title="在现实生活中，我们一般将摄像机摆放的空间View matrix和被拍摄的物体摆设的空间Model matrix分开，但是在OpenGL中却将两个合二为一设为ModelView matrix，通过上面的作业启发，你认为是为什么呢？"></a>在现实生活中，我们一般将摄像机摆放的空间View matrix和被拍摄的物体摆设的空间Model matrix分开，但是在OpenGL中却将两个合二为一设为ModelView matrix，通过上面的作业启发，你认为是为什么呢？</h1><p>因为OpenGL本身并没有摄像机这个概念，我们的摄像机，只是通过将场景中的物体往相反的方向移动模拟出来的。由于实际上只有一个坐标系统，坐标变换本质上都是在物体上进行，所以将View和Model矩阵合并成ModelView矩阵。而在多个摄像机的情况下，只需定义不同的ModelView矩阵，就可以实现摄像机的切换，不需要在多个坐标系统之间进行切换，实现起来比较方便。</p><h1 id="Bonus：实现一个camera类，能够使用键盘和鼠标控制视角，实现类似FPS的游戏场景"><a href="#Bonus：实现一个camera类，能够使用键盘和鼠标控制视角，实现类似FPS的游戏场景" class="headerlink" title="Bonus：实现一个camera类，能够使用键盘和鼠标控制视角，实现类似FPS的游戏场景"></a>Bonus：实现一个camera类，能够使用键盘和鼠标控制视角，实现类似FPS的游戏场景</h1><p>类的头文件定义如下，具体实现请看源代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default camera values</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> YAW = <span class="number">-90.0f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> PITCH = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> FOV = <span class="number">45.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor with vectors</span></span><br><span class="line">    Camera(glm::vec3 _position = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">15.0f</span>), </span><br><span class="line">        glm::vec3 _front = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>), </span><br><span class="line">        glm::vec3 _up = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>), </span><br><span class="line">        <span class="keyword">float</span> _yaw = YAW, <span class="keyword">float</span> _pitch = PITCH);</span><br><span class="line">    <span class="comment">// Returns the view matrix</span></span><br><span class="line">    glm::<span class="function">mat4 <span class="title">getViewMatrix</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Move the camera</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveForward</span><span class="params">(<span class="keyword">float</span> distance)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveBack</span><span class="params">(<span class="keyword">float</span> distance)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveRight</span><span class="params">(<span class="keyword">float</span> distance)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveLeft</span><span class="params">(<span class="keyword">float</span> distance)</span></span>;</span><br><span class="line">    <span class="comment">// Rotate the camera using pitch and yaw</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">float</span> _pitch, <span class="keyword">float</span> _yaw)</span></span>;</span><br><span class="line">    <span class="comment">// Change the fov to zoom</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">zoom</span><span class="params">(<span class="keyword">float</span> yoffset)</span></span>;</span><br><span class="line">    <span class="comment">// Get the fov</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getFov</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Reset the camera</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Calculates the front vector from the Camera's (updated) Euler Angles</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateCameraVectors</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Camera Attributes</span></span><br><span class="line">    glm::vec3 position;</span><br><span class="line">    glm::vec3 front;</span><br><span class="line">    glm::vec3 up;</span><br><span class="line">    glm::vec3 right;</span><br><span class="line">    glm::vec3 world_up;</span><br><span class="line">    <span class="comment">// Euler Angles</span></span><br><span class="line">    <span class="keyword">float</span> yaw;</span><br><span class="line">    <span class="keyword">float</span> pitch;</span><br><span class="line">    <span class="comment">// Camera options</span></span><br><span class="line">    <span class="keyword">float</span> fov;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>检测键盘输入，调用Camera类的四个移动方法，实现摄像机的移动：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> cameraSpeed = <span class="number">20.0f</span> * deltaTime;</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)</span><br><span class="line">    camera.moveForward(cameraSpeed);</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)</span><br><span class="line">    camera.moveBack(cameraSpeed);</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)</span><br><span class="line">    camera.moveLeft(cameraSpeed);</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)</span><br><span class="line">    camera.moveRight(cameraSpeed);</span><br></pre></td></tr></table></figure><p>在鼠标回调函数中，调用Camera类的rotate方法，实现视角的转动:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (firstMouse) &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">        firstMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> xoffset = xpos - lastX;</span><br><span class="line">    <span class="keyword">float</span> yoffset = lastY - ypos;</span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> sensitivity = <span class="number">0.05</span>;</span><br><span class="line">    xoffset *= sensitivity;</span><br><span class="line">    yoffset *= sensitivity;</span><br><span class="line">    camera.rotate(yoffset, xoffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在滚动的回调函数中，调用Camera类的zoom方法，实现放大和缩小:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffset)</span> </span>&#123;</span><br><span class="line">    camera.zoom(yoffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染的时候，通过Camera类获取View Matrix和FOV：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view = camera.getViewMatrix();</span><br><span class="line">projection = glm::perspective(camera.getFov(), (<span class="keyword">float</span>)windowWidth / windowHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>实现效果：</p><img src="/2019/04/17/Camera/bonus.gif" title="bonus">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;投影（Projection&quot;&gt;&lt;a href=&quot;#投影（Projection&quot; class=&quot;headerlink&quot; title=&quot;投影（Projection)&quot;&gt;&lt;/a&gt;投影（Projection)&lt;/h1&gt;&lt;h2 id=&quot;把上次作业绘制的cube放置在-1-5
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>用例建模 - 绘制用例图</title>
    <link href="https://xungerrrr.github.io/2019/04/12/%E7%94%A8%E4%BE%8B%E5%BB%BA%E6%A8%A1-%E7%BB%98%E5%88%B6%E7%94%A8%E4%BE%8B%E5%9B%BE/"/>
    <id>https://xungerrrr.github.io/2019/04/12/用例建模-绘制用例图/</id>
    <published>2019-04-12T06:08:30.000Z</published>
    <updated>2019-06-02T16:52:38.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ul><li><p>用例的概念</p><ul><li>用例是描述参与者使用系统去达到某种目的一系列相关的成功和失败情景。</li><li>用例是文本文档而不是图，即用例建模的过程主要是文本编写，而不是制图。</li><li>用例与面向对象无关。</li><li>用例是经典面向对象分析与设计的一个关键需求输入。</li><li>用例是表现系统功能的功能性或行为性需求。</li></ul></li><li><p>用例和场景的关系？什么是主场景或happy path？</p><ul><li>一个用例代表了多个场景，包括主场景和其他可选场景。</li><li>主场景对应主要的系统交互，通常是成功场景。</li><li>可选场景对应较少的交互和异常情况。</li></ul></li><li><p>用例有哪些形式？</p><ul><li>Brief：一段精炼的总结，通常是主场景。</li><li>Casual：非正式的段落格式，多个段落对应多个场景。</li><li>Fully：详细说明所有的步骤和变化。</li></ul></li><li><p>对于复杂业务，为什么编制完整用例非常难？</p><p>复杂业务的业务流程很复杂，涉及很多的场景，场景之间的关联也非常多，很难将所有的用例和场景按照一定顺序列举出来。同时，如果用例编写者对各个业务流程的理解存在偏差，用例的准确性和完整性就难以保证。</p></li><li><p>什么是用例图？</p><p>用例图是指由参与者（Actor）、用例（Use Case），边界以及它们之间的关系构成的用于描述系统功能的视图，也是外部用户所能观察到的系统功能的模型图。</p></li><li><p>用例图的基本符号与元素？</p><ul><li>小人（参与者）<img src="/2019/04/12/用例建模-绘制用例图/actor.png" title="actor"></li><li>椭圆（用例）<img src="/2019/04/12/用例建模-绘制用例图/usecase.png" title="usecase"></li><li>矩形（系统边界）<img src="/2019/04/12/用例建模-绘制用例图/system.png" title="system"></li><li>关系<ul><li>直线（关联关系）<img src="/2019/04/12/用例建模-绘制用例图/association.png" title="association"></li><li>&lt;<includes>&gt;箭头（包含关系）<img src="/2019/04/12/用例建模-绘制用例图/includes.png" title="includes"></includes></li><li>&lt;<extends>&gt;箭头（扩展关系）<img src="/2019/04/12/用例建模-绘制用例图/extends.png" title="extends"></extends></li><li>空心箭头（泛化关系）<img src="/2019/04/12/用例建模-绘制用例图/generalization.png" title="generalisation"></li></ul></li></ul></li><li><p>用例图的画法与步骤</p><ol><li>绘制系统边界。</li><li>绘制参与者，将参与者画在所有系统边界以外。</li><li>绘制用例，考虑每一个参与者是如何使用系统的，将相应的用例画在对应的系统中，用线将用例和参与者关联起来。</li><li>绘制用例间的关系：如包含关系、扩展关系和泛化关系。</li><li>绘制关联的外部支持系统，用线将支持系统和对应的用例关联起来。</li></ol></li><li><p>用例图给利益相关人与开发者的价值有哪些？</p><ul><li>利益相关人<br>用例图清晰地展示了系统的功能组成，客户可以清楚地看到系统设计与自己的要求是否相符。同时，客户可以简单修改用例图来表达需求变更的想法。</li><li>开发者<br>用例图明确地表达了用户的需求，因此系统架构的设计可以更加准确，同时系统的工作量评估也变得方便。</li></ul></li></ul><h2 id="建模练习题（用例模型）"><a href="#建模练习题（用例模型）" class="headerlink" title="建模练习题（用例模型）"></a>建模练习题（用例模型）</h2><ul><li><p>选择2-3个你熟悉的类似业务的在线服务系统（或移动APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求：</p><ul><li>请使用用户的视角，描述用户目标或系统提供的服务<br>订电影票</li><li>粒度达到子用例级别，并用include和exclude关联它们</li><li>请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例</li><li>尽可能识别外部系统和服务</li></ul><p>淘票票电影订票系统</p><img src="/2019/04/12/用例建模-绘制用例图/Tao.png" title="Tao"><p>猫眼电影订票系统</p><img src="/2019/04/12/用例建模-绘制用例图/Cat.png" title="Cat"></li><li><p>为什么相似系统的用例图是相似的？<br>相似的系统具有相似的需求，因此系统的功能和结构也非常相似，导致了用例图的相似性。</p></li><li>如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用。<br>根据创新点在用例图中的位置来判断。</li><li>请使用SCRUM方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表。</li></ul><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">Name</th><th style="text-align:center">Imp</th><th style="text-align:center">Est</th><th style="text-align:center">How to demo</th><th style="text-align:center">Note</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">登录注册</td><td style="text-align:center">15</td><td style="text-align:center">10</td><td style="text-align:center">可以选择登录或注册；输入已注册的账户和密码进行登录；使用手机验证码进行注册</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">搜索旅馆</td><td style="text-align:center">20</td><td style="text-align:center">15</td><td style="text-align:center">输入地点和时间进行搜索，生成酒店列表，然后可以选择按照价格、类型、评分等排序</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">预定旅馆</td><td style="text-align:center">10</td><td style="text-align:center">4</td><td style="text-align:center">用户点击酒店，选择房型，然后跳转到支付页面。</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">管理订单</td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">在订单页面显示历史订单，用户可以修改订单的时间、房型，或者取消订单</td></tr></tbody></table><ul><li>根据任务4，参考使用用例点估算软件成本，给出项目用例点的估算</li></ul><table><thead><tr><th style="text-align:center">用例</th><th style="text-align:center">#事务</th><th style="text-align:center">#计算</th><th style="text-align:center">原因</th><th style="text-align:center">权重</th></tr></thead><tbody><tr><td style="text-align:center">登录注册</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center"></td><td style="text-align:center">简单</td></tr><tr><td style="text-align:center">搜索旅馆</td><td style="text-align:center">10</td><td style="text-align:center">7</td><td style="text-align:center"></td><td style="text-align:center">复杂</td></tr><tr><td style="text-align:center">预定旅馆</td><td style="text-align:center">8</td><td style="text-align:center">5</td><td style="text-align:center"></td><td style="text-align:center">复杂</td></tr><tr><td style="text-align:center">管理订单</td><td style="text-align:center">4</td><td style="text-align:center">3</td><td style="text-align:center"></td><td style="text-align:center">平均</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简答题&quot;&gt;&lt;a href=&quot;#简答题&quot; class=&quot;headerlink&quot; title=&quot;简答题&quot;&gt;&lt;/a&gt;简答题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用例的概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用例是描述参与者使用系统去达到某种目的一系列相关的成功和失败情景。&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="SE" scheme="https://xungerrrr.github.io/tags/SE/"/>
    
  </entry>
  
  <entry>
    <title>Transformation</title>
    <link href="https://xungerrrr.github.io/2019/04/09/Transformation/"/>
    <id>https://xungerrrr.github.io/2019/04/09/Transformation/</id>
    <published>2019-04-09T10:55:37.000Z</published>
    <updated>2019-04-09T14:22:01.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="画一个立方体，边长为4，中心位置为-0-0-0"><a href="#画一个立方体，边长为4，中心位置为-0-0-0" class="headerlink" title="画一个立方体，边长为4，中心位置为(0, 0, 0)"></a>画一个立方体，边长为4，中心位置为(0, 0, 0)</h2><p>首先设定立方体的初始顶点位置和颜色。立方体的边长为4，中心位置为(0, 0, 0)，所以三个坐标轴的范围都是[-2, 2]。由于正方体有六个面，每个面由两个三角形构成，因此一共有36个点。同时，我希望用立方体表现出RGB颜色空间，x轴对应红色，y轴对应绿色，z轴对应蓝色，所以要根据点的坐标设置对应的颜色。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了能够显示出3D图形，需要进行坐标变换。需要相应的变换矩阵，实现从局部坐标到世界坐标、从世界坐标到观察坐标、从观察坐标到裁剪坐标的变换。在顶点着色器中添加这些矩阵作为全局变量，再进行矩阵相乘运算后输出，可以实现这个效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 aColor;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line">out vec3 ourColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * vec4(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要完整显示出立方体，要将摄像机向后移动，这个可以通过glm::translate移动场景来创建平移矩阵。要呈现立方体的真实感，需要进行透视投影，可以通过glm::perspective来创建投影矩阵。下面的代码添加在渲染循环过程内。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 model = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">glm::mat4 view = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">glm::mat4 projection = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">view = glm::translate(view, glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-15.0f</span>));</span><br><span class="line">projection = glm::perspective(glm::radians(<span class="number">45.0f</span>), (<span class="keyword">float</span>)windowWidth / windowHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line">shader.setMat4(<span class="string">"model"</span>, model);</span><br><span class="line">shader.setMat4(<span class="string">"projection"</span>, projection);</span><br><span class="line">shader.setMat4(<span class="string">"view"</span>, view);</span><br></pre></td></tr></table></figure><p>glDisable(GL_DEPTH_TEST)，关闭深度测试，渲染效果如下。这个效果不像是真实的立方体，本该被覆盖的后面被显示了出来。这是因为OpenGL是逐个三角形绘制的，后来绘制的像素有可能会覆盖之前的像素。</p><img src="/2019/04/09/Transformation/1.png" title="关闭深度测试"><p>glEnable(GL_DEPTH_TEST) ，启动深度测试，渲染效果如下。这个效果好多了，前面完全覆盖了背面，是一个真实的立方体（虽然这里看上去像正方形）。OpenGL的深度信息存储在Z缓冲中，也叫深度缓冲，GLFW会自动创建这个缓冲。当片段要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程就是深度测试，由OpenGL自动完成。</p><img src="/2019/04/09/Transformation/2.png" title="启动深度测试"><h2 id="平移-Translation-：使画好的cube沿着水平或垂直方向来回移动"><a href="#平移-Translation-：使画好的cube沿着水平或垂直方向来回移动" class="headerlink" title="平移(Translation)：使画好的cube沿着水平或垂直方向来回移动"></a>平移(Translation)：使画好的cube沿着水平或垂直方向来回移动</h2><p>用glm::translate生成平移矩阵，赋给model就可以实现平移。通过三角函数，可以实现立方体沿x轴来回移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> time = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line">model = glm::translate(model, glm::vec3(<span class="built_in">sin</span>(time) * <span class="number">4</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/04/09/Transformation/demo1.gif" title="平移"><h2 id="旋转-Rotation-：使画好的cube沿着XoZ平面的x-z轴持续旋转"><a href="#旋转-Rotation-：使画好的cube沿着XoZ平面的x-z轴持续旋转" class="headerlink" title="旋转(Rotation)：使画好的cube沿着XoZ平面的x=z轴持续旋转"></a>旋转(Rotation)：使画好的cube沿着XoZ平面的x=z轴持续旋转</h2><p>用glm::rotate生成旋转矩阵，赋给model就可以实现旋转。坐标设置为(1, 0, 1)，可以沿着x=z轴旋转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> time = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line">model = glm::rotate(model, time * <span class="number">2</span> * glm::radians(<span class="number">50.0f</span>), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/04/09/Transformation/demo2.gif" title="旋转"><h2 id="放缩-Scaling-：使画好的cube持续放大缩小"><a href="#放缩-Scaling-：使画好的cube持续放大缩小" class="headerlink" title="放缩(Scaling)：使画好的cube持续放大缩小"></a>放缩(Scaling)：使画好的cube持续放大缩小</h2><p>用glm::scale生成放缩矩阵，赋给model就可以实现放缩。利用三角函数和时间可以实现持续放缩。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> time = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line">model = glm::scale(model, glm::vec3(<span class="number">0.5</span> * <span class="built_in">sin</span>(time) + <span class="number">1</span>, <span class="number">0.5</span> * <span class="built_in">sin</span>(time) + <span class="number">1</span>, <span class="number">0.5</span> * <span class="built_in">sin</span>(time) + <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/04/09/Transformation/demo3.gif" title="放缩"><h2 id="在GUI里添加菜单栏，可以选择各种变换"><a href="#在GUI里添加菜单栏，可以选择各种变换" class="headerlink" title="在GUI里添加菜单栏，可以选择各种变换"></a>在GUI里添加菜单栏，可以选择各种变换</h2><p>用GUI将上述变换整合起来，得到结合的变换。旋转变换一定要放在最后，否则会使立方体偏离位置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ImGui::MenuItem(<span class="string">"translate"</span>, <span class="literal">NULL</span>, &amp;translate))</span><br><span class="line">    translateTime = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line"><span class="keyword">if</span> (ImGui::MenuItem(<span class="string">"scale"</span>, <span class="literal">NULL</span>, &amp;scale))</span><br><span class="line">    scaleTime = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line"><span class="keyword">if</span> (ImGui::MenuItem(<span class="string">"rotate"</span>, <span class="literal">NULL</span>, &amp;rotate))</span><br><span class="line">    rotateTime = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line"><span class="keyword">if</span> (translate)</span><br><span class="line">    model = glm::translate(model, glm::vec3(<span class="built_in">sin</span>( (time - translateTime)) * <span class="number">4</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"><span class="keyword">if</span> (scale)</span><br><span class="line">    model = glm::scale(model, glm::vec3(<span class="number">0.5</span> * <span class="built_in">sin</span>(time - scaleTime) + <span class="number">1</span>, <span class="number">0.5</span> * <span class="built_in">sin</span>(time - scaleTime) + <span class="number">1</span>, <span class="number">0.5</span> * <span class="built_in">sin</span>(time - scaleTime) + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (rotate)</span><br><span class="line">    model = glm::rotate(model, (time - rotateTime) * <span class="number">2</span> * glm::radians(<span class="number">50.0f</span>), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure></p><p>效果：</p><img src="/2019/04/09/Transformation/demo4.gif" title="GUI"><h2 id="结合Shader谈谈对渲染管线的理解"><a href="#结合Shader谈谈对渲染管线的理解" class="headerlink" title="结合Shader谈谈对渲染管线的理解"></a>结合Shader谈谈对渲染管线的理解</h2><p>渲染管线的作用是接受3D坐标，最终将它们转变成屏幕上的有色2D像素。渲染管线可以被划分成几个阶段，这些阶段高度专门化，并且容易并行执行。这些阶段在显卡中有各自对应的小程序，这些小程序就是着色器（Shader）。</p><p>渲染管线的第一个阶段是顶点着色器，它接受一个顶点坐标作为输入，进行坐标变换，处理顶点属性，然后输出变换后的3D坐标和属性。下一个阶段是图元装配，根据图元的类型接受来自顶点着色器的输入，将这些输入的坐标组装成对应的图元形状。几何着色器是第三个阶段，接受来自图元装配阶段的输入，通过产生新的顶点，构造新的图元，产生其他形状的图形。之后，数据会传入光栅化阶段，这个阶段会将图元映射到屏幕空间，生成片段，并且会裁剪出视口以外的像素。下一个阶段是片段着色器，能够计算像素的颜色，用于光照、阴影、颜色等效果。最后是Alpha测试和混合阶段，这个阶段进行深度检测和Alpha值检测，能够判断物体的深度和透明度，实现对象的遮挡和混合，最终输出符合预期的渲染效果。</p><h2 id="Bonus-将以上三种变换相结合，打开你们的脑洞，实现有创意的动画。"><a href="#Bonus-将以上三种变换相结合，打开你们的脑洞，实现有创意的动画。" class="headerlink" title="Bonus: 将以上三种变换相结合，打开你们的脑洞，实现有创意的动画。"></a>Bonus: 将以上三种变换相结合，打开你们的脑洞，实现有创意的动画。</h2><p>将平移和旋转结合起来，实现立方体在水平面上的滚动动画。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flip) &#123;</span><br><span class="line">    <span class="comment">// 判断旋转周期</span></span><br><span class="line">    <span class="keyword">if</span> (time - flipTime &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; time - flipTime &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        flipTime = time;</span><br><span class="line">        cycle++;</span><br><span class="line">        shift += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在不同的旋转周期，实现不同的变换</span></span><br><span class="line">    model = glm::translate(model, glm::vec3((shift + <span class="number">2</span> - <span class="number">20</span>), <span class="number">-2.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    model = glm::rotate(model, - (time - flipTime) * glm::radians(<span class="number">90.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    model = glm::translate(model, glm::vec3(<span class="number">-2.0f</span>, <span class="number">2.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    model = glm::rotate(model, -(cycle - <span class="number">1</span>) * glm::radians(<span class="number">90.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，通过滑块调整投射投影的可视角度，能够方便地调节场景可视范围。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImGui::SliderAngle(<span class="string">"viewing angle"</span>, &amp;viewAngle, <span class="number">10</span>, <span class="number">90</span>);</span><br><span class="line">projection = glm::perspective(viewAngle, (<span class="keyword">float</span>)windowWidth / windowHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/04/09/Transformation/demo5.gif" title="Bonus">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;画一个立方体，边长为4，中心位置为-0-0-0&quot;&gt;&lt;a href=&quot;#画一个立方体，边长为4，中心位置为-0-0-0&quot; class=&quot;headerlink&quot; title=&quot;画一个立方体，边长为4，中心位置为(0, 0, 0)&quot;&gt;&lt;/a&gt;画一个立方体，边长为4，中心
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>软件项目过程模型与规划</title>
    <link href="https://xungerrrr.github.io/2019/04/01/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%A7%84%E5%88%92/"/>
    <id>https://xungerrrr.github.io/2019/04/01/软件项目过程模型与规划/</id>
    <published>2019-04-01T14:24:32.000Z</published>
    <updated>2019-04-13T06:05:53.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点"><a href="#简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点" class="headerlink" title="简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点"></a>简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点</h2><p>从项目特点、风险特征、人力资源利用角度思考</p><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>降低软件开发的复杂程度，提高开发过程的透明性和可管理性。</li><li>推迟软件实现，强调分析和设计工作的重要性。</li><li>以项目的阶段评审和文档控制为手段，有效地对整个开发过程进行指导，能够及时发现并纠正问题。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>强调开发过程的线性顺序，缺乏灵活性。</li><li>无法解决软件需求不明确的问题。</li><li>瀑布模型是文档驱动的，规定过多的文档会大大增加工作量，仅根据文档来评估进度可能会出错。</li><li>风险控制的能力较弱。</li><li>资源调配问题：知识技能需求不同，人员数量要求不同。</li></ul><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>增强客户对系统的信心。</li><li>降低系统失败的风险。</li><li>提高系统可靠性。</li><li>提高系统的稳定性和可维护性。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>建立初始模型时，作为增量基础的基本业务服务的确定有一定难度。</li><li>增量粒度难以选择。</li></ul><h3 id="螺旋模型（含原型方法）"><a href="#螺旋模型（含原型方法）" class="headerlink" title="螺旋模型（含原型方法）"></a>螺旋模型（含原型方法）</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>风险驱动的迭代过程，强调可选方案和约束条件从而支持软件的重用，有助于将软件质量作为特殊目标融入产品开发之中。</li><li>结合了瀑布模型和快速原型方法，将瀑布模型的多个阶段转化到多个迭代过程中，以降低项目的风险。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>螺旋模型强调风险分析，但说服外部客户接受和相信分析结果并做出相关反应并不容易，因此螺旋模型往往比较适合内部的大规模软件开发。</li><li>风险分析需要耗费相当的成本，因此螺旋模型比较适合投资规模较大的软件项目。</li><li>失误的风险分析可能带来更大的风险。</li></ul><h2 id="简述统一过程三大特点，与面向对象的方法有什么关系？"><a href="#简述统一过程三大特点，与面向对象的方法有什么关系？" class="headerlink" title="简述统一过程三大特点，与面向对象的方法有什么关系？"></a>简述统一过程三大特点，与面向对象的方法有什么关系？</h2><ul><li>软件开发是一个迭代过程。</li><li>软件开发是由Use Case驱动的。</li><li>软件开发是以架构设计为中心的。</li></ul><p>统一过程是一个面向对象的软件开发方法，它给出了有关软件开发过程组织及实施的指导。</p><h2 id="简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？"><a href="#简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？" class="headerlink" title="简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？"></a>简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？</h2><p>统一过程四个阶段的划分准则是每个阶段的目标和里程碑。</p><ul><li>初始阶段<br>生命周期目标里程碑：通过对文档的评审确定用例需求理解正确、项目风险评估合理、阶段计划可行等。</li><li>细化阶段<br>生命周期体系结构里程碑：通过评审确定软件体系结构已经稳定、高风险的业务需求和技术机制已经解决、修订的项目计划可行等。</li><li>构建阶段<br>初始运行能力里程碑：包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署。此刻，要确定软件、环境、用户是否可以开始系统的运行。</li><li>交付阶段<br>产品发布里程碑：确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周<br>期。</li></ul><h2 id="软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？"><a href="#软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？" class="headerlink" title="软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？"></a>软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？</h2><p>软件企业采用基于统一过程的软件项目规划，利用软件产品范围的弹性，合理规划范围（20%业务决定80%满意度），使得软件企业按固定节奏生产、固定周期发布软件产品。</p><p>统一过程能够对过程加以调整改造，通过适当裁剪过程，可以调整生命周期阶段过程的正规性，持续优化过程。统一过程可以平衡竞争利益相关者的优先级，通过定义、理解和划分业务与用户优先次序的需求，为项目和需求制定优先次序，将需求和软件能力相结合，平衡资产重用与用户需求。统一过程可以创建自我管理的团队，鼓励跨职能协作，整合业务、软件和运作团队，从而激发开发成员的最佳表现。通过反复迭代，经过反馈、改变、消除风险和调整计划，可以有效证实项目目标的价值。统一过程还可以提高资源的重用率，并通过持续关注产品质量，保证项目质量的可靠。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点&quot;&gt;&lt;a href=&quot;#简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点&quot; class=&quot;headerlink&quot; title=&quot;简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点&quot;&gt;
      
    
    </summary>
    
    
      <category term="SE" scheme="https://xungerrrr.github.io/tags/SE/"/>
    
  </entry>
  
  <entry>
    <title>Draw Line</title>
    <link href="https://xungerrrr.github.io/2019/03/26/Draw-Line/"/>
    <id>https://xungerrrr.github.io/2019/03/26/Draw-Line/</id>
    <published>2019-03-26T05:42:18.000Z</published>
    <updated>2019-03-26T07:21:01.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Bresenham算法画一个三角形边框"><a href="#使用Bresenham算法画一个三角形边框" class="headerlink" title="使用Bresenham算法画一个三角形边框"></a>使用Bresenham算法画一个三角形边框</h2><p>根据要求，设计一个三角形的类，如下。在构造函数中输入三个顶点坐标。使用draw函数画图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Triangle(Shader &amp;shaderProgram, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x3, <span class="keyword">int</span> y3, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">float</span> col[]);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> color[<span class="number">3</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    <span class="keyword">int</span> windowWidth, windowHeight;</span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2, x3, y3;</span><br><span class="line">    Shader shader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> xn, <span class="keyword">int</span> yn)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">float</span> color[<span class="number">3</span>])</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>draw函数初始化缓冲区，然后调用drawLine函数画三角形的三条边：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Triangle::draw() &#123;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    </span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    drawLine(x1, y1, x2, y2);</span><br><span class="line">    drawLine(x1, y1, x3, y3);</span><br><span class="line">    drawLine(x2, y2, x3, y3);</span><br><span class="line"></span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>drawLine函数根据两个端点坐标，使用Bresenham算法计算直线上每一个点的坐标，然后调用drawPoint函数画点。步骤如下：</p><ol><li><p>输入数据</p><p> (x0, y0)为起点坐标，(xn, yn)为终点坐标。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Triangle::drawLine(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> xn, <span class="keyword">int</span> yn)</span><br></pre></td></tr></table></figure></li><li><p>计算Δx和Δy，判断Δx和Δy是否为0</p><p> 如果Δx和Δy都为0，说明两点重合，只画一个点；如果Δx为0，则画一条垂直的线；如果Δy为0，则画一条水平的线。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> delta_x = <span class="built_in">abs</span>(xn - x0), delta_y = <span class="built_in">abs</span>(yn - y0);</span><br><span class="line"><span class="keyword">int</span> x = x0, y = y0;</span><br><span class="line"><span class="keyword">if</span> (delta_x == <span class="number">0</span> &amp;&amp; delta_y == <span class="number">0</span>) &#123;</span><br><span class="line">    drawPoint(x, y, <span class="number">0</span>, color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delta_x == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> y_dir = (yn - y0) / delta_y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= delta_y; i++) &#123;</span><br><span class="line">        drawPoint(x, y, <span class="number">0</span>, color);</span><br><span class="line">        y += y_dir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delta_y == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> x_dir = (xn - x0) / delta_x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= delta_x; i++) &#123;</span><br><span class="line">        drawPoint(x, y, <span class="number">0</span>, color);</span><br><span class="line">        x += x_dir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果Δx和Δy均不为0，则使用Bresenham算法画直线</p><ul><li><p>斜率m的绝对值小于或等于1时，每次移动x坐标一个单位，然后计算y坐标。（根据端点坐标确定移动方向）</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">float</span>)delta_y / (<span class="keyword">float</span>)delta_x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> x_dir = (xn - x0) / delta_x;</span><br><span class="line">    <span class="keyword">int</span> y_dir = (yn - y0) / delta_y;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">2</span> * delta_y - delta_x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= delta_x; i++) &#123;</span><br><span class="line">        drawPoint(x, y, <span class="number">0</span>, color);</span><br><span class="line">        x += x_dir;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            p += (<span class="number">2</span> * delta_y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            y += y_dir;</span><br><span class="line">            p += (<span class="number">2</span> * delta_y - <span class="number">2</span> * delta_x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>斜率m的绝对值大与1时，每次移动y坐标一个单位，然后计算x坐标。（根据端点坐标确定移动方向）</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x_dir = (xn - x0) / delta_x;</span><br><span class="line">    <span class="keyword">int</span> y_dir = (yn - y0) / delta_y;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">2</span> * delta_x - delta_y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= delta_y; i++) &#123;</span><br><span class="line">        drawPoint(x, y, <span class="number">0</span>, color);</span><br><span class="line">        y += y_dir;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            p += (<span class="number">2</span> * delta_x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x += x_dir;</span><br><span class="line">            p += (<span class="number">2</span> * delta_x - <span class="number">2</span> * delta_y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>drawPoint函数会根据窗口大小，将输入的坐标值转换成-1~1之间的标准坐标值，然后绘制一个点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Triangle::drawPoint(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">float</span> color[<span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="keyword">float</span> point[<span class="number">6</span>];</span><br><span class="line">    point[<span class="number">0</span>] = (<span class="keyword">float</span>)x / windowWidth * <span class="number">2</span>;</span><br><span class="line">    point[<span class="number">1</span>] = (<span class="keyword">float</span>)y / windowHeight * <span class="number">2</span>;</span><br><span class="line">    point[<span class="number">2</span>] = z;</span><br><span class="line">    point[<span class="number">3</span>] = color[<span class="number">0</span>];</span><br><span class="line">    point[<span class="number">4</span>] = color[<span class="number">1</span>];</span><br><span class="line">    point[<span class="number">5</span>] = color[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    shader.use();</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, windowWidth, windowHeight);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(point), point, GL_STATIC_DRAW);</span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    glDrawArrays(GL_POINTS, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在ImGui设置三个点的坐标，就可以画出三角形</p><img src="/2019/03/26/Draw-Line/1.png" title="三角形"><h2 id="使用Bresenham算法画一个圆"><a href="#使用Bresenham算法画一个圆" class="headerlink" title="使用Bresenham算法画一个圆"></a>使用Bresenham算法画一个圆</h2><p>根据要求，设计一个圆的类，如下。在构造函数中输入圆心坐标和半径。使用draw函数画图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(Shader &amp;shaderProgram, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> r, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> color[<span class="number">3</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    <span class="keyword">int</span> windowWidth, windowHeight;</span><br><span class="line">    <span class="keyword">int</span> x0, y0, r;</span><br><span class="line">    Shader shader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawSymmetricPoints</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">float</span> color[<span class="number">3</span>])</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>draw函数初始化缓冲区，使用Bresenham算法计算1/8圆周的坐标，然后调用drawSymmetricPoints画出所有8个对称点。计算时，x坐标每次增加1，然后计算y坐标的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = x0, y = y0 + r, d = <span class="number">1</span> - r;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r / <span class="built_in">sqrt</span>(<span class="number">2</span>); i++) &#123;</span><br><span class="line">    drawSymmetricPoints(x, y);</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">if</span> (d &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        d += (<span class="number">2</span> * (x - x0) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        y--;</span><br><span class="line">        d += (<span class="number">2</span> * (x - y + y0 - x0) + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>drawSymmetricPoints函数计算8个关于圆心对称的点，然后调用drawPoint函数画点。drawPoint函数与画三角形的drawPoint函数相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Circle::drawSymmetricPoints(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">    drawPoint(x, y, <span class="number">0</span>, color);</span><br><span class="line">    drawPoint(y - y0 + x0, x - x0 + y0, <span class="number">0</span>, color);</span><br><span class="line">    drawPoint(<span class="number">2</span> * x0 - x, y, <span class="number">0</span>, color);</span><br><span class="line">    drawPoint(y - y0 + x0, x0 + y0 - x, <span class="number">0</span>, color);</span><br><span class="line">    drawPoint(x, <span class="number">2</span> * y0 - y, <span class="number">0</span>, color);</span><br><span class="line">    drawPoint(y0 + x0 - y, x - x0 + y0, <span class="number">0</span>, color);</span><br><span class="line">    drawPoint(<span class="number">2</span> * x0 - x, <span class="number">2</span> * y0 - y, <span class="number">0</span>, color);</span><br><span class="line">    drawPoint(y0 + x0 - y, x0 + y0 - x, <span class="number">0</span>, color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在ImGui设置圆心坐标和半径，就可以画出圆。</p><img src="/2019/03/26/Draw-Line/2.png" title="圆"><h2 id="在GUI在添加菜单栏，可以选择是三角形边框还是圆，以及能调整圆的大小"><a href="#在GUI在添加菜单栏，可以选择是三角形边框还是圆，以及能调整圆的大小" class="headerlink" title="在GUI在添加菜单栏，可以选择是三角形边框还是圆，以及能调整圆的大小"></a>在GUI在添加菜单栏，可以选择是三角形边框还是圆，以及能调整圆的大小</h2><p>在菜单栏中绑定bool对象，实现选择：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ImGui::BeginMainMenuBar()) &#123;</span><br><span class="line">    ImGui::MenuItem(<span class="string">"Triangle"</span>, <span class="literal">NULL</span>, &amp;tri);</span><br><span class="line">    ImGui::MenuItem(<span class="string">"Circle"</span>, <span class="literal">NULL</span>, &amp;cir);</span><br><span class="line">    ImGui::EndMainMenuBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>圆的参数由ImGuid的滑块传入，因此可以调整圆的大小：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cir) &#123;</span><br><span class="line">    ImGui::Begin(<span class="string">"Circle"</span>);</span><br><span class="line">    ImGui::SliderInt(<span class="string">"x"</span>, center, -windowWidth / <span class="number">2</span>, windowWidth / <span class="number">2</span>);</span><br><span class="line">    ImGui::SliderInt(<span class="string">"y"</span>, center + <span class="number">1</span>, -windowWidth / <span class="number">2</span>, windowWidth / <span class="number">2</span>);</span><br><span class="line">    ImGui::SliderInt(<span class="string">"Radius"</span>, radius, <span class="number">0</span>, windowWidth / <span class="number">2</span>);</span><br><span class="line">    ImGui::End();</span><br><span class="line">    <span class="function">Circle <span class="title">circle</span><span class="params">(shader, center[<span class="number">0</span>], center[<span class="number">1</span>], radius[<span class="number">0</span>], windowWidth, windowHeight)</span></span>;</span><br><span class="line">    circle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bonus：使用三角形光栅转换算法，用和背景不同的颜色，填充你的三角形"><a href="#Bonus：使用三角形光栅转换算法，用和背景不同的颜色，填充你的三角形" class="headerlink" title="Bonus：使用三角形光栅转换算法，用和背景不同的颜色，填充你的三角形"></a>Bonus：使用三角形光栅转换算法，用和背景不同的颜色，填充你的三角形</h2><p>给三角形类添加两个方法。fill方法用来填充三角形，contain方法用来判断一个点是否在三角形内部。</p><p>fill函数中，先对顶点坐标进行排序，得到三角形的包围盒。然后遍历包围盒内的点，调用contain判断点是否在内部，最后调用drawPoint画点即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = x_axis[<span class="number">0</span>]; x &lt;= x_axis[<span class="number">2</span>]; x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = y_axis[<span class="number">0</span>]; y &lt;= y_axis[<span class="number">2</span>]; y++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (contain(x, y)) &#123;</span><br><span class="line">            drawPoint(x, y, <span class="number">0</span>, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>contain函数使用向量的向量积来判断点是否在三角形内部。以该点为起点，分别以三个顶点为终点，可以得到三个向量。按照顺序两两求向量积，得到三个乘积。如果三个乘积同号，则说明点在三角形内部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Triangle::contain(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">int</span> v1[] = &#123; x - x1, y - y1 &#125;;</span><br><span class="line">    <span class="keyword">int</span> v2[] = &#123; x - x2, y - y2 &#125;;</span><br><span class="line">    <span class="keyword">int</span> v3[] = &#123; x - x3, y - y3 &#125;;</span><br><span class="line">    <span class="keyword">int</span> cross_product_1 = v1[<span class="number">0</span>] * v2[<span class="number">1</span>] - v1[<span class="number">1</span>] * v2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> cross_product_2 = v2[<span class="number">0</span>] * v3[<span class="number">1</span>] - v2[<span class="number">1</span>] * v3[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> cross_product_3 = v3[<span class="number">0</span>] * v1[<span class="number">1</span>] - v3[<span class="number">1</span>] * v1[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (cross_product_1 * cross_product_2 &gt;= <span class="number">0</span> &amp;&amp; cross_product_2 * cross_product_3 &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充结果</p><img src="/2019/03/26/Draw-Line/3.png" title="填充"><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><img src="/2019/03/26/Draw-Line/demo.gif" title="动画">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用Bresenham算法画一个三角形边框&quot;&gt;&lt;a href=&quot;#使用Bresenham算法画一个三角形边框&quot; class=&quot;headerlink&quot; title=&quot;使用Bresenham算法画一个三角形边框&quot;&gt;&lt;/a&gt;使用Bresenham算法画一个三角形边框&lt;/
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>GUI and Draw Simple Graphics</title>
    <link href="https://xungerrrr.github.io/2019/03/11/GUI-and-Draw-Simple-Graphics/"/>
    <id>https://xungerrrr.github.io/2019/03/11/GUI-and-Draw-Simple-Graphics/</id>
    <published>2019-03-11T12:45:12.000Z</published>
    <updated>2019-03-14T17:53:57.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用OpenGL-3-3及以上-GLFW画一个简单的三角形"><a href="#使用OpenGL-3-3及以上-GLFW画一个简单的三角形" class="headerlink" title="使用OpenGL(3.3及以上)+GLFW画一个简单的三角形"></a>使用OpenGL(3.3及以上)+GLFW画一个简单的三角形</h2><p>在画三角形之前，首先要初始化GLFW和GLAD，以及创建窗口。这里不详细说明。</p><p>在OpenGL中，3D坐标转换成2D坐标是由图形渲染管线完成的，可以被分成几个阶段，每一个阶段都有专门的运行程序，称为着色器。OpenGL中的着色器是用GLSL语言编写的。在现代OpenGL中，必须定义至少一个顶点着色器和一个片段着色器，因此要编写、编译和链接着色器。</p><h3 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h3><h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><p>画一个简单的三角形，只需要顶点的位置属性。在关键字in后声明一个三维的位置属性，可以实现这个简单的功能。在main函数中将位置转换成四维变量，输出到gl_Position中，就实现了顶点着色器的位置输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h4><p>在片段着色器中，使用关键字out输出一个颜色变量，颜色为(1.0, 0.5, 0.2, 1.0)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FragColor = vec4(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="着色器的编译和链接"><a href="#着色器的编译和链接" class="headerlink" title="着色器的编译和链接"></a>着色器的编译和链接</h3><p>为了实现这一功能，编写一个类，用于着色器的编译、链接和使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shader</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 程序ID</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">    <span class="comment">// 编译和链接</span></span><br><span class="line">    Shader(<span class="keyword">const</span> GLchar* vertexPath, <span class="keyword">const</span> GLchar* fragmentPath);</span><br><span class="line">    <span class="comment">// 使用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在构造函数中，读取着色器文件，并使用glCompileShader编译。以顶点着色器为例，编译过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line"><span class="keyword">int</span> success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(vertexShader);</span><br><span class="line"><span class="comment">// 检查编译状态</span></span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完成后，将两个着色器链接成程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shaderProgram = glCreateProgram();</span><br><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure><h3 id="着色器程序的使用"><a href="#着色器程序的使用" class="headerlink" title="着色器程序的使用"></a>着色器程序的使用</h3><p>调用glUseProgram函数以激活着色器程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Shader::use() &#123;</span><br><span class="line">    glUseProgram(shaderProgram);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顶点数据的输入、绑定和解析"><a href="#顶点数据的输入、绑定和解析" class="headerlink" title="顶点数据的输入、绑定和解析"></a>顶点数据的输入、绑定和解析</h3><p>定义一个数组来存储三角形三个点的坐标数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过顶点缓冲对象（VBO）管理数据。这里的数据是不变的，因此使用GL_STATIC_DRAW。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>此外，还需要调用glVertexAttribPointer，告诉OpenGL怎么解析数组中的数据。解析的时候，每次解析3个元素，跳过3个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="顶点数组对象"><a href="#顶点数组对象" class="headerlink" title="顶点数组对象"></a>顶点数组对象</h3><p>通过绑定VAO，可以将多个VBO集成到顶点数组中，方便多次绘制重复的图形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">glBindVertexArray(VAO);</span><br></pre></td></tr></table></figure><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>使用While循环进行多帧渲染。先激活程序、绑定VAO，然后输入三角形图元，用glDrawArrays生成图形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shader.use();</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><img src="/2019/03/11/GUI-and-Draw-Simple-Graphics/1.png" title="简单三角形"><h2 id="对三角形的三个顶点分别改为红绿蓝。并解释为什么会出现这样的结果"><a href="#对三角形的三个顶点分别改为红绿蓝。并解释为什么会出现这样的结果" class="headerlink" title="对三角形的三个顶点分别改为红绿蓝。并解释为什么会出现这样的结果"></a>对三角形的三个顶点分别改为红绿蓝。并解释为什么会出现这样的结果</h2><h3 id="修改着色器"><a href="#修改着色器" class="headerlink" title="修改着色器"></a>修改着色器</h3><h4 id="顶点着色器-1"><a href="#顶点着色器-1" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><p>为了使三个顶点输出不同的颜色，要在顶点着色器中增加颜色属性。aColor为输入颜色，ourColor为输出颜色。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 aColor;</span><br><span class="line"></span><br><span class="line">out vec3 ourColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="片段着色器-1"><a href="#片段着色器-1" class="headerlink" title="片段着色器"></a>片段着色器</h4><p>片段着色器接收来自顶点着色器的输入，转成vec4后输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec3 ourColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FragColor = vec4(ourColor, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改数组和解析方式"><a href="#修改数组和解析方式" class="headerlink" title="修改数组和解析方式"></a>修改数组和解析方式</h3><p>在数组的每一行添加三个颜色分量数据，表示顶点的颜色：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>     <span class="comment">// 上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解析位置的时候，每次解析3个元素，跳过6个元素；解析颜色的时候，每次解析3个元素，跳过6个元素，开始时跳过3个元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="渲染结果"><a href="#渲染结果" class="headerlink" title="渲染结果"></a>渲染结果</h3><img src="/2019/03/11/GUI-and-Draw-Simple-Graphics/2.png" title="多色三角形"><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>在光栅化的阶段，会产生比指定顶点更多的片段。对于没有定义颜色的片段，会根据片段所处的位置，进行颜色的插值。简单来讲，就是根据位置，对已知顶点的颜色进行线性组合。</p><h2 id="给上述工作添加一个GUI，里面有一个菜单栏，使得可以选择并改变三角形的颜色。"><a href="#给上述工作添加一个GUI，里面有一个菜单栏，使得可以选择并改变三角形的颜色。" class="headerlink" title="给上述工作添加一个GUI，里面有一个菜单栏，使得可以选择并改变三角形的颜色。"></a>给上述工作添加一个GUI，里面有一个菜单栏，使得可以选择并改变三角形的颜色。</h2><h3 id="初始化ImGUI"><a href="#初始化ImGUI" class="headerlink" title="初始化ImGUI"></a>初始化ImGUI</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ImGui::CreateContext();</span><br><span class="line">ImGuiIO &amp;io = ImGui::GetIO(); (<span class="keyword">void</span>)io;</span><br><span class="line">ImGui::StyleColorsDark();</span><br><span class="line">ImGui_ImplGlfw_InitForOpenGL(window, <span class="literal">true</span>);</span><br><span class="line">ImGui_ImplOpenGL3_Init(<span class="string">"#version 330"</span>);</span><br></pre></td></tr></table></figure><h3 id="定义一个向量，存储三个顶点的颜色值"><a href="#定义一个向量，存储三个顶点的颜色值" class="headerlink" title="定义一个向量，存储三个顶点的颜色值"></a>定义一个向量，存储三个顶点的颜色值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImVec4&gt; colors;</span><br><span class="line">colors.push_back(ImVec4(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">colors.push_back(ImVec4(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">colors.push_back(ImVec4(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure><h3 id="在渲染循环里，设置ImGUI样式，生成三个颜色选择器"><a href="#在渲染循环里，设置ImGUI样式，生成三个颜色选择器" class="headerlink" title="在渲染循环里，设置ImGUI样式，生成三个颜色选择器"></a>在渲染循环里，设置ImGUI样式，生成三个颜色选择器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ImGui_ImplOpenGL3_NewFrame();</span><br><span class="line">ImGui_ImplGlfw_NewFrame();</span><br><span class="line">ImGui::NewFrame();</span><br><span class="line"></span><br><span class="line">ImGui::Begin(<span class="string">"Color Setting"</span>);</span><br><span class="line">ImGui::ColorEdit3(<span class="string">"Left corner color"</span>, (<span class="keyword">float</span>*)&amp;colors[<span class="number">0</span>]);</span><br><span class="line">ImGui::ColorEdit3(<span class="string">"Right corner color"</span>, (<span class="keyword">float</span>*)&amp;colors[<span class="number">1</span>]);</span><br><span class="line">ImGui::ColorEdit3(<span class="string">"Top corner color"</span>, (<span class="keyword">float</span>*)&amp;colors[<span class="number">2</span>]);</span><br><span class="line">ImGui::End();</span><br></pre></td></tr></table></figure><h3 id="根据选择的颜色，改变数组元素的值，达到修改颜色的目的。修改后要重新绑定数据。"><a href="#根据选择的颜色，改变数组元素的值，达到修改颜色的目的。修改后要重新绑定数据。" class="headerlink" title="根据选择的颜色，改变数组元素的值，达到修改颜色的目的。修改后要重新绑定数据。"></a>根据选择的颜色，改变数组元素的值，达到修改颜色的目的。修改后要重新绑定数据。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    vertices[<span class="number">6</span> * i + <span class="number">3</span>] = colors[i].x;</span><br><span class="line">    vertices[<span class="number">6</span> * i + <span class="number">4</span>] = colors[i].y;</span><br><span class="line">    vertices[<span class="number">6</span> * i + <span class="number">5</span>] = colors[i].z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染-1"><a href="#渲染-1" class="headerlink" title="渲染"></a>渲染</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImGui::Render();</span><br><span class="line">ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());</span><br></pre></td></tr></table></figure><img src="/2019/03/11/GUI-and-Draw-Simple-Graphics/3.png" title="GUI"><h2 id="使用EBO-Element-Buffer-Object-绘制多个三角形"><a href="#使用EBO-Element-Buffer-Object-绘制多个三角形" class="headerlink" title="使用EBO(Element Buffer Object)绘制多个三角形"></a>使用EBO(Element Buffer Object)绘制多个三角形</h2><h3 id="添加三角形和对应的索引"><a href="#添加三角形和对应的索引" class="headerlink" title="添加三角形和对应的索引"></a>添加三角形和对应的索引</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三个三角形</span></span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">    <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="EBO的创建和绑定"><a href="#EBO的创建和绑定" class="headerlink" title="EBO的创建和绑定"></a>EBO的创建和绑定</h3><p>缓冲类型是GL_ELEMENT_ARRAY_BUFFER</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><h3 id="渲染-2"><a href="#渲染-2" class="headerlink" title="渲染"></a>渲染</h3><p>渲染时，将glDrawArrays改为glDrawElements，使用EBO中的索引进行渲染。参数分别是图元、顶点数量、索引数据类型和索引偏移量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><img src="/2019/03/11/GUI-and-Draw-Simple-Graphics/4.png" title="多个三角形"><h2 id="绘制其他的图元，除了三角形，还有点、线等"><a href="#绘制其他的图元，除了三角形，还有点、线等" class="headerlink" title="绘制其他的图元，除了三角形，还有点、线等"></a>绘制其他的图元，除了三角形，还有点、线等</h2><h3 id="扩充数组"><a href="#扩充数组" class="headerlink" title="扩充数组"></a>扩充数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三个三角形</span></span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一条线</span></span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二条线</span></span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点</span></span><br><span class="line">    <span class="number">-0.75f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.75f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="渲染-3"><a href="#渲染-3" class="headerlink" title="渲染"></a>渲染</h3><p>使用glDrawArrays进行渲染，传入图元GL_LINES绘制直线，传入图元GL_POINTS绘制点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_LINES, <span class="number">9</span>, <span class="number">4</span>);</span><br><span class="line">glDrawArrays(GL_POINTS, <span class="number">13</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>如下图，新增两条白线和两个白点：</p><img src="/2019/03/11/GUI-and-Draw-Simple-Graphics/5.png" title="线和点"><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p><a href="https://github.com/Xungerrrr/SYSU-CG/tree/master/GUI%20and%20Draw%20Simple%20Graphics" target="_blank" rel="noopener">https://github.com/Xungerrrr/SYSU-CG/tree/master/GUI%20and%20Draw%20Simple%20Graphics</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用OpenGL-3-3及以上-GLFW画一个简单的三角形&quot;&gt;&lt;a href=&quot;#使用OpenGL-3-3及以上-GLFW画一个简单的三角形&quot; class=&quot;headerlink&quot; title=&quot;使用OpenGL(3.3及以上)+GLFW画一个简单的三角形&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>软件项目与知识团队管理基础</title>
    <link href="https://xungerrrr.github.io/2019/03/10/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    <id>https://xungerrrr.github.io/2019/03/10/软件项目与知识团队管理基础/</id>
    <published>2019-03-10T14:41:32.000Z</published>
    <updated>2019-03-24T15:37:09.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><h3 id="用简短的语言给出对分析、设计的理解。"><a href="#用简短的语言给出对分析、设计的理解。" class="headerlink" title="用简短的语言给出对分析、设计的理解。"></a>用简短的语言给出对分析、设计的理解。</h3><ul><li>分析强调的是对问题和需求的调查研究，而不是解决方案。例如，如果需要一个新的在线交易系统，它会怎样被使用？它有什么功能？分析是做正确的事情(Do the right thing)。</li><li>设计强调的是满足需求的概念上的解决方案（在软件方面和硬件方面），而不是其实现。例如，对数据库模式和软件对象的描述。设计是把事情做对（Do the thing right)。</li></ul><h3 id="用一句话描述面向对象的分析与设计的优势。"><a href="#用一句话描述面向对象的分析与设计的优势。" class="headerlink" title="用一句话描述面向对象的分析与设计的优势。"></a>用一句话描述面向对象的分析与设计的优势。</h3><p>能够构建与真实世界相似的问题模型和对象，符合人在世界中的思维方式，使得人能够更好地理解和设计。</p><h3 id="简述-UML（统一建模语言）的作用。考试考哪些图？"><a href="#简述-UML（统一建模语言）的作用。考试考哪些图？" class="headerlink" title="简述 UML（统一建模语言）的作用。考试考哪些图？"></a>简述 UML（统一建模语言）的作用。考试考哪些图？</h3><p>将分析和设计的结果可视化，将问题抽象成容易理解的可视化模型。</p><p>UML图分四类：</p><ul><li>用例图：用户角度：功能、执行者</li><li>静态图：系统静态结构<ul><li>类图：概念及关系</li><li>对象图：某种状态或时间段内，系统中活跃的对象及其关系</li><li>包图：描述系统的分解结构</li></ul></li><li>行为图：系统的动态行为<ul><li>交互图：描述对象间的消息传递<ul><li>顺序图：强调对象间消息发送的时序</li><li>合作图：强调对象间的动态协作关系</li></ul></li><li>状态图：对象的动态行为。状态-事件-状态迁移-响应动作</li><li>活动图：描述系统为完成某功能而执行的操作序列</li></ul></li><li>实现图：描述系统的组成和分布情况<ul><li>构件图：组成部件及其关系</li><li>部署图：物理体系结构及与软件单元的对应关系</li></ul></li></ul><h3 id="从软件本质的角度，解释软件范围（需求）控制的可行性"><a href="#从软件本质的角度，解释软件范围（需求）控制的可行性" class="headerlink" title="从软件本质的角度，解释软件范围（需求）控制的可行性"></a>从软件本质的角度，解释软件范围（需求）控制的可行性</h3><p>软件的本质决定了软件开发的困难，Brook总结其本质特性为四个：复杂性、不一致性、可变性、不可见性。因此，软件范围多数情况下对于客户和开发者都是模糊的，这形成软件产品与其他产品不同的开发过程。在保证需求的前提下，可以砍去一些客户都没思考清晰的业务，通过多次反馈和迭代进行开发和升级，使得软件的范围和需求受控。</p><h2 id="项目管理实践"><a href="#项目管理实践" class="headerlink" title="项目管理实践"></a>项目管理实践</h2><h3 id="看板使用练习（提交看板执行结果贴图，建议使用-Git-project）"><a href="#看板使用练习（提交看板执行结果贴图，建议使用-Git-project）" class="headerlink" title="看板使用练习（提交看板执行结果贴图，建议使用 Git project）"></a>看板使用练习（提交看板执行结果贴图，建议使用 Git project）</h3><ul><li>使用截图工具（pnsg 格式输出），展现你团队的任务 Kanban</li><li>每个人的任务是明确的。必须一周后可以看到具体结果</li><li>每个人的任务是 1-2 项</li><li>至少包含一个团队活动任务</li></ul><img src="/2019/03/10/软件项目与知识团队管理基础/kanban.png" title="看板"><h3 id="UML-绘图工具练习（提交贴图，必须使用-UMLet）"><a href="#UML-绘图工具练习（提交贴图，必须使用-UMLet）" class="headerlink" title="UML 绘图工具练习（提交贴图，必须使用 UMLet）"></a>UML 绘图工具练习（提交贴图，必须使用 UMLet）</h3><p>《UML和模式应用（原书第3版）》，P6，图1-3：</p><img src="/2019/03/10/软件项目与知识团队管理基础/uml.png" title="uml"><p>各模块参数：</p><img src="/2019/03/10/软件项目与知识团队管理基础/1.png" title="DiceGame"><img src="/2019/03/10/软件项目与知识团队管理基础/2.png" title="Die"><img src="/2019/03/10/软件项目与知识团队管理基础/3.png" title="Arrow">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简答题&quot;&gt;&lt;a href=&quot;#简答题&quot; class=&quot;headerlink&quot; title=&quot;简答题&quot;&gt;&lt;/a&gt;简答题&lt;/h2&gt;&lt;h3 id=&quot;用简短的语言给出对分析、设计的理解。&quot;&gt;&lt;a href=&quot;#用简短的语言给出对分析、设计的理解。&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="SE" scheme="https://xungerrrr.github.io/tags/SE/"/>
    
  </entry>
  
  <entry>
    <title>Learn About CG</title>
    <link href="https://xungerrrr.github.io/2019/03/04/Learn-About-CG/"/>
    <id>https://xungerrrr.github.io/2019/03/04/Learn-About-CG/</id>
    <published>2019-03-04T06:18:30.000Z</published>
    <updated>2019-03-14T17:57:57.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="谈谈自己对计算机图形学的理解。"><a href="#谈谈自己对计算机图形学的理解。" class="headerlink" title="谈谈自己对计算机图形学的理解。"></a>谈谈自己对计算机图形学的理解。</h2><p>我对计算机图形学的理解是，计算机图形学是一门利用计算机对二维或三维图形进行表示、处理、计算、显示和交互的学科。通过各种建模方法，在计算机中建立几何图形的模型，这是图形的表示过程。通过渲染技术，将图形模型转换成显示器的栅格形式，或者是转换成全息图像形式，这是图形的处理、计算和显示过程。通过各种输入工具，改变图形的状态，这是交互过程。这些都是计算机图形学研究的范畴。</p><h2 id="什么是OpenGL？OpenGL-ES？Web-GL？Vulkan？DirectX？"><a href="#什么是OpenGL？OpenGL-ES？Web-GL？Vulkan？DirectX？" class="headerlink" title="什么是OpenGL？OpenGL ES？Web GL？Vulkan？DirectX？"></a>什么是OpenGL？OpenGL ES？Web GL？Vulkan？DirectX？</h2><ul><li>OpenGL是一个API（Application Programming Interface，应用程序编程接口），是跨编程语言及跨平台的接口，包含了一系列可以操作图形、图像的函数，用于渲染2D和3D图形。更确切地说，OpenGL是一个规范，规定了每个函数的用法和输出值，具体的实现一般由显卡厂商完成。</li><li>OpenGL ES（OpenGL for Embedded Systems）是OpenGL规范的子集，用于嵌入式设备的图形渲染。相比于OpenGL，OpenGL ES去除了一些非必要的特性，是OpenGL的简化版本。</li><li>WebGL是一种绘图标准，将JavaScript和OpenGL ES结合在一起，使得网页可以调用系统显卡进行硬件加速渲染，从而在浏览器中流畅地显示3D图形。</li><li>Vulkan是另一种跨平台的绘图应用程序接口，提供了许多比OpenGL更加先进的特性，性能比OpenGL要更好，是OpenGL的替代者。</li><li>DirectX是由微软开发的多媒体编程接口，提供了显示、声音、输入、网络等API，功能十分丰富，不只是一个图形编程接口，用于Windows系统多媒体应用开发。</li></ul><h2 id="gl-h-glu-h-glew-h的作用分别是什么？"><a href="#gl-h-glu-h-glew-h的作用分别是什么？" class="headerlink" title="gl.h glu.h glew.h的作用分别是什么？"></a>gl.h glu.h glew.h的作用分别是什么？</h2><ul><li>gl.h是OpenGL 1.1的基础头文件，包含了OpenGL 1.1的功能。如果需要使用新功能，需要添加OpenGL的扩展库。</li><li>glu.h是OpenGL Utilities库，包含了一些方便的函数，但是已经过时，现在一般不用。</li><li>glew.h是OpenGL Extension Wrangler Library，用于使用OpenGL的扩展功能，其中包含了gl.h。OpenGL版本众多，因此编译的时候无法将函数的位置确定下来，需要在运行时查询。借助glew.h，可以在运行时根据硬件方便地管理OpenGL的函数指针，定位函数的位置。</li></ul><h2 id="使用GLFW和freeglut的目的是什么？"><a href="#使用GLFW和freeglut的目的是什么？" class="headerlink" title="使用GLFW和freeglut的目的是什么？"></a>使用GLFW和freeglut的目的是什么？</h2><p>创建OpenGL上下文、创建显示窗口和处理用户输入，在每个系统上都有不一样的操作。作为一个跨平台API，OpenGL将这部分功能抽象出去，因此需要我们去手动处理。使用GLFW或者freeglut，可以方便地创建OpenGL上下文、定义窗口参数和处理用户输入，而不需要使用操作系统复杂的API，节省编程时间和难度。</p><h2 id="结合上述参考链接，选择一个SIGGRAPH-2017-2018上你最喜欢的专题，介绍该专题是做什么的，使用了什么CG技术？"><a href="#结合上述参考链接，选择一个SIGGRAPH-2017-2018上你最喜欢的专题，介绍该专题是做什么的，使用了什么CG技术？" class="headerlink" title="结合上述参考链接，选择一个SIGGRAPH 2017/2018上你最喜欢的专题，介绍该专题是做什么的，使用了什么CG技术？"></a>结合上述参考链接，选择一个SIGGRAPH 2017/2018上你最喜欢的专题，介绍该专题是做什么的，使用了什么CG技术？</h2><p>我对SIGGRAPH 2018中的Computational photos and videos专题比较感兴趣。这个专题做的是计算摄影方面的研究，目的是利用有限的图片信息，计算出场景的深度信息，也就是生成三维的场景。这个专题中有两篇研究论文。第一篇是<a href="http://delivery.acm.org/10.1145/3210000/3201329/a64-wadhwa.pdf?ip=120.236.174.139&amp;id=3201329&amp;acc=OPENTOC&amp;key=BF85BBA5741FDC6E%2E3D07CFA6C3F555EA%2E4D4702B0C3E38B35%2E383ADA7593775D6F&amp;__acm__=1551716722_7848def64dc95e9252115c00fad0b02f" target="_blank" rel="noopener"><em>Synthetic Depth-of-Field with a Single-Camera Mobile Phone</em></a>，实现了利用单个手机摄像头计算出照片的景深信息，得到类似于单反镜头的背景虚化效果，由Google Research团队发表，目前已用于Google Pixel系列手机中的人像模式功能。第二篇是<a href="http://delivery.acm.org/10.1145/3210000/3201323/a65-zhou.pdf?ip=120.236.174.139&amp;id=3201323&amp;acc=OPENTOC&amp;key=BF85BBA5741FDC6E%2E3D07CFA6C3F555EA%2E4D4702B0C3E38B35%2E383ADA7593775D6F&amp;__acm__=1551716806_39a7933ec8e03f668f238b0fc39fe828" target="_blank" rel="noopener"><em>Stereo Magnification: Learning view synthesis using multiplane images</em></a>，利用双镜头拍摄的两张照片，就可以生成一个动画，模拟出在三维场景中运动的场景。该专题运用了CG中的建模和渲染技术，都是先计算出场景的景深信息，构建出场景的模型，然后渲染成高真实度的照片和动画。两篇论文都涉及到基于图像的渲染技术（Image-based rendering）。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <a href="http://staff.ustc.edu.cn/~lgliu/Resources/CG/What_is_CG.htm" target="_blank" rel="noopener">什么是计算机图形学？</a><br>[2] <a href="https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/" target="_blank" rel="noopener">什么是OpenGL</a><br>[3] <a href="https://www.siggraph.org//learn/conference-content" target="_blank" rel="noopener">SIGGRAGPH Conference Content</a><br>[4] <a href="http://kesen.realtimerendering.com/sig2017.html" target="_blank" rel="noopener">SIGGRAPH 2018专题与论文集合</a><br>[5] <a href="https://www.siggraph.org/sites/default/files/ACM%20Transactions%20on%20Graphics%20Volume%2037%20Issue%204%20August%202018.html" target="_blank" rel="noopener">SIGGRAPH 2018论文集</a><br>[6] <a href="https://www.leiphone.com/news/201808/fX05lhGQo2X50Wya.html" target="_blank" rel="noopener">SIGGRAPH 2018：VR凉凉？逛完展你就知道了</a><br>[7] <a href="https://zhuanlan.zhihu.com/p/38082963" target="_blank" rel="noopener">SIGGRAPH 2018 不能错过的八大精彩</a><br>[8] <a href="https://www.zhihu.com/question/60903441?from=profile_question_card://www.siggraph.org/sites/default/files/sa-17-tog-open-access.html" target="_blank" rel="noopener">SIGGRAPH 2017 有啥有意思的 project？</a><br>[9] <a href="https://www.leiphone.com/news/201707/ZSLKstyMCMgP1hO3.html" target="_blank" rel="noopener">SIGGRAPH 2017：一窥AR/VR最新趋势</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;谈谈自己对计算机图形学的理解。&quot;&gt;&lt;a href=&quot;#谈谈自己对计算机图形学的理解。&quot; class=&quot;headerlink&quot; title=&quot;谈谈自己对计算机图形学的理解。&quot;&gt;&lt;/a&gt;谈谈自己对计算机图形学的理解。&lt;/h2&gt;&lt;p&gt;我对计算机图形学的理解是，计算机图形
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>软件的本质与软件工程科学</title>
    <link href="https://xungerrrr.github.io/2019/03/03/%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%A7%91%E5%AD%A6/"/>
    <id>https://xungerrrr.github.io/2019/03/03/软件的本质与软件工程科学/</id>
    <published>2019-03-03T05:04:15.000Z</published>
    <updated>2019-03-13T09:22:36.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件工程的定义"><a href="#软件工程的定义" class="headerlink" title="软件工程的定义"></a>软件工程的定义</h2><blockquote><p>Software engineering is “(1) the application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software, that is, the application of engineering to software,” and “(2) the study of approaches as in (1).” – IEEE Standard 610.12</p></blockquote><p>软件工程是，系统化、规范化、可度量化的方法在软件开发、运行和维护中的应用，即工程化方法在软件中的应用，以及对这些方法的研究。</p><h2 id="解释导致software-crisis本质原因、表现，述说克服软件危机的方法"><a href="#解释导致software-crisis本质原因、表现，述说克服软件危机的方法" class="headerlink" title="解释导致software crisis本质原因、表现，述说克服软件危机的方法"></a>解释导致software crisis本质原因、表现，述说克服软件危机的方法</h2><h3 id="本质原因"><a href="#本质原因" class="headerlink" title="本质原因"></a>本质原因</h3><p>导致软件危机的本质原因是计算机硬件的飞速发展。根据软件构造性成本模型COCOMO（Constructive Cost Model），软件的成本与代码行的数量成指数关系。计算机的能力越强大，软件编程就越复杂，软件成本呈指数爆炸式增长，软件开发的效率也逐渐变低。传统的软件开发方法不能适应硬件的高速发展，导致了软件危机的出现。</p><h3 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h3><ul><li>项目运行超出预算</li><li>项目运行超出时间</li><li>软件效率低</li><li>软件质量差</li><li>软件不匹配需求</li><li>项目难以管理和维护</li><li>软件无法交付</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>克服软件危机的方法有：构建软件工程知识体系（SWEBoK）、对企业的能力成熟度进行评估、制定软件工程管理标准、使用实践管理工具总结实践经验等等。</p><h2 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h2><p>在软件工程中，软件生命周期是指将软件开发工作在时间维度上分割成不同部分，来提高设计、产品管理和项目管理水平的过程，也称为软件开发过程，其各个阶段实现了软件的需求定义与分析、设计、实现、测试、交付和维护。常见的过程模型有瀑布模型、螺旋模型、敏捷的模型等等。其具体过程有：</p><ul><li>问题定义：确定解决的具体问题是什么。</li><li>可行性研究：从经济、技术、法律等多方面进行可行性分析。</li><li>需求分析：详细分析项目的需求和约束条件。</li><li>开发阶段<ul><li>概要设计：设计整体框架，定义模块和接口。</li><li>详细设计：设计每个模块的具体要求。</li><li>实现：具体的代码实现。</li><li>测试</li></ul></li><li>维护：包含改正性维护、适应性维护、完善性维护、预防性维护等方面。</li></ul><h2 id="SWEBoK的15个知识域"><a href="#SWEBoK的15个知识域" class="headerlink" title="SWEBoK的15个知识域"></a>SWEBoK的15个知识域</h2><ul><li>实践知识域（11个）<ul><li>软件需求：为解决真实问题，软件产品所需的要求和约束。</li><li>软件设计：软件设计包含了需求分析、架构设计、成分设计、接口设计等设计过程以及设计的结果。</li><li>软件构建：结合详细设计、编码、单元测试、集成测试等过程，对软件进行具体的构建和调试。</li><li>软件测试：评估产品质量并通过识别缺陷来改进产品质量。具体包括测试的基础知识、测试技术、人机交互接口测试、测试手段和现状分析等。</li><li>软件维护：提升性能、更新软件和错误修正，分别对应完善性、适应性和改正性维护。</li><li>软件配置管理：是在不同时间点识别系统配置的规则，用于系统地控制配置的改变，以及在整个软件生命周期中维持配置的完整性和可追溯性。</li><li>软件工程管理：涉及计划、协调、测量、报告和控制项目，以确保软件的开发和维护是系统化、规范化和量化的。</li><li>软件工程过程：也叫软件生命周期，涵盖其定义、实施、评估、测量、管理和改进。</li><li>软件工程模型和方法：也叫软件开发模型，覆盖多个软件生命周期阶段。能直观表达软件开发的全过程。</li><li>软件质量：包括软件质量基础知识、质量管理的流程和现实考虑。</li><li>软件工程专业实践：软件工程师必备的软件工程知识、技能和态度，要求工程师做到专业化、负责任和符合道德准则。</li></ul></li><li>教育需求知识域（4个）<ul><li>软件工程经济学：关注的是在软件业务环境中的决策，是商业决策与技术决策的统一。</li><li>计算基础：覆盖了计算机科学的基础知识，例如算法、抽象、编程基础、计算机组成、操作系统和网络等。</li><li>数学基础：数学基础知识，包括线性代数、离散数学、概率论、数论等。</li><li>工程基础：工程化技术的基础知识，例如统计方法、测量方法、仿真与建模等。</li></ul></li></ul><h2 id="简单解释CMMI的五个级别"><a href="#简单解释CMMI的五个级别" class="headerlink" title="简单解释CMMI的五个级别"></a>简单解释CMMI的五个级别</h2><ul><li>Level 1 – Initial：无序，自发生产模式。</li><li>Level 2 – Managed：有活力，项目级管理模式。</li><li>Level 3 – Defined：受控，企业级组织方式。</li><li>Level 4 – Quantitatively Managed：量化，数据化管理模式，精准管理。</li><li>Level 5 – Optimizing：优化，大型企业运行方式，高效率完成大项目开发。</li></ul><img src="/2019/03/03/软件的本质与软件工程科学/Maturity%20levels.png" title="Maturity Levels"><h2 id="用自己语言简述SWEBok或CMMI"><a href="#用自己语言简述SWEBok或CMMI" class="headerlink" title="用自己语言简述SWEBok或CMMI"></a>用自己语言简述SWEBok或CMMI</h2><p>CMMI（Capability Maturity Model Integration），能力成熟度模型集成，是度量一个企业或组织在开发、服务、采购等层面上的成熟度的集成方法，最早主要面向软件工程领域。CMMI的目的在于帮助企业进行能力评估，并协助提升企业的绩效。在不同的成熟度中，CMMI给出了对应的过程区域，这些过程区域有助于企业维持最佳的运作效率，同时有利于企业向更高的成熟度进步。许多企业在进行CMMI评价的过程中，了解了自己所处的位置，也发现了自己发展的潜力所在。</p><p>CMMI存在持续和分阶段两种表现方式。其中，分阶段式中有五个等级，对应的等级有不同的过程区域。CMMI一共有16个核心过程区域，覆盖了企业开发、服务、采购等层面的大部分内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;软件工程的定义&quot;&gt;&lt;a href=&quot;#软件工程的定义&quot; class=&quot;headerlink&quot; title=&quot;软件工程的定义&quot;&gt;&lt;/a&gt;软件工程的定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Software engineering is “(1) the appl
      
    
    </summary>
    
    
      <category term="SE" scheme="https://xungerrrr.github.io/tags/SE/"/>
    
  </entry>
  
  <entry>
    <title>Git日常使用总结</title>
    <link href="https://xungerrrr.github.io/2018/09/16/Git%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://xungerrrr.github.io/2018/09/16/Git日常使用总结/</id>
    <published>2018-09-16T05:44:10.000Z</published>
    <updated>2019-03-14T05:49:43.263Z</updated>
    
    <content type="html"><![CDATA[<h3 id="取得项目的-Git-仓库"><a href="#取得项目的-Git-仓库" class="headerlink" title="取得项目的 Git 仓库"></a>取得项目的 Git 仓库</h3><ul><li><p>在工作目录中初始化新仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></li><li><p>从现有仓库克隆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone &lt;url&gt;</span><br></pre></td></tr></table></figure><p>也可以自定义项目目录名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone &lt;url&gt; &lt;name&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="将更新记录到仓库"><a href="#将更新记录到仓库" class="headerlink" title="将更新记录到仓库"></a>将更新记录到仓库</h3><ul><li><p>检查当前文件状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><p>查看尚未暂存的文件更新了哪些部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure><p>加上-cached选项，查看已经暂存起来的文件和上次提交时的快照之间的差异：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached</span><br></pre></td></tr></table></figure></li><li><p>跟踪新文件和暂存已修改文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add &lt;file&gt;</span><br></pre></td></tr></table></figure></li><li><p>忽略某些文件</p><p>创建.gitignore文件。.gitignore文件的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line"># 忽略所有 .a 结尾的文件</span><br><span class="line">*.a</span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!lib.a</span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"># 忽略 build/ 目录下的所有文件</span><br><span class="line">build/</span><br><span class="line"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># 忽略 doc/ 目录下所有扩展名为 txt 的文件</span><br><span class="line">doc/**/*.txt</span><br></pre></td></tr></table></figure></li><li><p>提交更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;&lt;message&gt;&quot;</span><br></pre></td></tr></table></figure><p>加上-a选项，跳过使用暂存区域：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -m &quot;&lt;message&gt;&quot;</span><br></pre></td></tr></table></figure></li><li><p>移除文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm &lt;file&gt;</span><br></pre></td></tr></table></figure><p>加上–cached选项，移除跟踪但不删除文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached &lt;file&gt;</span><br></pre></td></tr></table></figure></li><li><p>移动文件（重命名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv &lt;file_from&gt; &lt;file_to&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-p                # 按补丁格式显示每个更新之间的差异。</span><br><span class="line">--word-diff       # 按 word diff 格式显示差异。</span><br><span class="line">--stat            # 显示每次更新的文件修改统计信息。</span><br><span class="line">--shortstat       # 只显示 --stat 中最后的行数修改添加移除统计。</span><br><span class="line">--name-only       # 仅在提交信息后显示已修改的文件清单。</span><br><span class="line">--name-status     # 显示新增、修改、删除的文件清单。</span><br><span class="line">--abbrev-commit   # 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</span><br><span class="line">--relative-date   # 使用较短的相对时间显示（比如，“2 weeks ago”）。</span><br><span class="line">--graph           # 显示 ASCII 图形表示的分支合并历史。</span><br><span class="line">--pretty          # 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</span><br><span class="line">--oneline         # --pretty=oneline --abbrev-commit 的简化用法。</span><br><span class="line">-(n)              # 仅显示最近的 n 条提交</span><br><span class="line">--since, --after  # 仅显示指定时间之后的提交。</span><br><span class="line">--until, --before # 仅显示指定时间之前的提交。</span><br><span class="line">--author          # 仅显示指定作者相关的提交。</span><br><span class="line">--committer       # 仅显示指定提交者相关的提交。</span><br></pre></td></tr></table></figure><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><ul><li><p>重新提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure></li><li><p>取消已经暂存的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure></li><li><p>取消对文件的修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul><li><p>查看当前的远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br></pre></td></tr></table></figure><p>加上-v选项，显示对应的克隆地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure></li><li><p>添加远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &lt;shortname&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></li><li><p>从远程仓库抓取数据</p><p>不合并分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch &lt;remote-name&gt;</span><br></pre></td></tr></table></figure><p>合并分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;remote-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>推送数据到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看远程仓库的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show &lt;remote-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>远程仓库的删除和重命名</p><p>重命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename &lt;old-name&gt; &lt;new-name&gt;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm &lt;remote-name&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;取得项目的-Git-仓库&quot;&gt;&lt;a href=&quot;#取得项目的-Git-仓库&quot; class=&quot;headerlink&quot; title=&quot;取得项目的 Git 仓库&quot;&gt;&lt;/a&gt;取得项目的 Git 仓库&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在工作目录中初始化新仓库&lt;/p&gt;
&lt;fig
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Learning</title>
    <link href="https://xungerrrr.github.io/2018/09/10/Android-Learning/"/>
    <id>https://xungerrrr.github.io/2018/09/10/Android-Learning/</id>
    <published>2018-09-10T06:16:49.000Z</published>
    <updated>2019-03-14T06:31:09.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android开发项目汇总"><a href="#Android开发项目汇总" class="headerlink" title="Android开发项目汇总"></a>Android开发项目汇总</h1><blockquote><p>这是中山大学2018秋季学期「手机平台应用开发」的项目汇总。</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="Project-1"><a href="#Project-1" class="headerlink" title="Project 1"></a>Project 1</h3><ul><li><a href="https://github.com/Xungerrrr/SYSU-Android/tree/master/Project%201" target="_blank" rel="noopener">个人项目 1 - 中山大学智慧健康服务平台应用开发</a></li></ul><h3 id="Project-2"><a href="#Project-2" class="headerlink" title="Project 2"></a>Project 2</h3><ul><li><a href="https://github.com/Xungerrrr/SYSU-Android/tree/master/Project%202" target="_blank" rel="noopener">个人项目 2 - 中山大学智慧健康服务平台应用开发</a></li></ul><h3 id="Project-3"><a href="#Project-3" class="headerlink" title="Project 3"></a>Project 3</h3><ul><li><a href="https://github.com/Xungerrrr/SYSU-Android/tree/master/Project%203" target="_blank" rel="noopener">个人项目 3 - 数据存储应用开发</a></li></ul><h3 id="Project-4"><a href="#Project-4" class="headerlink" title="Project 4"></a>Project 4</h3><ul><li><a href="https://github.com/Xungerrrr/SYSU-Android/tree/master/Project%204" target="_blank" rel="noopener">个人项目 4 - 简单音乐播放器应用开发</a></li></ul><h3 id="Project-5"><a href="#Project-5" class="headerlink" title="Project 5"></a>Project 5</h3><ul><li><a href="https://github.com/Xungerrrr/SYSU-Android/tree/master/Project%205" target="_blank" rel="noopener">个人项目 5 - 网络与Web服务</a></li></ul><h3 id="Midterm-Project"><a href="#Midterm-Project" class="headerlink" title="Midterm Project"></a>Midterm Project</h3><ul><li><a href="https://github.com/Xungerrrr/SYSU-Android/tree/master/Midterm" target="_blank" rel="noopener">期中项目 - 王者荣耀英雄大全</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android开发项目汇总&quot;&gt;&lt;a href=&quot;#Android开发项目汇总&quot; class=&quot;headerlink&quot; title=&quot;Android开发项目汇总&quot;&gt;&lt;/a&gt;Android开发项目汇总&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这是中山大学2018秋季学
      
    
    </summary>
    
    
      <category term="Android" scheme="https://xungerrrr.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
