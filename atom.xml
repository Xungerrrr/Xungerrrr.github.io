<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xungerrrr&#39;s Site</title>
  
  <subtitle>Every Little Counts.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xungerrrr.github.io/"/>
  <updated>2019-05-29T11:13:06.728Z</updated>
  <id>https://xungerrrr.github.io/</id>
  
  <author>
    <name>Xunyan Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bezier Curve</title>
    <link href="https://xungerrrr.github.io/2019/05/29/Bezier-Curve/"/>
    <id>https://xungerrrr.github.io/2019/05/29/Bezier-Curve/</id>
    <published>2019-05-29T09:51:34.000Z</published>
    <updated>2019-05-29T11:13:06.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><h3 id="捕捉指针的移动"><a href="#捕捉指针的移动" class="headerlink" title="捕捉指针的移动"></a>捕捉指针的移动</h3><p>定义一个回调函数mouse_callback，记录指针的位置信息。用glfwSetCursorPosCallback绑定回调函数，就能在鼠标移动时，捕捉到指针的实时坐标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span> </span>&#123;</span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetCursorPosCallback(window, mouse_callback);</span><br></pre></td></tr></table></figure><h3 id="捕捉鼠标的点击"><a href="#捕捉鼠标的点击" class="headerlink" title="捕捉鼠标的点击"></a>捕捉鼠标的点击</h3><p>定义一个回调函数mouse_button_callback，处理鼠标的点击事件。首先，要将指针坐标转换成OpenGL的标准坐标，范围是[-1, 1]。然后，根据按键的不同调用不同的函数。点击左键时，调用addPoint添加一个控制点；点击右键时，调用deletePoint删除最后一个控制点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_button_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> button, <span class="keyword">int</span> action, <span class="keyword">int</span> mods)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == GLFW_PRESS) &#123;</span><br><span class="line">        <span class="keyword">float</span> clickX = (lastX - windowWidth / <span class="number">2</span>) / (windowWidth / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">float</span> clickY = -(lastY - windowHeight / <span class="number">2</span>) / (windowHeight / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">switch</span> (button) &#123;</span><br><span class="line">            <span class="keyword">case</span> GLFW_MOUSE_BUTTON_LEFT:</span><br><span class="line">                addPoint(clickX, clickY);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GLFW_MOUSE_BUTTON_RIGHT:</span><br><span class="line">                deletePoint();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用glfwSetMouseButtonCallback绑定回调函数，就能捕获鼠标点击事件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetMouseButtonCallback(window, mouse_button_callback);</span><br></pre></td></tr></table></figure><h2 id="控制点的变化"><a href="#控制点的变化" class="headerlink" title="控制点的变化"></a>控制点的变化</h2><h3 id="控制点的增加"><a href="#控制点的增加" class="headerlink" title="控制点的增加"></a>控制点的增加</h3><p>要增加控制点，先按照顶点数组的格式创建一个包含坐标信息的vector，然后将这个vector插入到控制点vector中。添加完之后，调用calculateBezier函数重新计算bezier曲线，做到实时更新曲线。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addPoint</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; newPoint = &#123; x, y, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    controlPoints.insert(controlPoints.end(), newPoint.begin(), newPoint.end());</span><br><span class="line">    calculateBezier();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制点的删除"><a href="#控制点的删除" class="headerlink" title="控制点的删除"></a>控制点的删除</h3><p>根据定义的顶点数组格式，要删除最后一个控制点，只需要删除控制点vector最后6个元素即可。删除之后，调用calculateBezier函数重新计算bezier曲线，做到实时更新曲线。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletePoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!controlPoints.empty()) &#123;</span><br><span class="line">        controlPoints.erase(controlPoints.begin() + controlPoints.size() - <span class="number">6</span>, controlPoints.end());</span><br><span class="line">        calculateBezier();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bezier曲线的计算"><a href="#Bezier曲线的计算" class="headerlink" title="Bezier曲线的计算"></a>Bezier曲线的计算</h2><p>首先，要清空原有的bezier曲线。然后，根据Bezier曲线的公式计算即可，其中bernstein函数是伯恩斯坦基函数。t的增加步长设为0.0001。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculateBezier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bezierPoints.clear();</span><br><span class="line">    <span class="keyword">int</span> n = controlPoints.size() / <span class="number">6</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">float</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t += <span class="number">0.0001</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">float</span> b = bernstein(i, n, t);</span><br><span class="line">                x += controlPoints[i * <span class="number">6</span>] * b;</span><br><span class="line">                y += controlPoints[i * <span class="number">6</span> + <span class="number">1</span>] * b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; newPoint = &#123; x, y, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">            bezierPoints.insert(bezierPoints.end(), newPoint.begin(), newPoint.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">bernstein</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">float</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        result *= ((<span class="keyword">float</span>)(n - j) / (<span class="keyword">float</span>)(i - j));</span><br><span class="line">    &#125;</span><br><span class="line">    result *= <span class="built_in">pow</span>(t, i) * <span class="built_in">pow</span>(<span class="number">1</span> - t, n - i);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><h3 id="显示控制点"><a href="#显示控制点" class="headerlink" title="显示控制点"></a>显示控制点</h3><p>用GL_POINTS图元，绘制控制点数组中的所有点，用GL_LINE_STRIP图元绘制相邻控制点的连线。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!controlPoints.empty()) &#123;</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, windowWidth, windowHeight);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;pointVBO);</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;pointVAO);</span><br><span class="line">    glBindVertexArray(pointVAO);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, pointVBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * controlPoints.size(), &amp;controlPoints[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">    glPointSize(<span class="number">10</span>);</span><br><span class="line">    glDrawArrays(GL_POINTS, <span class="number">0</span>, controlPoints.size() / <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; controlPoints.size() / <span class="number">6</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        glDrawArrays(GL_LINE_STRIP, i, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显示Bezier曲线"><a href="#显示Bezier曲线" class="headerlink" title="显示Bezier曲线"></a>显示Bezier曲线</h3><p>用GL_POINTS图元，绘制Bezier曲线数组里面的所有点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!bezierPoints.empty()) &#123;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;bezierVBO);</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;bezierVAO);</span><br><span class="line">    glBindVertexArray(bezierVAO);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, bezierVBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(<span class="keyword">float</span>)* bezierPoints.size(), &amp;bezierPoints[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">    glPointSize(<span class="number">1</span>);</span><br><span class="line">    glDrawArrays(GL_POINTS, <span class="number">0</span>, bezierPoints.size() / <span class="number">6</span>);</span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2019/05/29/Bezier-Curve/result.gif" title="result"><h2 id="Bonus：动态呈现Bezier曲线的生成过程"><a href="#Bonus：动态呈现Bezier曲线的生成过程" class="headerlink" title="Bonus：动态呈现Bezier曲线的生成过程"></a>Bonus：动态呈现Bezier曲线的生成过程</h2><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>根据Bezier曲线的原理，每一层的辅助线由该层相邻的辅助点连接而成，每一层的辅助点是由上一层的每一条辅助线取比例t所得，最顶层的辅助点和辅助线是之前画出的控制点和控制线，最底层的辅助点就是比例t对应的Bezier曲线上的点。根据这个原理和t的值，可以通过两层循环算出所有的辅助点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getVisualizePoints</span><span class="params">(<span class="keyword">float</span> t)</span> </span>&#123;</span><br><span class="line">    visualizePoints = <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;(controlPoints);</span><br><span class="line">    <span class="keyword">int</span> n = controlPoints.size() / <span class="number">6</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">float</span> x = (<span class="number">1</span> - t) * visualizePoints[(j + offset) * <span class="number">6</span>] + t * visualizePoints[(j + <span class="number">1</span> + offset) * <span class="number">6</span>];</span><br><span class="line">            <span class="keyword">float</span> y = (<span class="number">1</span> - t) * visualizePoints[(j + offset) * <span class="number">6</span> + <span class="number">1</span>] + t * visualizePoints[(j + <span class="number">1</span> + offset) * <span class="number">6</span> + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; newPoint = &#123; x, y, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">            visualizePoints.insert(visualizePoints.end(), newPoint.begin(), newPoint.end());</span><br><span class="line">        &#125;</span><br><span class="line">        offset += (n - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显示-1"><a href="#显示-1" class="headerlink" title="显示"></a>显示</h3><p>在渲染循环中，通过时间来控制t的值，使t从0到1循环变化。然后，调用getVisualizePoints获得所有的辅助点。最后，用GL_LINE_STRIP图元绘制所有的辅助线，用GL_POINTS图元绘制所有的辅助点。绘制过程与控制点的绘制类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> t = (<span class="keyword">float</span>)(time - (<span class="keyword">int</span>)time / <span class="number">10</span> * <span class="number">10</span>) / <span class="number">10</span>;</span><br><span class="line">getVisualizePoints(t);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!visualizePoints.empty()) &#123;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;visualizeVBO);</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;visualizeVAO);</span><br><span class="line">    glBindVertexArray(visualizeVAO);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, visualizeVBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(<span class="keyword">float</span>)* visualizePoints.size(), &amp;visualizePoints[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n = controlPoints.size() / <span class="number">6</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">float</span> offset = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            glDrawArrays(GL_LINE_STRIP, j + offset, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        offset += (n - i);</span><br><span class="line">    &#125;</span><br><span class="line">    glPointSize(<span class="number">5</span>);</span><br><span class="line">    glDrawArrays(GL_POINTS, <span class="number">0</span>, visualizePoints.size() / <span class="number">6</span>);</span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2019/05/29/Bezier-Curve/bonus.gif" title="bonus">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;鼠标事件&quot;&gt;&lt;a href=&quot;#鼠标事件&quot; class=&quot;headerlink&quot; title=&quot;鼠标事件&quot;&gt;&lt;/a&gt;鼠标事件&lt;/h2&gt;&lt;h3 id=&quot;捕捉指针的移动&quot;&gt;&lt;a href=&quot;#捕捉指针的移动&quot; class=&quot;headerlink&quot; title=&quot;捕捉指
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Shadow Mapping</title>
    <link href="https://xungerrrr.github.io/2019/05/13/Shadow-Mapping/"/>
    <id>https://xungerrrr.github.io/2019/05/13/Shadow-Mapping/</id>
    <published>2019-05-13T06:27:28.000Z</published>
    <updated>2019-05-13T15:38:18.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shadow-Mapping阴影渲染"><a href="#Shadow-Mapping阴影渲染" class="headerlink" title="Shadow Mapping阴影渲染"></a>Shadow Mapping阴影渲染</h2><p>Shadow Mapping阴影渲染分为两个步骤：</p><ol><li>以光源视角渲染场景，得到深度图（Shadow Map)，存储为纹理；</li><li>以观察视角再次渲染场景，将每个点的深度值和Shadow Map中的深度值进行比较，判断点是否在阴影内。</li></ol><h3 id="获取Shadow-Map"><a href="#获取Shadow-Map" class="headerlink" title="获取Shadow Map"></a>获取Shadow Map</h3><h4 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h4><p>首先来设计着色器。因为要在光源视角渲染场景，所以顶点着色器只需要将坐标变换到光源视角空间并输出即可。使用一个变换矩阵即可完成变换。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> lightSpaceMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = lightSpaceMatrix * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于片段着色器，因为只需要获取深度信息而不需要颜色信息，所以可以使用一个空的片段着色器。</p><h4 id="存储Shadow-Map"><a href="#存储Shadow-Map" class="headerlink" title="存储Shadow Map"></a>存储Shadow Map</h4><p>为了获得Shadow Map，我们需要将渲染的深度信息存到一个2D纹理中。需要借助帧缓冲对象和纹理来实现。</p><p>首先，创建一个2D纹理。因为我们只需要存储深度值，所以将纹理格式设置为GL_DEPTH_COMPONENT。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> depthMap;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SHADOW_WIDTH = <span class="number">4096</span>, SHADOW_HEIGHT = <span class="number">4096</span>;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;depthMap);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, depthMap);</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT,</span><br><span class="line">    SHADOW_WIDTH, SHADOW_HEIGHT, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br></pre></td></tr></table></figure><p>然后，创建一个帧缓冲对象，将纹理绑定为帧缓冲的深度缓冲。因为不需要颜色缓冲，所以通过调用glDrawBuffer(GL_NONE)和glReadBuffer(GL_NONE)说明不用颜色进行渲染。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> depthMapFBO;</span><br><span class="line">glGenFramebuffers(<span class="number">1</span>, &amp;depthMapFBO);</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line">glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, <span class="number">0</span>);</span><br><span class="line">glDrawBuffer(GL_NONE);</span><br><span class="line">glReadBuffer(GL_NONE);</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="光源空间变换"><a href="#光源空间变换" class="headerlink" title="光源空间变换"></a>光源空间变换</h4><p>在顶点着色器中，用到了一个变换矩阵，将世界坐标变换到光源视角。变换矩阵由投影矩阵和视角矩阵相乘得到。</p><p>对于平行光，可以采用正交投影，通过glm::ortho定义矩阵。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> near_plane = <span class="number">1.0f</span>, far_plane = <span class="number">100.0f</span>;</span><br><span class="line">glm::mat4 lightProjection = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">lightProjection = glm::ortho(<span class="number">-10.0f</span>, <span class="number">10.0f</span>, <span class="number">-10.0f</span>, <span class="number">10.0f</span>, near_plane, far_plane);</span><br></pre></td></tr></table></figure><p>通过glm::lookAt函数，创建观察矩阵，从光源位置看向坐标原点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::<span class="function">vec3 <span class="title">lightPos</span><span class="params">(<span class="number">-3.0f</span>, <span class="number">4.0f</span>, <span class="number">-1.0f</span>)</span></span>;</span><br><span class="line">glm::mat4 lightView = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">lightView = glm::lookAt(lightPos, glm::vec3(<span class="number">0.0f</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>));</span><br></pre></td></tr></table></figure><p>相乘得到变换矩阵。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 lightSpaceMatrix = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">lightSpaceMatrix = lightProjection * lightView;</span><br></pre></td></tr></table></figure><h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>通过glBindFramebuffer绑定帧缓冲，在函数renderScene中渲染场景。渲染完成后深度信息就存储到了纹理中，得到Shadow Map。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">depthShader.use();</span><br><span class="line">depthShader.setMat4(<span class="string">"lightSpaceMatrix"</span>, lightSpaceMatrix);</span><br><span class="line"></span><br><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line">glClear(GL_DEPTH_BUFFER_BIT);</span><br><span class="line">renderScene(depthShader, planeVAO, cubeVAO);</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="阴影计算（Shadow-Mapping算法）"><a href="#阴影计算（Shadow-Mapping算法）" class="headerlink" title="阴影计算（Shadow Mapping算法）"></a>阴影计算（Shadow Mapping算法）</h3><p>下一步，需要从观察视角进行渲染，从光源视角对像素深度和Shadow Map中对应位置的值进行比较。如果深度大于Shadow Map的值，说明该点在其他物体后，处在阴影内。反之则不在阴影内。</p><h4 id="着色器-1"><a href="#着色器-1" class="headerlink" title="着色器"></a>着色器</h4><p>顶点着色器与实现Phong光照模型的顶点着色器相似。不过，因为要比较深度值判断片段是否在阴影内，所以顶点着色器还需要输出片段变换到光源视角空间的坐标。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs_out.FragPosLightSpace = lightSpaceMatrix * <span class="type">vec4</span>(vs_out.FragPos, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>片段着色器与实现Phong光照模型的片段着色器相似。不过，片段着色器还需要计算片段是否在阴影内。</p><p>首先，需要将光源视角空间的坐标进行标准化，变换到[0, 1]之间。z坐标即是当前的深度。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"><span class="type">float</span> currentDepth = projCoords.z;</span><br></pre></td></tr></table></figure><p>然后，获取Shadow Map中的深度信息。比较当前深度和最近深度，判断片段是否在阴影内。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> closestDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy).r; </span><br><span class="line"><span class="type">float</span> shadow = currentDepth &gt; closestDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><p>如果在阴影内，则只显示环境光。否则按照Phong光照模型进行渲染。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> lighting = (ambient + (<span class="number">1.0</span> - shadow) * (diffuse + specular)) * color;</span><br></pre></td></tr></table></figure><h4 id="渲染-1"><a href="#渲染-1" class="headerlink" title="渲染"></a>渲染</h4><p>渲染的方法与之前的类似。在渲染前，需要绑定两个纹理。一个是物体的纹理，这里使用了木地板纹理。另一个是第一步得到的Shadow Map，用于计算阴影。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, woodTexture);</span><br><span class="line">glActiveTexture(GL_TEXTURE1);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, depthMap);</span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><img src="/2019/05/13/Shadow-Mapping/1.png" title="pic1"><h2 id="增加光源在透视投影下的Shadow-Mapping"><a href="#增加光源在透视投影下的Shadow-Mapping" class="headerlink" title="增加光源在透视投影下的Shadow Mapping"></a>增加光源在透视投影下的Shadow Mapping</h2><p>通过ImGui选择投影方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ImGui::Begin(<span class="string">"Projection Type"</span>);</span><br><span class="line">ImGui::BeginGroup();</span><br><span class="line">ImGui::RadioButton(<span class="string">"Orthogonal"</span>, &amp;projectionType, <span class="number">1</span>);</span><br><span class="line">ImGui::RadioButton(<span class="string">"Perspective"</span>, &amp;projectionType, <span class="number">2</span>);</span><br><span class="line">ImGui::EndGroup();</span><br><span class="line">ImGui::End();</span><br></pre></td></tr></table></figure><p>根据投影方式创建不同的投影矩阵。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (projectionType == <span class="number">1</span>)</span><br><span class="line">    lightProjection = glm::ortho(<span class="number">-10.0f</span>, <span class="number">10.0f</span>, <span class="number">-10.0f</span>, <span class="number">10.0f</span>, near_plane, far_plane);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (projectionType == <span class="number">2</span>)</span><br><span class="line">    lightProjection = glm::perspective(glm::radians(<span class="number">120.0f</span>), <span class="number">1.0f</span>, near_plane, far_plane);</span><br></pre></td></tr></table></figure><p>让光源动起来，使效果明显。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lightPos.z = <span class="built_in">sin</span>(time) * <span class="number">10.0f</span>;</span><br><span class="line">lightPos.y = <span class="built_in">sin</span>(time/ <span class="number">2.0f</span>) * <span class="number">2</span> + <span class="number">4.0f</span>;</span><br></pre></td></tr></table></figure><h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p>正交投影：</p><img src="/2019/05/13/Shadow-Mapping/2.png" title="pic2"><p>透视投影：</p><img src="/2019/05/13/Shadow-Mapping/3.png" title="pic3"><h2 id="优化阴影"><a href="#优化阴影" class="headerlink" title="优化阴影"></a>优化阴影</h2><h3 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h3><p>通过加入偏移量，避免了由于Shadow Map分辨率不足导致的阴影失真。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="number">0.005</span>;</span><br><span class="line"><span class="type">float</span> shadow = currentDepth - bias  &gt; closestDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><p>优化前：</p><img src="/2019/05/13/Shadow-Mapping/4.png" title="pic4"><p>优化后：</p><img src="/2019/05/13/Shadow-Mapping/5.png" title="pic5"><h3 id="悬浮"><a href="#悬浮" class="headerlink" title="悬浮"></a>悬浮</h3><p>在渲染Shadow Map的时候，通过正面剔除，减轻了悬浮的现象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glCullFace(GL_FRONT);</span><br><span class="line">renderScene(depthShader, planeVAO, cubeVAO);</span><br><span class="line">glCullFace(GL_BACK);</span><br></pre></td></tr></table></figure><h3 id="锯齿"><a href="#锯齿" class="headerlink" title="锯齿"></a>锯齿</h3><p>通过使用5*5的模板进行均值滤波，减轻了阴影的锯齿化现象。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> texelSize = <span class="number">1.0</span> / <span class="built_in">textureSize</span>(shadowMap, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-2</span>; x &lt;= <span class="number">2</span>; ++x) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-2</span>; y &lt;= <span class="number">2</span>; ++y) &#123;</span><br><span class="line">        <span class="type">float</span> pcfDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy + <span class="type">vec2</span>(x, y) * texelSize).r;</span><br><span class="line">        shadow += currentDepth - bias &gt; pcfDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">shadow /= <span class="number">25.0</span>;</span><br></pre></td></tr></table></figure><p>优化前：</p><img src="/2019/05/13/Shadow-Mapping/6.png" title="pic6"><p>优化后：</p><img src="/2019/05/13/Shadow-Mapping/7.png" title="pic7">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Shadow-Mapping阴影渲染&quot;&gt;&lt;a href=&quot;#Shadow-Mapping阴影渲染&quot; class=&quot;headerlink&quot; title=&quot;Shadow Mapping阴影渲染&quot;&gt;&lt;/a&gt;Shadow Mapping阴影渲染&lt;/h2&gt;&lt;p&gt;Shadow
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Lights and Shading</title>
    <link href="https://xungerrrr.github.io/2019/05/07/Lights-and-Shading/"/>
    <id>https://xungerrrr.github.io/2019/05/07/Lights-and-Shading/</id>
    <published>2019-05-07T12:47:38.000Z</published>
    <updated>2019-05-07T14:14:34.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现Phong光照模型"><a href="#实现Phong光照模型" class="headerlink" title="实现Phong光照模型"></a>实现Phong光照模型</h2><h3 id="Phong-Shading"><a href="#Phong-Shading" class="headerlink" title="Phong Shading"></a>Phong Shading</h3><p>Phong Shading在每个像素根据法向量计算光照，而每个像素的法向量由顶点的法向量插值求得。因此，要实现Phong Shading，顶点着色器需要输出顶点的位置和法向量。输出的位置由世界坐标表示，所以要用model矩阵进行变换后输出。为避免缩放后法向量不垂直于平面，要用法线矩阵对法向量进行变换后输出。顶点着色器的代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> Normal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragPos = <span class="type">vec3</span>(model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>));</span><br><span class="line">    Normal = <span class="type">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(model))) * aNormal;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Phong Shading在片段着色器根据法向量计算光照，要在片段着色器中计算环境光、漫反射和镜面反射三种光照效果。环境光强度仅由全局变量ambientStrength决定。漫反射光的强度由全局变量diffuseStrength以及光线与法向量的夹角决定。夹角的cos值，可以通过法向量的单位向量与入射点到光源方向的单位向量的点乘求得，且cos值不小于0。镜面反射光强度由全局变量specularStrength以及入射点到摄像机方向与全反射光方向的夹角决定，夹角的cos值也是通过单位向量的点乘求得。三种光照强度相加后，与物体颜色和光照颜色相乘，得到显示的颜色。实现的代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> objectColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> ambientStrength;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> diffuseStrength;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> specularStrength;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    <span class="type">vec3</span> ambient = ambientStrength * lightColor;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// diffuse </span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">vec3</span> diffuse = diffuseStrength * diff * lightColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);</span><br><span class="line">    <span class="type">vec3</span> specular = specularStrength * spec * lightColor;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> result = (ambient + diffuse + specular) * objectColor;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Gouraud-Shading"><a href="#Gouraud-Shading" class="headerlink" title="Gouraud Shading"></a>Gouraud Shading</h3><p>与Phong Shadings不同，Gouraud Shading在顶点处计算光照，其他像素的颜色由顶点颜色插值得到，所以光照的计算放在顶点着色器中。具体的计算方法与Phong Shading类似。顶点着色器最终输出光照的颜色。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> LightingColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> ambientStrength;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> diffuseStrength;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> specularStrength;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> Position = <span class="type">vec3</span>(model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>));</span><br><span class="line">    <span class="type">vec3</span> Normal = <span class="type">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(model))) * aNormal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    <span class="type">vec3</span> ambient = ambientStrength * lightColor;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// diffuse </span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - Position);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">vec3</span> diffuse = diffuseStrength * diff * lightColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - Position);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);</span><br><span class="line">    <span class="type">vec3</span> specular = specularStrength * spec * lightColor;</span><br><span class="line"></span><br><span class="line">    LightingColor = ambient + diffuse + specular;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>光线颜色输入到片段着色器中，与物体颜色相乘，得到显示的颜色：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> LightingColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> objectColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(LightingColor * objectColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用GUI，使参数可调节，效果实时更改"><a href="#使用GUI，使参数可调节，效果实时更改" class="headerlink" title="使用GUI，使参数可调节，效果实时更改"></a>使用GUI，使参数可调节，效果实时更改</h2><h3 id="Shading切换"><a href="#Shading切换" class="headerlink" title="Shading切换"></a>Shading切换</h3><p>创建两个shader对象，使用GUI进行切换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Shader <span class="title">phongLightingShader</span><span class="params">(<span class="string">"phong.vs"</span>, <span class="string">"phong.fs"</span>)</span></span>;</span><br><span class="line"><span class="function">Shader <span class="title">gouraudLightingShader</span><span class="params">(<span class="string">"gouraud.vs"</span>, <span class="string">"gouraud.fs"</span>)</span></span>;</span><br><span class="line">Shader *lightingShader = &amp;phongLightingShader;</span><br></pre></td></tr></table></figure><p>在渲染循环中切换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ImGui::Begin(<span class="string">"Shading Type"</span>);</span><br><span class="line">ImGui::BeginGroup();</span><br><span class="line">ImGui::RadioButton(<span class="string">"Phong"</span>, &amp;shadingType, <span class="number">1</span>);</span><br><span class="line">ImGui::RadioButton(<span class="string">"Gouraud"</span>, &amp;shadingType, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (shadingType == <span class="number">1</span>) &#123;</span><br><span class="line">    lightingShader = &amp;phongLightingShader;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (shadingType == <span class="number">2</span>) &#123;</span><br><span class="line">    lightingShader = &amp;gouraudLightingShader;</span><br><span class="line">&#125;</span><br><span class="line">ImGui::EndGroup();</span><br><span class="line">ImGui::End();</span><br></pre></td></tr></table></figure><h3 id="参数可调节"><a href="#参数可调节" class="headerlink" title="参数可调节"></a>参数可调节</h3><p>用SliderFloat调节三个参数，然后设置全局变量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ImGui::Begin(<span class="string">"Light Strength"</span>);</span><br><span class="line">ImGui::SliderFloat(<span class="string">"Ambient Strength"</span>, &amp;ambientStrength, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">ImGui::SliderFloat(<span class="string">"Diffuse Strength"</span>, &amp;diffuseStrength, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">ImGui::SliderFloat(<span class="string">"Specular Strength"</span>, &amp;specularStrength, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">ImGui::End();</span><br><span class="line"></span><br><span class="line">lightingShader-&gt;setFloat(<span class="string">"ambientStrength"</span>, ambientStrength);</span><br><span class="line">lightingShader-&gt;setFloat(<span class="string">"diffuseStrength"</span>, diffuseStrength);</span><br><span class="line">lightingShader-&gt;setFloat(<span class="string">"specularStrength"</span>, specularStrength);</span><br></pre></td></tr></table></figure></p><h2 id="Bonus：移动光源"><a href="#Bonus：移动光源" class="headerlink" title="Bonus：移动光源"></a>Bonus：移动光源</h2><p>用三角函数可以实现光源在x方向的来回移动：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> time = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line"><span class="keyword">if</span> (ImGui::MenuItem(<span class="string">"move"</span>, <span class="literal">NULL</span>, &amp;move)) &#123;</span><br><span class="line">    moveTime = time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (move)</span><br><span class="line">    lightPos.x = <span class="built_in">sin</span>(time - moveTime + <span class="number">3.14</span> / <span class="number">6</span>) * <span class="number">2.0f</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    lightPos.x = <span class="number">1.0f</span>;</span><br><span class="line">lightingShader-&gt;setVec3(<span class="string">"lightPos"</span>, lightPos);</span><br></pre></td></tr></table></figure><h2 id="渲染效果"><a href="#渲染效果" class="headerlink" title="渲染效果"></a>渲染效果</h2><h3 id="Phong-Shading-1"><a href="#Phong-Shading-1" class="headerlink" title="Phong Shading"></a>Phong Shading</h3><img src="/2019/05/07/Lights-and-Shading/1.png" title="Phong"><h3 id="Gouraud-Shading-1"><a href="#Gouraud-Shading-1" class="headerlink" title="Gouraud Shading"></a>Gouraud Shading</h3><img src="/2019/05/07/Lights-and-Shading/2.png" title="Gouraud"><h3 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h3><img src="/2019/05/07/Lights-and-Shading/demo1.gif" title="Demo1"><h3 id="运动光源"><a href="#运动光源" class="headerlink" title="运动光源"></a>运动光源</h3><img src="/2019/05/07/Lights-and-Shading/demo2.gif" title="Demo1">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实现Phong光照模型&quot;&gt;&lt;a href=&quot;#实现Phong光照模型&quot; class=&quot;headerlink&quot; title=&quot;实现Phong光照模型&quot;&gt;&lt;/a&gt;实现Phong光照模型&lt;/h2&gt;&lt;h3 id=&quot;Phong-Shading&quot;&gt;&lt;a href=&quot;#Phon
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Camera</title>
    <link href="https://xungerrrr.github.io/2019/04/17/Camera/"/>
    <id>https://xungerrrr.github.io/2019/04/17/Camera/</id>
    <published>2019-04-17T06:24:07.000Z</published>
    <updated>2019-04-17T14:30:48.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="投影（Projection"><a href="#投影（Projection" class="headerlink" title="投影（Projection)"></a>投影（Projection)</h1><h2 id="把上次作业绘制的cube放置在-1-5-0-5-1-5-位置，要求6个面颜色不一致"><a href="#把上次作业绘制的cube放置在-1-5-0-5-1-5-位置，要求6个面颜色不一致" class="headerlink" title="把上次作业绘制的cube放置在(-1.5, 0.5, -1.5)位置，要求6个面颜色不一致"></a>把上次作业绘制的cube放置在(-1.5, 0.5, -1.5)位置，要求6个面颜色不一致</h2><p>因为放置在(-1.5, 0.5, -1.5)时透视投影效果不明显，我将立方体放置在了(-3.5, 2.5, -1.5)位置。用glm::translate即可实现平移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = glm::translate(model, glm::vec3(<span class="number">-3.5</span>, <span class="number">2.5f</span>, <span class="number">-1.5f</span>));</span><br></pre></td></tr></table></figure><h2 id="正交投影（orthographic-projection-：实现正交投影，使用多组（left-right-bottom-top-near-far）参数，比较结果差异"><a href="#正交投影（orthographic-projection-：实现正交投影，使用多组（left-right-bottom-top-near-far）参数，比较结果差异" class="headerlink" title="正交投影（orthographic projection)：实现正交投影，使用多组（left, right, bottom, top, near, far）参数，比较结果差异"></a>正交投影（orthographic projection)：实现正交投影，使用多组（left, right, bottom, top, near, far）参数，比较结果差异</h2><p>先设计一个GUI交互界面，可以选择投影类型，并输入不同的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> left = <span class="number">-12.0f</span>, right = <span class="number">12.0f</span>, bottom = <span class="number">-9.0f</span>, top = <span class="number">9.0f</span>, nearDist = <span class="number">0.1f</span>, farDist = <span class="number">100.0f</span>;</span><br><span class="line">ImGui::Begin(<span class="string">"Projection Type"</span>);</span><br><span class="line">ImGui::BeginGroup();</span><br><span class="line">ImGui::RadioButton(<span class="string">"Orthographic"</span>, &amp;projectionType, <span class="number">1</span>);</span><br><span class="line">ImGui::PushItemWidth(<span class="number">60</span>);</span><br><span class="line"><span class="keyword">if</span> (projectionType == <span class="number">1</span>) &#123;</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Left"</span>, &amp;left);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Right"</span>, &amp;right);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Bottom"</span>, &amp;bottom);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Top"</span>, &amp;top);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Near"</span>, &amp;nearDist);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Far"</span>, &amp;farDist);</span><br><span class="line">    projection = glm::ortho(left, right, bottom, top, nearDist, farDist);</span><br><span class="line">&#125;</span><br><span class="line">ImGui::RadioButton(<span class="string">"Perspective"</span>, &amp;projectionType, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (projectionType == <span class="number">2</span>) &#123;</span><br><span class="line">    ImGui::InputFloat(<span class="string">"FOV"</span>, &amp;fov);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Aspect Ratio"</span>, &amp;ratio);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Near"</span>, &amp;nearDist);</span><br><span class="line">    ImGui::SameLine(<span class="number">0.0f</span>, <span class="number">10.0f</span>);</span><br><span class="line">    ImGui::InputFloat(<span class="string">"Far"</span>, &amp;farDist);</span><br><span class="line">    projection = glm::perspective(fov, ratio, nearDist, farDist);</span><br><span class="line">&#125;</span><br><span class="line">ImGui::EndGroup();</span><br><span class="line">ImGui::End();</span><br></pre></td></tr></table></figure><p>效果：<br><img src="/2019/04/17/Camera/GUI.png" title="GUI"></p><p>多组参数的结果：</p><p>改变left、right、bottom和top，这决定了视口的左右范围和上下范围。数值范围越大，显示的范围也越大，物体也就越小。</p><img src="/2019/04/17/Camera/1.png" title="1.1"><img src="/2019/04/17/Camera/2.png" title="1.2"><p>如果长宽比与窗口相同，则显示的内容与真实的比例相同，否则会发生比例的变化。</p><img src="/2019/04/17/Camera/4.png" title="1.4"><p>near和far参数是显示的最近距离和最远距离。摄像机的z坐标是15，立方体中心的z坐标是-1.5，立方体的边长为4，立方体的正面离摄像机的距离是14.5。所以当把near设为15时，立方体的正面便不会显示出来，而显示立方体的背面。</p><img src="/2019/04/17/Camera/3.png" title="1.3"><h2 id="透视投影（perspective-projection）：实现透视投影，使用多组参数，比较结果差异"><a href="#透视投影（perspective-projection）：实现透视投影，使用多组参数，比较结果差异" class="headerlink" title="透视投影（perspective projection）：实现透视投影，使用多组参数，比较结果差异"></a>透视投影（perspective projection）：实现透视投影，使用多组参数，比较结果差异</h2><p>多组参数的结果：</p><p>fov代表了视角大小，视角越小，看到的范围越小，物体就越大。</p><img src="/2019/04/17/Camera/5.png" title="2.1"><img src="/2019/04/17/Camera/6.png" title="2.2"><p>aspect ratio代表了宽高比，如果与窗口相同，则显示的内容与真实的比例相同，否则会发生比例的变化。</p><img src="/2019/04/17/Camera/7.png" title="2.3"><p>near和far决定了显示的前后范围。当把far设为17时，立方体的后半部分不显示。</p><img src="/2019/04/17/Camera/8.png" title="2.4"><p>当把near设为15时，立方体的前半部分不显示。</p><img src="/2019/04/17/Camera/9.png" title="2.5"><h1 id="视角变换（View-Changing）"><a href="#视角变换（View-Changing）" class="headerlink" title="视角变换（View Changing）"></a>视角变换（View Changing）</h1><h2 id="把cube放置在-0-0-0-处，做透视投影，使摄像机围绕cube旋转，并且时刻看着cube中心"><a href="#把cube放置在-0-0-0-处，做透视投影，使摄像机围绕cube旋转，并且时刻看着cube中心" class="headerlink" title="把cube放置在(0, 0, 0)处，做透视投影，使摄像机围绕cube旋转，并且时刻看着cube中心"></a>把cube放置在(0, 0, 0)处，做透视投影，使摄像机围绕cube旋转，并且时刻看着cube中心</h2><p>使摄像机位置始终在半径为15的圆周上，可以用三角函数实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ImGui::RadioButton(<span class="string">"View Changing"</span>, &amp;function, <span class="number">2</span>)) &#123;</span><br><span class="line">    rotateTime = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">float</span> time = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line"><span class="keyword">float</span> radius = <span class="number">15.0f</span>;</span><br><span class="line"><span class="keyword">float</span> camX = <span class="built_in">sin</span>(time - rotateTime) * radius;</span><br><span class="line"><span class="keyword">float</span> camZ = <span class="built_in">cos</span>(time - rotateTime) * radius;</span><br></pre></td></tr></table></figure><p>使用摄像机位置，创建LookAt矩阵，令摄像机始终看着(0, 0, 0)。投影矩阵使用透视投影。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view = glm::lookAt(glm::vec3(camX, <span class="number">0.0</span>, camZ), glm::vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>));</span><br><span class="line">projection = glm::perspective(glm::radians(<span class="number">45.0f</span>), (<span class="keyword">float</span>)windowWidth / windowHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/04/17/Camera/rotate.gif" title="旋转"><h1 id="在现实生活中，我们一般将摄像机摆放的空间View-matrix和被拍摄的物体摆设的空间Model-matrix分开，但是在OpenGL中却将两个合二为一设为ModelView-matrix，通过上面的作业启发，你认为是为什么呢？"><a href="#在现实生活中，我们一般将摄像机摆放的空间View-matrix和被拍摄的物体摆设的空间Model-matrix分开，但是在OpenGL中却将两个合二为一设为ModelView-matrix，通过上面的作业启发，你认为是为什么呢？" class="headerlink" title="在现实生活中，我们一般将摄像机摆放的空间View matrix和被拍摄的物体摆设的空间Model matrix分开，但是在OpenGL中却将两个合二为一设为ModelView matrix，通过上面的作业启发，你认为是为什么呢？"></a>在现实生活中，我们一般将摄像机摆放的空间View matrix和被拍摄的物体摆设的空间Model matrix分开，但是在OpenGL中却将两个合二为一设为ModelView matrix，通过上面的作业启发，你认为是为什么呢？</h1><p>因为OpenGL本身并没有摄像机这个概念，我们的摄像机，只是通过将场景中的物体往相反的方向移动模拟出来的。由于实际上只有一个坐标系统，坐标变换本质上都是在物体上进行，所以将View和Model矩阵合并成ModelView矩阵。而在多个摄像机的情况下，只需定义不同的ModelView矩阵，就可以实现摄像机的切换，不需要在多个坐标系统之间进行切换，实现起来比较方便。</p><h1 id="Bonus：实现一个camera类，能够使用键盘和鼠标控制视角，实现类似FPS的游戏场景"><a href="#Bonus：实现一个camera类，能够使用键盘和鼠标控制视角，实现类似FPS的游戏场景" class="headerlink" title="Bonus：实现一个camera类，能够使用键盘和鼠标控制视角，实现类似FPS的游戏场景"></a>Bonus：实现一个camera类，能够使用键盘和鼠标控制视角，实现类似FPS的游戏场景</h1><p>类的头文件定义如下，具体实现请看源代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default camera values</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> YAW = <span class="number">-90.0f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> PITCH = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> FOV = <span class="number">45.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor with vectors</span></span><br><span class="line">    Camera(glm::vec3 _position = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">15.0f</span>), </span><br><span class="line">        glm::vec3 _front = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>), </span><br><span class="line">        glm::vec3 _up = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>), </span><br><span class="line">        <span class="keyword">float</span> _yaw = YAW, <span class="keyword">float</span> _pitch = PITCH);</span><br><span class="line">    <span class="comment">// Returns the view matrix</span></span><br><span class="line">    glm::<span class="function">mat4 <span class="title">getViewMatrix</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Move the camera</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveForward</span><span class="params">(<span class="keyword">float</span> distance)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveBack</span><span class="params">(<span class="keyword">float</span> distance)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveRight</span><span class="params">(<span class="keyword">float</span> distance)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveLeft</span><span class="params">(<span class="keyword">float</span> distance)</span></span>;</span><br><span class="line">    <span class="comment">// Rotate the camera using pitch and yaw</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">float</span> _pitch, <span class="keyword">float</span> _yaw)</span></span>;</span><br><span class="line">    <span class="comment">// Change the fov to zoom</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">zoom</span><span class="params">(<span class="keyword">float</span> yoffset)</span></span>;</span><br><span class="line">    <span class="comment">// Get the fov</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getFov</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Reset the camera</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Calculates the front vector from the Camera's (updated) Euler Angles</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateCameraVectors</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Camera Attributes</span></span><br><span class="line">    glm::vec3 position;</span><br><span class="line">    glm::vec3 front;</span><br><span class="line">    glm::vec3 up;</span><br><span class="line">    glm::vec3 right;</span><br><span class="line">    glm::vec3 world_up;</span><br><span class="line">    <span class="comment">// Euler Angles</span></span><br><span class="line">    <span class="keyword">float</span> yaw;</span><br><span class="line">    <span class="keyword">float</span> pitch;</span><br><span class="line">    <span class="comment">// Camera options</span></span><br><span class="line">    <span class="keyword">float</span> fov;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>检测键盘输入，调用Camera类的四个移动方法，实现摄像机的移动：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> cameraSpeed = <span class="number">20.0f</span> * deltaTime;</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)</span><br><span class="line">    camera.moveForward(cameraSpeed);</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)</span><br><span class="line">    camera.moveBack(cameraSpeed);</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)</span><br><span class="line">    camera.moveLeft(cameraSpeed);</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)</span><br><span class="line">    camera.moveRight(cameraSpeed);</span><br></pre></td></tr></table></figure><p>在鼠标回调函数中，调用Camera类的rotate方法，实现视角的转动:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (firstMouse) &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">        firstMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> xoffset = xpos - lastX;</span><br><span class="line">    <span class="keyword">float</span> yoffset = lastY - ypos;</span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> sensitivity = <span class="number">0.05</span>;</span><br><span class="line">    xoffset *= sensitivity;</span><br><span class="line">    yoffset *= sensitivity;</span><br><span class="line">    camera.rotate(yoffset, xoffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在滚动的回调函数中，调用Camera类的zoom方法，实现放大和缩小:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffset)</span> </span>&#123;</span><br><span class="line">    camera.zoom(yoffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染的时候，通过Camera类获取View Matrix和FOV：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view = camera.getViewMatrix();</span><br><span class="line">projection = glm::perspective(camera.getFov(), (<span class="keyword">float</span>)windowWidth / windowHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>实现效果：</p><img src="/2019/04/17/Camera/bonus.gif" title="bonus">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;投影（Projection&quot;&gt;&lt;a href=&quot;#投影（Projection&quot; class=&quot;headerlink&quot; title=&quot;投影（Projection)&quot;&gt;&lt;/a&gt;投影（Projection)&lt;/h1&gt;&lt;h2 id=&quot;把上次作业绘制的cube放置在-1-5
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>用例建模 - 绘制用例图</title>
    <link href="https://xungerrrr.github.io/2019/04/12/%E7%94%A8%E4%BE%8B%E5%BB%BA%E6%A8%A1-%E7%BB%98%E5%88%B6%E7%94%A8%E4%BE%8B%E5%9B%BE/"/>
    <id>https://xungerrrr.github.io/2019/04/12/用例建模-绘制用例图/</id>
    <published>2019-04-12T06:08:30.000Z</published>
    <updated>2019-04-13T16:22:04.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ul><li><p>用例的概念</p><ul><li>用例是描述参与者使用系统去达到某种目的一系列相关的成功和失败情景。</li><li>用例是文本文档而不是图，即用例建模的过程主要是文本编写，而不是制图。</li><li>用例与面向对象无关。</li><li>用例是经典面向对象分析与设计的一个关键需求输入。</li><li>用例是表现系统功能的功能性或行为性需求。</li></ul></li><li><p>用例和场景的关系？什么是主场景或happy path？</p><ul><li>一个用例代表了多个场景，包括主场景和其他可选场景。</li><li>主场景对应主要的系统交互，通常是成功场景。</li><li>可选场景对应较少的交互和异常情况。</li></ul></li><li><p>用例有哪些形式？</p><ul><li>Brief：一段精炼的总结，通常是主场景。</li><li>Casual：非正式的段落格式，多个段落对应多个场景。</li><li>Fully：详细说明所有的步骤和变化。</li></ul></li><li><p>对于复杂业务，为什么编制完整用例非常难？</p><p>复杂业务的业务流程很复杂，涉及很多的场景，场景之间的关联也非常多，很难将所有的用例和场景按照一定顺序列举出来。同时，如果用例编写者对各个业务流程的理解存在偏差，用例的准确性和完整性就难以保证。</p></li><li><p>什么是用例图？</p><p>用例图是指由参与者（Actor）、用例（Use Case），边界以及它们之间的关系构成的用于描述系统功能的视图，也是外部用户所能观察到的系统功能的模型图。</p></li><li><p>用例图的基本符号与元素？</p><ul><li>小人（参与者）<img src="/2019/04/12/用例建模-绘制用例图/actor.png" title="actor"></li><li>椭圆（用例）<img src="/2019/04/12/用例建模-绘制用例图/usecase.png" title="usecase"></li><li>矩形（系统边界）<img src="/2019/04/12/用例建模-绘制用例图/system.png" title="system"></li><li>关系<ul><li>直线（关联关系）<img src="/2019/04/12/用例建模-绘制用例图/association.png" title="association"></li><li>&lt;<includes>&gt;箭头（包含关系）<img src="/2019/04/12/用例建模-绘制用例图/includes.png" title="includes"></includes></li><li>&lt;<extends>&gt;箭头（扩展关系）<img src="/2019/04/12/用例建模-绘制用例图/extends.png" title="extends"></extends></li><li>空心箭头（泛化关系）<img src="/2019/04/12/用例建模-绘制用例图/generalization.png" title="generalisation"></li></ul></li></ul></li><li><p>用例图的画法与步骤</p><ol><li>绘制系统边界。</li><li>绘制参与者，将参与者画在所有系统边界以外。</li><li>绘制用例，考虑每一个参与者是如何使用系统的，将相应的用例画在对应的系统中，用线将用例和参与者关联起来。</li><li>绘制用例间的关系：如包含关系、扩展关系和泛化关系。</li><li>绘制关联的外部支持系统，用线将支持系统和对应的用例关联起来。</li></ol></li><li><p>用例图给利益相关人与开发者的价值有哪些？</p><ul><li>利益相关人<br>用例图清晰地展示了系统的功能组成，客户可以清楚地看到系统设计与自己的要求是否相符。同时，客户可以简单修改用例图来表达需求变更的想法。</li><li>开发者<br>用例图明确地表达了用户的需求，因此系统架构的设计可以更加准确，同时系统的工作量评估也变得方便。</li></ul></li></ul><h2 id="建模练习题（用例模型）"><a href="#建模练习题（用例模型）" class="headerlink" title="建模练习题（用例模型）"></a>建模练习题（用例模型）</h2><ul><li><p>选择2-3个你熟悉的类似业务的在线服务系统（或移动APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求：</p><ul><li>请使用用户的视角，描述用户目标或系统提供的服务<br>订电影票</li><li>粒度达到子用例级别，并用include和exclude关联它们</li><li>请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例</li><li>尽可能识别外部系统和服务</li></ul><p>淘票票电影订票系统</p><img src="/2019/04/12/用例建模-绘制用例图/Tao.png" title="Tao"><p>猫眼电影订票系统</p><img src="/2019/04/12/用例建模-绘制用例图/Cat.png" title="Cat"></li><li><p>为什么相似系统的用例图是相似的？<br>相似的系统具有相似的需求，因此系统的功能和结构也非常相似，导致了用例图的相似性。</p></li><li>如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用。<br>根据创新点在用例图中的位置来判断。</li><li>请使用SCRUM方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表。</li></ul><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">Name</th><th style="text-align:center">Imp</th><th style="text-align:center">Est</th><th style="text-align:center">How to demo</th><th style="text-align:center">Note</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">登录注册</td><td style="text-align:center">15</td><td style="text-align:center">10</td><td style="text-align:center">可以选择登录或注册；输入已注册的账户和密码进行登录；使用手机验证码进行注册</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">搜索旅馆</td><td style="text-align:center">20</td><td style="text-align:center">15</td><td style="text-align:center">输入地点和时间进行搜索，生成酒店列表，然后可以选择按照价格、类型、评分等排序</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">预定旅馆</td><td style="text-align:center">10</td><td style="text-align:center">4</td><td style="text-align:center">用户点击酒店，选择房型，然后跳转到支付页面。</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">管理订单</td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">在订单页面显示历史订单，用户可以修改订单的时间、房型，或者取消订单</td></tr></tbody></table><ul><li>根据任务4，参考使用用例点估算软件成本，给出项目用例点的估算</li></ul><table><thead><tr><th style="text-align:center">用例</th><th style="text-align:center">事务</th><th style="text-align:center">计算</th><th style="text-align:center">原因</th><th style="text-align:center">权重</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">登录注册</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">搜索旅馆</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">预定旅馆</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">管理订单</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简答题&quot;&gt;&lt;a href=&quot;#简答题&quot; class=&quot;headerlink&quot; title=&quot;简答题&quot;&gt;&lt;/a&gt;简答题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用例的概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用例是描述参与者使用系统去达到某种目的一系列相关的成功和失败情景。&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="SE" scheme="https://xungerrrr.github.io/tags/SE/"/>
    
  </entry>
  
  <entry>
    <title>Transformation</title>
    <link href="https://xungerrrr.github.io/2019/04/09/Transformation/"/>
    <id>https://xungerrrr.github.io/2019/04/09/Transformation/</id>
    <published>2019-04-09T10:55:37.000Z</published>
    <updated>2019-04-09T14:22:01.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="画一个立方体，边长为4，中心位置为-0-0-0"><a href="#画一个立方体，边长为4，中心位置为-0-0-0" class="headerlink" title="画一个立方体，边长为4，中心位置为(0, 0, 0)"></a>画一个立方体，边长为4，中心位置为(0, 0, 0)</h2><p>首先设定立方体的初始顶点位置和颜色。立方体的边长为4，中心位置为(0, 0, 0)，所以三个坐标轴的范围都是[-2, 2]。由于正方体有六个面，每个面由两个三角形构成，因此一共有36个点。同时，我希望用立方体表现出RGB颜色空间，x轴对应红色，y轴对应绿色，z轴对应蓝色，所以要根据点的坐标设置对应的颜色。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了能够显示出3D图形，需要进行坐标变换。需要相应的变换矩阵，实现从局部坐标到世界坐标、从世界坐标到观察坐标、从观察坐标到裁剪坐标的变换。在顶点着色器中添加这些矩阵作为全局变量，再进行矩阵相乘运算后输出，可以实现这个效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 aColor;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line">out vec3 ourColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * vec4(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要完整显示出立方体，要将摄像机向后移动，这个可以通过glm::translate移动场景来创建平移矩阵。要呈现立方体的真实感，需要进行透视投影，可以通过glm::perspective来创建投影矩阵。下面的代码添加在渲染循环过程内。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 model = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">glm::mat4 view = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">glm::mat4 projection = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">view = glm::translate(view, glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-15.0f</span>));</span><br><span class="line">projection = glm::perspective(glm::radians(<span class="number">45.0f</span>), (<span class="keyword">float</span>)windowWidth / windowHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line">shader.setMat4(<span class="string">"model"</span>, model);</span><br><span class="line">shader.setMat4(<span class="string">"projection"</span>, projection);</span><br><span class="line">shader.setMat4(<span class="string">"view"</span>, view);</span><br></pre></td></tr></table></figure><p>glDisable(GL_DEPTH_TEST)，关闭深度测试，渲染效果如下。这个效果不像是真实的立方体，本该被覆盖的后面被显示了出来。这是因为OpenGL是逐个三角形绘制的，后来绘制的像素有可能会覆盖之前的像素。</p><img src="/2019/04/09/Transformation/1.png" title="关闭深度测试"><p>glEnable(GL_DEPTH_TEST) ，启动深度测试，渲染效果如下。这个效果好多了，前面完全覆盖了背面，是一个真实的立方体（虽然这里看上去像正方形）。OpenGL的深度信息存储在Z缓冲中，也叫深度缓冲，GLFW会自动创建这个缓冲。当片段要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程就是深度测试，由OpenGL自动完成。</p><img src="/2019/04/09/Transformation/2.png" title="启动深度测试"><h2 id="平移-Translation-：使画好的cube沿着水平或垂直方向来回移动"><a href="#平移-Translation-：使画好的cube沿着水平或垂直方向来回移动" class="headerlink" title="平移(Translation)：使画好的cube沿着水平或垂直方向来回移动"></a>平移(Translation)：使画好的cube沿着水平或垂直方向来回移动</h2><p>用glm::translate生成平移矩阵，赋给model就可以实现平移。通过三角函数，可以实现立方体沿x轴来回移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> time = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line">model = glm::translate(model, glm::vec3(<span class="built_in">sin</span>(time) * <span class="number">4</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/04/09/Transformation/demo1.gif" title="平移"><h2 id="旋转-Rotation-：使画好的cube沿着XoZ平面的x-z轴持续旋转"><a href="#旋转-Rotation-：使画好的cube沿着XoZ平面的x-z轴持续旋转" class="headerlink" title="旋转(Rotation)：使画好的cube沿着XoZ平面的x=z轴持续旋转"></a>旋转(Rotation)：使画好的cube沿着XoZ平面的x=z轴持续旋转</h2><p>用glm::rotate生成旋转矩阵，赋给model就可以实现旋转。坐标设置为(1, 0, 1)，可以沿着x=z轴旋转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> time = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line">model = glm::rotate(model, time * <span class="number">2</span> * glm::radians(<span class="number">50.0f</span>), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/04/09/Transformation/demo2.gif" title="旋转"><h2 id="放缩-Scaling-：使画好的cube持续放大缩小"><a href="#放缩-Scaling-：使画好的cube持续放大缩小" class="headerlink" title="放缩(Scaling)：使画好的cube持续放大缩小"></a>放缩(Scaling)：使画好的cube持续放大缩小</h2><p>用glm::scale生成放缩矩阵，赋给model就可以实现放缩。利用三角函数和时间可以实现持续放缩。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> time = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line">model = glm::scale(model, glm::vec3(<span class="number">0.5</span> * <span class="built_in">sin</span>(time) + <span class="number">1</span>, <span class="number">0.5</span> * <span class="built_in">sin</span>(time) + <span class="number">1</span>, <span class="number">0.5</span> * <span class="built_in">sin</span>(time) + <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/04/09/Transformation/demo3.gif" title="放缩"><h2 id="在GUI里添加菜单栏，可以选择各种变换"><a href="#在GUI里添加菜单栏，可以选择各种变换" class="headerlink" title="在GUI里添加菜单栏，可以选择各种变换"></a>在GUI里添加菜单栏，可以选择各种变换</h2><p>用GUI将上述变换整合起来，得到结合的变换。旋转变换一定要放在最后，否则会使立方体偏离位置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ImGui::MenuItem(<span class="string">"translate"</span>, <span class="literal">NULL</span>, &amp;translate))</span><br><span class="line">    translateTime = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line"><span class="keyword">if</span> (ImGui::MenuItem(<span class="string">"scale"</span>, <span class="literal">NULL</span>, &amp;scale))</span><br><span class="line">    scaleTime = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line"><span class="keyword">if</span> (ImGui::MenuItem(<span class="string">"rotate"</span>, <span class="literal">NULL</span>, &amp;rotate))</span><br><span class="line">    rotateTime = (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line"><span class="keyword">if</span> (translate)</span><br><span class="line">    model = glm::translate(model, glm::vec3(<span class="built_in">sin</span>( (time - translateTime)) * <span class="number">4</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"><span class="keyword">if</span> (scale)</span><br><span class="line">    model = glm::scale(model, glm::vec3(<span class="number">0.5</span> * <span class="built_in">sin</span>(time - scaleTime) + <span class="number">1</span>, <span class="number">0.5</span> * <span class="built_in">sin</span>(time - scaleTime) + <span class="number">1</span>, <span class="number">0.5</span> * <span class="built_in">sin</span>(time - scaleTime) + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (rotate)</span><br><span class="line">    model = glm::rotate(model, (time - rotateTime) * <span class="number">2</span> * glm::radians(<span class="number">50.0f</span>), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure></p><p>效果：</p><img src="/2019/04/09/Transformation/demo4.gif" title="GUI"><h2 id="结合Shader谈谈对渲染管线的理解"><a href="#结合Shader谈谈对渲染管线的理解" class="headerlink" title="结合Shader谈谈对渲染管线的理解"></a>结合Shader谈谈对渲染管线的理解</h2><p>渲染管线的作用是接受3D坐标，最终将它们转变成屏幕上的有色2D像素。渲染管线可以被划分成几个阶段，这些阶段高度专门化，并且容易并行执行。这些阶段在显卡中有各自对应的小程序，这些小程序就是着色器（Shader）。</p><p>渲染管线的第一个阶段是顶点着色器，它接受一个顶点坐标作为输入，进行坐标变换，处理顶点属性，然后输出变换后的3D坐标和属性。下一个阶段是图元装配，根据图元的类型接受来自顶点着色器的输入，将这些输入的坐标组装成对应的图元形状。几何着色器是第三个阶段，接受来自图元装配阶段的输入，通过产生新的顶点，构造新的图元，产生其他形状的图形。之后，数据会传入光栅化阶段，这个阶段会将图元映射到屏幕空间，生成片段，并且会裁剪出视口以外的像素。下一个阶段是片段着色器，能够计算像素的颜色，用于光照、阴影、颜色等效果。最后是Alpha测试和混合阶段，这个阶段进行深度检测和Alpha值检测，能够判断物体的深度和透明度，实现对象的遮挡和混合，最终输出符合预期的渲染效果。</p><h2 id="Bonus-将以上三种变换相结合，打开你们的脑洞，实现有创意的动画。"><a href="#Bonus-将以上三种变换相结合，打开你们的脑洞，实现有创意的动画。" class="headerlink" title="Bonus: 将以上三种变换相结合，打开你们的脑洞，实现有创意的动画。"></a>Bonus: 将以上三种变换相结合，打开你们的脑洞，实现有创意的动画。</h2><p>将平移和旋转结合起来，实现立方体在水平面上的滚动动画。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flip) &#123;</span><br><span class="line">    <span class="comment">// 判断旋转周期</span></span><br><span class="line">    <span class="keyword">if</span> (time - flipTime &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; time - flipTime &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        flipTime = time;</span><br><span class="line">        cycle++;</span><br><span class="line">        shift += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在不同的旋转周期，实现不同的变换</span></span><br><span class="line">    model = glm::translate(model, glm::vec3((shift + <span class="number">2</span> - <span class="number">20</span>), <span class="number">-2.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    model = glm::rotate(model, - (time - flipTime) * glm::radians(<span class="number">90.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    model = glm::translate(model, glm::vec3(<span class="number">-2.0f</span>, <span class="number">2.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    model = glm::rotate(model, -(cycle - <span class="number">1</span>) * glm::radians(<span class="number">90.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，通过滑块调整投射投影的可视角度，能够方便地调节场景可视范围。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImGui::SliderAngle(<span class="string">"viewing angle"</span>, &amp;viewAngle, <span class="number">10</span>, <span class="number">90</span>);</span><br><span class="line">projection = glm::perspective(viewAngle, (<span class="keyword">float</span>)windowWidth / windowHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>效果：</p><img src="/2019/04/09/Transformation/demo5.gif" title="Bonus">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;画一个立方体，边长为4，中心位置为-0-0-0&quot;&gt;&lt;a href=&quot;#画一个立方体，边长为4，中心位置为-0-0-0&quot; class=&quot;headerlink&quot; title=&quot;画一个立方体，边长为4，中心位置为(0, 0, 0)&quot;&gt;&lt;/a&gt;画一个立方体，边长为4，中心
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>软件项目过程模型与规划</title>
    <link href="https://xungerrrr.github.io/2019/04/01/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%A7%84%E5%88%92/"/>
    <id>https://xungerrrr.github.io/2019/04/01/软件项目过程模型与规划/</id>
    <published>2019-04-01T14:24:32.000Z</published>
    <updated>2019-04-13T06:05:53.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点"><a href="#简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点" class="headerlink" title="简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点"></a>简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点</h2><p>从项目特点、风险特征、人力资源利用角度思考</p><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>降低软件开发的复杂程度，提高开发过程的透明性和可管理性。</li><li>推迟软件实现，强调分析和设计工作的重要性。</li><li>以项目的阶段评审和文档控制为手段，有效地对整个开发过程进行指导，能够及时发现并纠正问题。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>强调开发过程的线性顺序，缺乏灵活性。</li><li>无法解决软件需求不明确的问题。</li><li>瀑布模型是文档驱动的，规定过多的文档会大大增加工作量，仅根据文档来评估进度可能会出错。</li><li>风险控制的能力较弱。</li><li>资源调配问题：知识技能需求不同，人员数量要求不同。</li></ul><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>增强客户对系统的信心。</li><li>降低系统失败的风险。</li><li>提高系统可靠性。</li><li>提高系统的稳定性和可维护性。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>建立初始模型时，作为增量基础的基本业务服务的确定有一定难度。</li><li>增量粒度难以选择。</li></ul><h3 id="螺旋模型（含原型方法）"><a href="#螺旋模型（含原型方法）" class="headerlink" title="螺旋模型（含原型方法）"></a>螺旋模型（含原型方法）</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>风险驱动的迭代过程，强调可选方案和约束条件从而支持软件的重用，有助于将软件质量作为特殊目标融入产品开发之中。</li><li>结合了瀑布模型和快速原型方法，将瀑布模型的多个阶段转化到多个迭代过程中，以降低项目的风险。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>螺旋模型强调风险分析，但说服外部客户接受和相信分析结果并做出相关反应并不容易，因此螺旋模型往往比较适合内部的大规模软件开发。</li><li>风险分析需要耗费相当的成本，因此螺旋模型比较适合投资规模较大的软件项目。</li><li>失误的风险分析可能带来更大的风险。</li></ul><h2 id="简述统一过程三大特点，与面向对象的方法有什么关系？"><a href="#简述统一过程三大特点，与面向对象的方法有什么关系？" class="headerlink" title="简述统一过程三大特点，与面向对象的方法有什么关系？"></a>简述统一过程三大特点，与面向对象的方法有什么关系？</h2><ul><li>软件开发是一个迭代过程。</li><li>软件开发是由Use Case驱动的。</li><li>软件开发是以架构设计为中心的。</li></ul><p>统一过程是一个面向对象的软件开发方法，它给出了有关软件开发过程组织及实施的指导。</p><h2 id="简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？"><a href="#简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？" class="headerlink" title="简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？"></a>简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？</h2><p>统一过程四个阶段的划分准则是每个阶段的目标和里程碑。</p><ul><li>初始阶段<br>生命周期目标里程碑：通过对文档的评审确定用例需求理解正确、项目风险评估合理、阶段计划可行等。</li><li>细化阶段<br>生命周期体系结构里程碑：通过评审确定软件体系结构已经稳定、高风险的业务需求和技术机制已经解决、修订的项目计划可行等。</li><li>构建阶段<br>初始运行能力里程碑：包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署。此刻，要确定软件、环境、用户是否可以开始系统的运行。</li><li>交付阶段<br>产品发布里程碑：确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周<br>期。</li></ul><h2 id="软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？"><a href="#软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？" class="headerlink" title="软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？"></a>软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？</h2><p>软件企业采用基于统一过程的软件项目规划，利用软件产品范围的弹性，合理规划范围（20%业务决定80%满意度），使得软件企业按固定节奏生产、固定周期发布软件产品。</p><p>统一过程能够对过程加以调整改造，通过适当裁剪过程，可以调整生命周期阶段过程的正规性，持续优化过程。统一过程可以平衡竞争利益相关者的优先级，通过定义、理解和划分业务与用户优先次序的需求，为项目和需求制定优先次序，将需求和软件能力相结合，平衡资产重用与用户需求。统一过程可以创建自我管理的团队，鼓励跨职能协作，整合业务、软件和运作团队，从而激发开发成员的最佳表现。通过反复迭代，经过反馈、改变、消除风险和调整计划，可以有效证实项目目标的价值。统一过程还可以提高资源的重用率，并通过持续关注产品质量，保证项目质量的可靠。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点&quot;&gt;&lt;a href=&quot;#简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点&quot; class=&quot;headerlink&quot; title=&quot;简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点&quot;&gt;
      
    
    </summary>
    
    
      <category term="SE" scheme="https://xungerrrr.github.io/tags/SE/"/>
    
  </entry>
  
  <entry>
    <title>Draw Line</title>
    <link href="https://xungerrrr.github.io/2019/03/26/Draw-Line/"/>
    <id>https://xungerrrr.github.io/2019/03/26/Draw-Line/</id>
    <published>2019-03-26T05:42:18.000Z</published>
    <updated>2019-03-26T07:21:01.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Bresenham算法画一个三角形边框"><a href="#使用Bresenham算法画一个三角形边框" class="headerlink" title="使用Bresenham算法画一个三角形边框"></a>使用Bresenham算法画一个三角形边框</h2><p>根据要求，设计一个三角形的类，如下。在构造函数中输入三个顶点坐标。使用draw函数画图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Triangle(Shader &amp;shaderProgram, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x3, <span class="keyword">int</span> y3, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">float</span> col[]);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> color[<span class="number">3</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    <span class="keyword">int</span> windowWidth, windowHeight;</span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2, x3, y3;</span><br><span class="line">    Shader shader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> xn, <span class="keyword">int</span> yn)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">float</span> color[<span class="number">3</span>])</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>draw函数初始化缓冲区，然后调用drawLine函数画三角形的三条边：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Triangle::draw() &#123;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    </span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    drawLine(x1, y1, x2, y2);</span><br><span class="line">    drawLine(x1, y1, x3, y3);</span><br><span class="line">    drawLine(x2, y2, x3, y3);</span><br><span class="line"></span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>drawLine函数根据两个端点坐标，使用Bresenham算法计算直线上每一个点的坐标，然后调用drawPoint函数画点。步骤如下：</p><ol><li><p>输入数据</p><p> (x0, y0)为起点坐标，(xn, yn)为终点坐标。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Triangle::drawLine(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> xn, <span class="keyword">int</span> yn)</span><br></pre></td></tr></table></figure></li><li><p>计算Δx和Δy，判断Δx和Δy是否为0</p><p> 如果Δx和Δy都为0，说明两点重合，只画一个点；如果Δx为0，则画一条垂直的线；如果Δy为0，则画一条水平的线。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> delta_x = <span class="built_in">abs</span>(xn - x0), delta_y = <span class="built_in">abs</span>(yn - y0);</span><br><span class="line"><span class="keyword">int</span> x = x0, y = y0;</span><br><span class="line"><span class="keyword">if</span> (delta_x == <span class="number">0</span> &amp;&amp; delta_y == <span class="number">0</span>) &#123;</span><br><span class="line">    drawPoint(x, y, <span class="number">0</span>, color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delta_x == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> y_dir = (yn - y0) / delta_y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= delta_y; i++) &#123;</span><br><span class="line">        drawPoint(x, y, <span class="number">0</span>, color);</span><br><span class="line">        y += y_dir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delta_y == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> x_dir = (xn - x0) / delta_x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= delta_x; i++) &#123;</span><br><span class="line">        drawPoint(x, y, <span class="number">0</span>, color);</span><br><span class="line">        x += x_dir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果Δx和Δy均不为0，则使用Bresenham算法画直线</p><ul><li><p>斜率m的绝对值小于或等于1时，每次移动x坐标一个单位，然后计算y坐标。（根据端点坐标确定移动方向）</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">float</span>)delta_y / (<span class="keyword">float</span>)delta_x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> x_dir = (xn - x0) / delta_x;</span><br><span class="line">    <span class="keyword">int</span> y_dir = (yn - y0) / delta_y;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">2</span> * delta_y - delta_x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= delta_x; i++) &#123;</span><br><span class="line">        drawPoint(x, y, <span class="number">0</span>, color);</span><br><span class="line">        x += x_dir;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            p += (<span class="number">2</span> * delta_y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            y += y_dir;</span><br><span class="line">            p += (<span class="number">2</span> * delta_y - <span class="number">2</span> * delta_x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>斜率m的绝对值大与1时，每次移动y坐标一个单位，然后计算x坐标。（根据端点坐标确定移动方向）</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x_dir = (xn - x0) / delta_x;</span><br><span class="line">    <span class="keyword">int</span> y_dir = (yn - y0) / delta_y;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">2</span> * delta_x - delta_y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= delta_y; i++) &#123;</span><br><span class="line">        drawPoint(x, y, <span class="number">0</span>, color);</span><br><span class="line">        y += y_dir;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            p += (<span class="number">2</span> * delta_x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x += x_dir;</span><br><span class="line">            p += (<span class="number">2</span> * delta_x - <span class="number">2</span> * delta_y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>drawPoint函数会根据窗口大小，将输入的坐标值转换成-1~1之间的标准坐标值，然后绘制一个点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Triangle::drawPoint(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">float</span> color[<span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="keyword">float</span> point[<span class="number">6</span>];</span><br><span class="line">    point[<span class="number">0</span>] = (<span class="keyword">float</span>)x / windowWidth * <span class="number">2</span>;</span><br><span class="line">    point[<span class="number">1</span>] = (<span class="keyword">float</span>)y / windowHeight * <span class="number">2</span>;</span><br><span class="line">    point[<span class="number">2</span>] = z;</span><br><span class="line">    point[<span class="number">3</span>] = color[<span class="number">0</span>];</span><br><span class="line">    point[<span class="number">4</span>] = color[<span class="number">1</span>];</span><br><span class="line">    point[<span class="number">5</span>] = color[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    shader.use();</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, windowWidth, windowHeight);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(point), point, GL_STATIC_DRAW);</span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    glDrawArrays(GL_POINTS, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在ImGui设置三个点的坐标，就可以画出三角形</p><img src="/2019/03/26/Draw-Line/1.png" title="三角形"><h2 id="使用Bresenham算法画一个圆"><a href="#使用Bresenham算法画一个圆" class="headerlink" title="使用Bresenham算法画一个圆"></a>使用Bresenham算法画一个圆</h2><p>根据要求，设计一个圆的类，如下。在构造函数中输入圆心坐标和半径。使用draw函数画图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(Shader &amp;shaderProgram, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> r, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> color[<span class="number">3</span>] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    <span class="keyword">int</span> windowWidth, windowHeight;</span><br><span class="line">    <span class="keyword">int</span> x0, y0, r;</span><br><span class="line">    Shader shader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawSymmetricPoints</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">float</span> color[<span class="number">3</span>])</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>draw函数初始化缓冲区，使用Bresenham算法计算1/8圆周的坐标，然后调用drawSymmetricPoints画出所有8个对称点。计算时，x坐标每次增加1，然后计算y坐标的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = x0, y = y0 + r, d = <span class="number">1</span> - r;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r / <span class="built_in">sqrt</span>(<span class="number">2</span>); i++) &#123;</span><br><span class="line">    drawSymmetricPoints(x, y);</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">if</span> (d &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        d += (<span class="number">2</span> * (x - x0) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        y--;</span><br><span class="line">        d += (<span class="number">2</span> * (x - y + y0 - x0) + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>drawSymmetricPoints函数计算8个关于圆心对称的点，然后调用drawPoint函数画点。drawPoint函数与画三角形的drawPoint函数相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Circle::drawSymmetricPoints(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">    drawPoint(x, y, <span class="number">0</span>, color);</span><br><span class="line">    drawPoint(y - y0 + x0, x - x0 + y0, <span class="number">0</span>, color);</span><br><span class="line">    drawPoint(<span class="number">2</span> * x0 - x, y, <span class="number">0</span>, color);</span><br><span class="line">    drawPoint(y - y0 + x0, x0 + y0 - x, <span class="number">0</span>, color);</span><br><span class="line">    drawPoint(x, <span class="number">2</span> * y0 - y, <span class="number">0</span>, color);</span><br><span class="line">    drawPoint(y0 + x0 - y, x - x0 + y0, <span class="number">0</span>, color);</span><br><span class="line">    drawPoint(<span class="number">2</span> * x0 - x, <span class="number">2</span> * y0 - y, <span class="number">0</span>, color);</span><br><span class="line">    drawPoint(y0 + x0 - y, x0 + y0 - x, <span class="number">0</span>, color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在ImGui设置圆心坐标和半径，就可以画出圆。</p><img src="/2019/03/26/Draw-Line/2.png" title="圆"><h2 id="在GUI在添加菜单栏，可以选择是三角形边框还是圆，以及能调整圆的大小"><a href="#在GUI在添加菜单栏，可以选择是三角形边框还是圆，以及能调整圆的大小" class="headerlink" title="在GUI在添加菜单栏，可以选择是三角形边框还是圆，以及能调整圆的大小"></a>在GUI在添加菜单栏，可以选择是三角形边框还是圆，以及能调整圆的大小</h2><p>在菜单栏中绑定bool对象，实现选择：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ImGui::BeginMainMenuBar()) &#123;</span><br><span class="line">    ImGui::MenuItem(<span class="string">"Triangle"</span>, <span class="literal">NULL</span>, &amp;tri);</span><br><span class="line">    ImGui::MenuItem(<span class="string">"Circle"</span>, <span class="literal">NULL</span>, &amp;cir);</span><br><span class="line">    ImGui::EndMainMenuBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>圆的参数由ImGuid的滑块传入，因此可以调整圆的大小：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cir) &#123;</span><br><span class="line">    ImGui::Begin(<span class="string">"Circle"</span>);</span><br><span class="line">    ImGui::SliderInt(<span class="string">"x"</span>, center, -windowWidth / <span class="number">2</span>, windowWidth / <span class="number">2</span>);</span><br><span class="line">    ImGui::SliderInt(<span class="string">"y"</span>, center + <span class="number">1</span>, -windowWidth / <span class="number">2</span>, windowWidth / <span class="number">2</span>);</span><br><span class="line">    ImGui::SliderInt(<span class="string">"Radius"</span>, radius, <span class="number">0</span>, windowWidth / <span class="number">2</span>);</span><br><span class="line">    ImGui::End();</span><br><span class="line">    <span class="function">Circle <span class="title">circle</span><span class="params">(shader, center[<span class="number">0</span>], center[<span class="number">1</span>], radius[<span class="number">0</span>], windowWidth, windowHeight)</span></span>;</span><br><span class="line">    circle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bonus：使用三角形光栅转换算法，用和背景不同的颜色，填充你的三角形"><a href="#Bonus：使用三角形光栅转换算法，用和背景不同的颜色，填充你的三角形" class="headerlink" title="Bonus：使用三角形光栅转换算法，用和背景不同的颜色，填充你的三角形"></a>Bonus：使用三角形光栅转换算法，用和背景不同的颜色，填充你的三角形</h2><p>给三角形类添加两个方法。fill方法用来填充三角形，contain方法用来判断一个点是否在三角形内部。</p><p>fill函数中，先对顶点坐标进行排序，得到三角形的包围盒。然后遍历包围盒内的点，调用contain判断点是否在内部，最后调用drawPoint画点即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = x_axis[<span class="number">0</span>]; x &lt;= x_axis[<span class="number">2</span>]; x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = y_axis[<span class="number">0</span>]; y &lt;= y_axis[<span class="number">2</span>]; y++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (contain(x, y)) &#123;</span><br><span class="line">            drawPoint(x, y, <span class="number">0</span>, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>contain函数使用向量的向量积来判断点是否在三角形内部。以该点为起点，分别以三个顶点为终点，可以得到三个向量。按照顺序两两求向量积，得到三个乘积。如果三个乘积同号，则说明点在三角形内部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Triangle::contain(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">int</span> v1[] = &#123; x - x1, y - y1 &#125;;</span><br><span class="line">    <span class="keyword">int</span> v2[] = &#123; x - x2, y - y2 &#125;;</span><br><span class="line">    <span class="keyword">int</span> v3[] = &#123; x - x3, y - y3 &#125;;</span><br><span class="line">    <span class="keyword">int</span> cross_product_1 = v1[<span class="number">0</span>] * v2[<span class="number">1</span>] - v1[<span class="number">1</span>] * v2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> cross_product_2 = v2[<span class="number">0</span>] * v3[<span class="number">1</span>] - v2[<span class="number">1</span>] * v3[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> cross_product_3 = v3[<span class="number">0</span>] * v1[<span class="number">1</span>] - v3[<span class="number">1</span>] * v1[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (cross_product_1 * cross_product_2 &gt;= <span class="number">0</span> &amp;&amp; cross_product_2 * cross_product_3 &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充结果</p><img src="/2019/03/26/Draw-Line/3.png" title="填充"><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><img src="/2019/03/26/Draw-Line/demo.gif" title="动画">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用Bresenham算法画一个三角形边框&quot;&gt;&lt;a href=&quot;#使用Bresenham算法画一个三角形边框&quot; class=&quot;headerlink&quot; title=&quot;使用Bresenham算法画一个三角形边框&quot;&gt;&lt;/a&gt;使用Bresenham算法画一个三角形边框&lt;/
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>GUI and Draw Simple Graphics</title>
    <link href="https://xungerrrr.github.io/2019/03/11/GUI-and-Draw-Simple-Graphics/"/>
    <id>https://xungerrrr.github.io/2019/03/11/GUI-and-Draw-Simple-Graphics/</id>
    <published>2019-03-11T12:45:12.000Z</published>
    <updated>2019-03-14T17:53:57.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用OpenGL-3-3及以上-GLFW画一个简单的三角形"><a href="#使用OpenGL-3-3及以上-GLFW画一个简单的三角形" class="headerlink" title="使用OpenGL(3.3及以上)+GLFW画一个简单的三角形"></a>使用OpenGL(3.3及以上)+GLFW画一个简单的三角形</h2><p>在画三角形之前，首先要初始化GLFW和GLAD，以及创建窗口。这里不详细说明。</p><p>在OpenGL中，3D坐标转换成2D坐标是由图形渲染管线完成的，可以被分成几个阶段，每一个阶段都有专门的运行程序，称为着色器。OpenGL中的着色器是用GLSL语言编写的。在现代OpenGL中，必须定义至少一个顶点着色器和一个片段着色器，因此要编写、编译和链接着色器。</p><h3 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h3><h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><p>画一个简单的三角形，只需要顶点的位置属性。在关键字in后声明一个三维的位置属性，可以实现这个简单的功能。在main函数中将位置转换成四维变量，输出到gl_Position中，就实现了顶点着色器的位置输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h4><p>在片段着色器中，使用关键字out输出一个颜色变量，颜色为(1.0, 0.5, 0.2, 1.0)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FragColor = vec4(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="着色器的编译和链接"><a href="#着色器的编译和链接" class="headerlink" title="着色器的编译和链接"></a>着色器的编译和链接</h3><p>为了实现这一功能，编写一个类，用于着色器的编译、链接和使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shader</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 程序ID</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">    <span class="comment">// 编译和链接</span></span><br><span class="line">    Shader(<span class="keyword">const</span> GLchar* vertexPath, <span class="keyword">const</span> GLchar* fragmentPath);</span><br><span class="line">    <span class="comment">// 使用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在构造函数中，读取着色器文件，并使用glCompileShader编译。以顶点着色器为例，编译过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line"><span class="keyword">int</span> success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(vertexShader);</span><br><span class="line"><span class="comment">// 检查编译状态</span></span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完成后，将两个着色器链接成程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shaderProgram = glCreateProgram();</span><br><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure><h3 id="着色器程序的使用"><a href="#着色器程序的使用" class="headerlink" title="着色器程序的使用"></a>着色器程序的使用</h3><p>调用glUseProgram函数以激活着色器程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Shader::use() &#123;</span><br><span class="line">    glUseProgram(shaderProgram);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顶点数据的输入、绑定和解析"><a href="#顶点数据的输入、绑定和解析" class="headerlink" title="顶点数据的输入、绑定和解析"></a>顶点数据的输入、绑定和解析</h3><p>定义一个数组来存储三角形三个点的坐标数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过顶点缓冲对象（VBO）管理数据。这里的数据是不变的，因此使用GL_STATIC_DRAW。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>此外，还需要调用glVertexAttribPointer，告诉OpenGL怎么解析数组中的数据。解析的时候，每次解析3个元素，跳过3个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="顶点数组对象"><a href="#顶点数组对象" class="headerlink" title="顶点数组对象"></a>顶点数组对象</h3><p>通过绑定VAO，可以将多个VBO集成到顶点数组中，方便多次绘制重复的图形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">glBindVertexArray(VAO);</span><br></pre></td></tr></table></figure><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>使用While循环进行多帧渲染。先激活程序、绑定VAO，然后输入三角形图元，用glDrawArrays生成图形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shader.use();</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><img src="/2019/03/11/GUI-and-Draw-Simple-Graphics/1.png" title="简单三角形"><h2 id="对三角形的三个顶点分别改为红绿蓝。并解释为什么会出现这样的结果"><a href="#对三角形的三个顶点分别改为红绿蓝。并解释为什么会出现这样的结果" class="headerlink" title="对三角形的三个顶点分别改为红绿蓝。并解释为什么会出现这样的结果"></a>对三角形的三个顶点分别改为红绿蓝。并解释为什么会出现这样的结果</h2><h3 id="修改着色器"><a href="#修改着色器" class="headerlink" title="修改着色器"></a>修改着色器</h3><h4 id="顶点着色器-1"><a href="#顶点着色器-1" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><p>为了使三个顶点输出不同的颜色，要在顶点着色器中增加颜色属性。aColor为输入颜色，ourColor为输出颜色。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 aColor;</span><br><span class="line"></span><br><span class="line">out vec3 ourColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="片段着色器-1"><a href="#片段着色器-1" class="headerlink" title="片段着色器"></a>片段着色器</h4><p>片段着色器接收来自顶点着色器的输入，转成vec4后输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec3 ourColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FragColor = vec4(ourColor, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改数组和解析方式"><a href="#修改数组和解析方式" class="headerlink" title="修改数组和解析方式"></a>修改数组和解析方式</h3><p>在数组的每一行添加三个颜色分量数据，表示顶点的颜色：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>     <span class="comment">// 上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解析位置的时候，每次解析3个元素，跳过6个元素；解析颜色的时候，每次解析3个元素，跳过6个元素，开始时跳过3个元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="渲染结果"><a href="#渲染结果" class="headerlink" title="渲染结果"></a>渲染结果</h3><img src="/2019/03/11/GUI-and-Draw-Simple-Graphics/2.png" title="多色三角形"><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>在光栅化的阶段，会产生比指定顶点更多的片段。对于没有定义颜色的片段，会根据片段所处的位置，进行颜色的插值。简单来讲，就是根据位置，对已知顶点的颜色进行线性组合。</p><h2 id="给上述工作添加一个GUI，里面有一个菜单栏，使得可以选择并改变三角形的颜色。"><a href="#给上述工作添加一个GUI，里面有一个菜单栏，使得可以选择并改变三角形的颜色。" class="headerlink" title="给上述工作添加一个GUI，里面有一个菜单栏，使得可以选择并改变三角形的颜色。"></a>给上述工作添加一个GUI，里面有一个菜单栏，使得可以选择并改变三角形的颜色。</h2><h3 id="初始化ImGUI"><a href="#初始化ImGUI" class="headerlink" title="初始化ImGUI"></a>初始化ImGUI</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ImGui::CreateContext();</span><br><span class="line">ImGuiIO &amp;io = ImGui::GetIO(); (<span class="keyword">void</span>)io;</span><br><span class="line">ImGui::StyleColorsDark();</span><br><span class="line">ImGui_ImplGlfw_InitForOpenGL(window, <span class="literal">true</span>);</span><br><span class="line">ImGui_ImplOpenGL3_Init(<span class="string">"#version 330"</span>);</span><br></pre></td></tr></table></figure><h3 id="定义一个向量，存储三个顶点的颜色值"><a href="#定义一个向量，存储三个顶点的颜色值" class="headerlink" title="定义一个向量，存储三个顶点的颜色值"></a>定义一个向量，存储三个顶点的颜色值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImVec4&gt; colors;</span><br><span class="line">colors.push_back(ImVec4(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">colors.push_back(ImVec4(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">colors.push_back(ImVec4(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure><h3 id="在渲染循环里，设置ImGUI样式，生成三个颜色选择器"><a href="#在渲染循环里，设置ImGUI样式，生成三个颜色选择器" class="headerlink" title="在渲染循环里，设置ImGUI样式，生成三个颜色选择器"></a>在渲染循环里，设置ImGUI样式，生成三个颜色选择器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ImGui_ImplOpenGL3_NewFrame();</span><br><span class="line">ImGui_ImplGlfw_NewFrame();</span><br><span class="line">ImGui::NewFrame();</span><br><span class="line"></span><br><span class="line">ImGui::Begin(<span class="string">"Color Setting"</span>);</span><br><span class="line">ImGui::ColorEdit3(<span class="string">"Left corner color"</span>, (<span class="keyword">float</span>*)&amp;colors[<span class="number">0</span>]);</span><br><span class="line">ImGui::ColorEdit3(<span class="string">"Right corner color"</span>, (<span class="keyword">float</span>*)&amp;colors[<span class="number">1</span>]);</span><br><span class="line">ImGui::ColorEdit3(<span class="string">"Top corner color"</span>, (<span class="keyword">float</span>*)&amp;colors[<span class="number">2</span>]);</span><br><span class="line">ImGui::End();</span><br></pre></td></tr></table></figure><h3 id="根据选择的颜色，改变数组元素的值，达到修改颜色的目的。修改后要重新绑定数据。"><a href="#根据选择的颜色，改变数组元素的值，达到修改颜色的目的。修改后要重新绑定数据。" class="headerlink" title="根据选择的颜色，改变数组元素的值，达到修改颜色的目的。修改后要重新绑定数据。"></a>根据选择的颜色，改变数组元素的值，达到修改颜色的目的。修改后要重新绑定数据。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    vertices[<span class="number">6</span> * i + <span class="number">3</span>] = colors[i].x;</span><br><span class="line">    vertices[<span class="number">6</span> * i + <span class="number">4</span>] = colors[i].y;</span><br><span class="line">    vertices[<span class="number">6</span> * i + <span class="number">5</span>] = colors[i].z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染-1"><a href="#渲染-1" class="headerlink" title="渲染"></a>渲染</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImGui::Render();</span><br><span class="line">ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());</span><br></pre></td></tr></table></figure><img src="/2019/03/11/GUI-and-Draw-Simple-Graphics/3.png" title="GUI"><h2 id="使用EBO-Element-Buffer-Object-绘制多个三角形"><a href="#使用EBO-Element-Buffer-Object-绘制多个三角形" class="headerlink" title="使用EBO(Element Buffer Object)绘制多个三角形"></a>使用EBO(Element Buffer Object)绘制多个三角形</h2><h3 id="添加三角形和对应的索引"><a href="#添加三角形和对应的索引" class="headerlink" title="添加三角形和对应的索引"></a>添加三角形和对应的索引</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三个三角形</span></span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">    <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="EBO的创建和绑定"><a href="#EBO的创建和绑定" class="headerlink" title="EBO的创建和绑定"></a>EBO的创建和绑定</h3><p>缓冲类型是GL_ELEMENT_ARRAY_BUFFER</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><h3 id="渲染-2"><a href="#渲染-2" class="headerlink" title="渲染"></a>渲染</h3><p>渲染时，将glDrawArrays改为glDrawElements，使用EBO中的索引进行渲染。参数分别是图元、顶点数量、索引数据类型和索引偏移量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><img src="/2019/03/11/GUI-and-Draw-Simple-Graphics/4.png" title="多个三角形"><h2 id="绘制其他的图元，除了三角形，还有点、线等"><a href="#绘制其他的图元，除了三角形，还有点、线等" class="headerlink" title="绘制其他的图元，除了三角形，还有点、线等"></a>绘制其他的图元，除了三角形，还有点、线等</h2><h3 id="扩充数组"><a href="#扩充数组" class="headerlink" title="扩充数组"></a>扩充数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三个三角形</span></span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一条线</span></span><br><span class="line">    <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二条线</span></span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点</span></span><br><span class="line">    <span class="number">-0.75f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">0.75f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="渲染-3"><a href="#渲染-3" class="headerlink" title="渲染"></a>渲染</h3><p>使用glDrawArrays进行渲染，传入图元GL_LINES绘制直线，传入图元GL_POINTS绘制点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_LINES, <span class="number">9</span>, <span class="number">4</span>);</span><br><span class="line">glDrawArrays(GL_POINTS, <span class="number">13</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>如下图，新增两条白线和两个白点：</p><img src="/2019/03/11/GUI-and-Draw-Simple-Graphics/5.png" title="线和点"><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p><a href="https://github.com/Xungerrrr/SYSU-CG/tree/master/GUI%20and%20Draw%20Simple%20Graphics" target="_blank" rel="noopener">https://github.com/Xungerrrr/SYSU-CG/tree/master/GUI%20and%20Draw%20Simple%20Graphics</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用OpenGL-3-3及以上-GLFW画一个简单的三角形&quot;&gt;&lt;a href=&quot;#使用OpenGL-3-3及以上-GLFW画一个简单的三角形&quot; class=&quot;headerlink&quot; title=&quot;使用OpenGL(3.3及以上)+GLFW画一个简单的三角形&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>软件项目与知识团队管理基础</title>
    <link href="https://xungerrrr.github.io/2019/03/10/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    <id>https://xungerrrr.github.io/2019/03/10/软件项目与知识团队管理基础/</id>
    <published>2019-03-10T14:41:32.000Z</published>
    <updated>2019-03-24T15:37:09.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><h3 id="用简短的语言给出对分析、设计的理解。"><a href="#用简短的语言给出对分析、设计的理解。" class="headerlink" title="用简短的语言给出对分析、设计的理解。"></a>用简短的语言给出对分析、设计的理解。</h3><ul><li>分析强调的是对问题和需求的调查研究，而不是解决方案。例如，如果需要一个新的在线交易系统，它会怎样被使用？它有什么功能？分析是做正确的事情(Do the right thing)。</li><li>设计强调的是满足需求的概念上的解决方案（在软件方面和硬件方面），而不是其实现。例如，对数据库模式和软件对象的描述。设计是把事情做对（Do the thing right)。</li></ul><h3 id="用一句话描述面向对象的分析与设计的优势。"><a href="#用一句话描述面向对象的分析与设计的优势。" class="headerlink" title="用一句话描述面向对象的分析与设计的优势。"></a>用一句话描述面向对象的分析与设计的优势。</h3><p>能够构建与真实世界相似的问题模型和对象，符合人在世界中的思维方式，使得人能够更好地理解和设计。</p><h3 id="简述-UML（统一建模语言）的作用。考试考哪些图？"><a href="#简述-UML（统一建模语言）的作用。考试考哪些图？" class="headerlink" title="简述 UML（统一建模语言）的作用。考试考哪些图？"></a>简述 UML（统一建模语言）的作用。考试考哪些图？</h3><p>将分析和设计的结果可视化，将问题抽象成容易理解的可视化模型。</p><p>UML图分四类：</p><ul><li>用例图：用户角度：功能、执行者</li><li>静态图：系统静态结构<ul><li>类图：概念及关系</li><li>对象图：某种状态或时间段内，系统中活跃的对象及其关系</li><li>包图：描述系统的分解结构</li></ul></li><li>行为图：系统的动态行为<ul><li>交互图：描述对象间的消息传递<ul><li>顺序图：强调对象间消息发送的时序</li><li>合作图：强调对象间的动态协作关系</li></ul></li><li>状态图：对象的动态行为。状态-事件-状态迁移-响应动作</li><li>活动图：描述系统为完成某功能而执行的操作序列</li></ul></li><li>实现图：描述系统的组成和分布情况<ul><li>构件图：组成部件及其关系</li><li>部署图：物理体系结构及与软件单元的对应关系</li></ul></li></ul><h3 id="从软件本质的角度，解释软件范围（需求）控制的可行性"><a href="#从软件本质的角度，解释软件范围（需求）控制的可行性" class="headerlink" title="从软件本质的角度，解释软件范围（需求）控制的可行性"></a>从软件本质的角度，解释软件范围（需求）控制的可行性</h3><p>软件的本质决定了软件开发的困难，Brook总结其本质特性为四个：复杂性、不一致性、可变性、不可见性。因此，软件范围多数情况下对于客户和开发者都是模糊的，这形成软件产品与其他产品不同的开发过程。在保证需求的前提下，可以砍去一些客户都没思考清晰的业务，通过多次反馈和迭代进行开发和升级，使得软件的范围和需求受控。</p><h2 id="项目管理实践"><a href="#项目管理实践" class="headerlink" title="项目管理实践"></a>项目管理实践</h2><h3 id="看板使用练习（提交看板执行结果贴图，建议使用-Git-project）"><a href="#看板使用练习（提交看板执行结果贴图，建议使用-Git-project）" class="headerlink" title="看板使用练习（提交看板执行结果贴图，建议使用 Git project）"></a>看板使用练习（提交看板执行结果贴图，建议使用 Git project）</h3><ul><li>使用截图工具（pnsg 格式输出），展现你团队的任务 Kanban</li><li>每个人的任务是明确的。必须一周后可以看到具体结果</li><li>每个人的任务是 1-2 项</li><li>至少包含一个团队活动任务</li></ul><img src="/2019/03/10/软件项目与知识团队管理基础/kanban.png" title="看板"><h3 id="UML-绘图工具练习（提交贴图，必须使用-UMLet）"><a href="#UML-绘图工具练习（提交贴图，必须使用-UMLet）" class="headerlink" title="UML 绘图工具练习（提交贴图，必须使用 UMLet）"></a>UML 绘图工具练习（提交贴图，必须使用 UMLet）</h3><p>《UML和模式应用（原书第3版）》，P6，图1-3：</p><img src="/2019/03/10/软件项目与知识团队管理基础/uml.png" title="uml"><p>各模块参数：</p><img src="/2019/03/10/软件项目与知识团队管理基础/1.png" title="DiceGame"><img src="/2019/03/10/软件项目与知识团队管理基础/2.png" title="Die"><img src="/2019/03/10/软件项目与知识团队管理基础/3.png" title="Arrow">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简答题&quot;&gt;&lt;a href=&quot;#简答题&quot; class=&quot;headerlink&quot; title=&quot;简答题&quot;&gt;&lt;/a&gt;简答题&lt;/h2&gt;&lt;h3 id=&quot;用简短的语言给出对分析、设计的理解。&quot;&gt;&lt;a href=&quot;#用简短的语言给出对分析、设计的理解。&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="SE" scheme="https://xungerrrr.github.io/tags/SE/"/>
    
  </entry>
  
  <entry>
    <title>Learn About CG</title>
    <link href="https://xungerrrr.github.io/2019/03/04/Learn-About-CG/"/>
    <id>https://xungerrrr.github.io/2019/03/04/Learn-About-CG/</id>
    <published>2019-03-04T06:18:30.000Z</published>
    <updated>2019-03-14T17:57:57.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="谈谈自己对计算机图形学的理解。"><a href="#谈谈自己对计算机图形学的理解。" class="headerlink" title="谈谈自己对计算机图形学的理解。"></a>谈谈自己对计算机图形学的理解。</h2><p>我对计算机图形学的理解是，计算机图形学是一门利用计算机对二维或三维图形进行表示、处理、计算、显示和交互的学科。通过各种建模方法，在计算机中建立几何图形的模型，这是图形的表示过程。通过渲染技术，将图形模型转换成显示器的栅格形式，或者是转换成全息图像形式，这是图形的处理、计算和显示过程。通过各种输入工具，改变图形的状态，这是交互过程。这些都是计算机图形学研究的范畴。</p><h2 id="什么是OpenGL？OpenGL-ES？Web-GL？Vulkan？DirectX？"><a href="#什么是OpenGL？OpenGL-ES？Web-GL？Vulkan？DirectX？" class="headerlink" title="什么是OpenGL？OpenGL ES？Web GL？Vulkan？DirectX？"></a>什么是OpenGL？OpenGL ES？Web GL？Vulkan？DirectX？</h2><ul><li>OpenGL是一个API（Application Programming Interface，应用程序编程接口），是跨编程语言及跨平台的接口，包含了一系列可以操作图形、图像的函数，用于渲染2D和3D图形。更确切地说，OpenGL是一个规范，规定了每个函数的用法和输出值，具体的实现一般由显卡厂商完成。</li><li>OpenGL ES（OpenGL for Embedded Systems）是OpenGL规范的子集，用于嵌入式设备的图形渲染。相比于OpenGL，OpenGL ES去除了一些非必要的特性，是OpenGL的简化版本。</li><li>WebGL是一种绘图标准，将JavaScript和OpenGL ES结合在一起，使得网页可以调用系统显卡进行硬件加速渲染，从而在浏览器中流畅地显示3D图形。</li><li>Vulkan是另一种跨平台的绘图应用程序接口，提供了许多比OpenGL更加先进的特性，性能比OpenGL要更好，是OpenGL的替代者。</li><li>DirectX是由微软开发的多媒体编程接口，提供了显示、声音、输入、网络等API，功能十分丰富，不只是一个图形编程接口，用于Windows系统多媒体应用开发。</li></ul><h2 id="gl-h-glu-h-glew-h的作用分别是什么？"><a href="#gl-h-glu-h-glew-h的作用分别是什么？" class="headerlink" title="gl.h glu.h glew.h的作用分别是什么？"></a>gl.h glu.h glew.h的作用分别是什么？</h2><ul><li>gl.h是OpenGL 1.1的基础头文件，包含了OpenGL 1.1的功能。如果需要使用新功能，需要添加OpenGL的扩展库。</li><li>glu.h是OpenGL Utilities库，包含了一些方便的函数，但是已经过时，现在一般不用。</li><li>glew.h是OpenGL Extension Wrangler Library，用于使用OpenGL的扩展功能，其中包含了gl.h。OpenGL版本众多，因此编译的时候无法将函数的位置确定下来，需要在运行时查询。借助glew.h，可以在运行时根据硬件方便地管理OpenGL的函数指针，定位函数的位置。</li></ul><h2 id="使用GLFW和freeglut的目的是什么？"><a href="#使用GLFW和freeglut的目的是什么？" class="headerlink" title="使用GLFW和freeglut的目的是什么？"></a>使用GLFW和freeglut的目的是什么？</h2><p>创建OpenGL上下文、创建显示窗口和处理用户输入，在每个系统上都有不一样的操作。作为一个跨平台API，OpenGL将这部分功能抽象出去，因此需要我们去手动处理。使用GLFW或者freeglut，可以方便地创建OpenGL上下文、定义窗口参数和处理用户输入，而不需要使用操作系统复杂的API，节省编程时间和难度。</p><h2 id="结合上述参考链接，选择一个SIGGRAPH-2017-2018上你最喜欢的专题，介绍该专题是做什么的，使用了什么CG技术？"><a href="#结合上述参考链接，选择一个SIGGRAPH-2017-2018上你最喜欢的专题，介绍该专题是做什么的，使用了什么CG技术？" class="headerlink" title="结合上述参考链接，选择一个SIGGRAPH 2017/2018上你最喜欢的专题，介绍该专题是做什么的，使用了什么CG技术？"></a>结合上述参考链接，选择一个SIGGRAPH 2017/2018上你最喜欢的专题，介绍该专题是做什么的，使用了什么CG技术？</h2><p>我对SIGGRAPH 2018中的Computational photos and videos专题比较感兴趣。这个专题做的是计算摄影方面的研究，目的是利用有限的图片信息，计算出场景的深度信息，也就是生成三维的场景。这个专题中有两篇研究论文。第一篇是<a href="http://delivery.acm.org/10.1145/3210000/3201329/a64-wadhwa.pdf?ip=120.236.174.139&amp;id=3201329&amp;acc=OPENTOC&amp;key=BF85BBA5741FDC6E%2E3D07CFA6C3F555EA%2E4D4702B0C3E38B35%2E383ADA7593775D6F&amp;__acm__=1551716722_7848def64dc95e9252115c00fad0b02f" target="_blank" rel="noopener"><em>Synthetic Depth-of-Field with a Single-Camera Mobile Phone</em></a>，实现了利用单个手机摄像头计算出照片的景深信息，得到类似于单反镜头的背景虚化效果，由Google Research团队发表，目前已用于Google Pixel系列手机中的人像模式功能。第二篇是<a href="http://delivery.acm.org/10.1145/3210000/3201323/a65-zhou.pdf?ip=120.236.174.139&amp;id=3201323&amp;acc=OPENTOC&amp;key=BF85BBA5741FDC6E%2E3D07CFA6C3F555EA%2E4D4702B0C3E38B35%2E383ADA7593775D6F&amp;__acm__=1551716806_39a7933ec8e03f668f238b0fc39fe828" target="_blank" rel="noopener"><em>Stereo Magnification: Learning view synthesis using multiplane images</em></a>，利用双镜头拍摄的两张照片，就可以生成一个动画，模拟出在三维场景中运动的场景。该专题运用了CG中的建模和渲染技术，都是先计算出场景的景深信息，构建出场景的模型，然后渲染成高真实度的照片和动画。两篇论文都涉及到基于图像的渲染技术（Image-based rendering）。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <a href="http://staff.ustc.edu.cn/~lgliu/Resources/CG/What_is_CG.htm" target="_blank" rel="noopener">什么是计算机图形学？</a><br>[2] <a href="https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/" target="_blank" rel="noopener">什么是OpenGL</a><br>[3] <a href="https://www.siggraph.org//learn/conference-content" target="_blank" rel="noopener">SIGGRAGPH Conference Content</a><br>[4] <a href="http://kesen.realtimerendering.com/sig2017.html" target="_blank" rel="noopener">SIGGRAPH 2018专题与论文集合</a><br>[5] <a href="https://www.siggraph.org/sites/default/files/ACM%20Transactions%20on%20Graphics%20Volume%2037%20Issue%204%20August%202018.html" target="_blank" rel="noopener">SIGGRAPH 2018论文集</a><br>[6] <a href="https://www.leiphone.com/news/201808/fX05lhGQo2X50Wya.html" target="_blank" rel="noopener">SIGGRAPH 2018：VR凉凉？逛完展你就知道了</a><br>[7] <a href="https://zhuanlan.zhihu.com/p/38082963" target="_blank" rel="noopener">SIGGRAPH 2018 不能错过的八大精彩</a><br>[8] <a href="https://www.zhihu.com/question/60903441?from=profile_question_card://www.siggraph.org/sites/default/files/sa-17-tog-open-access.html" target="_blank" rel="noopener">SIGGRAPH 2017 有啥有意思的 project？</a><br>[9] <a href="https://www.leiphone.com/news/201707/ZSLKstyMCMgP1hO3.html" target="_blank" rel="noopener">SIGGRAPH 2017：一窥AR/VR最新趋势</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;谈谈自己对计算机图形学的理解。&quot;&gt;&lt;a href=&quot;#谈谈自己对计算机图形学的理解。&quot; class=&quot;headerlink&quot; title=&quot;谈谈自己对计算机图形学的理解。&quot;&gt;&lt;/a&gt;谈谈自己对计算机图形学的理解。&lt;/h2&gt;&lt;p&gt;我对计算机图形学的理解是，计算机图形
      
    
    </summary>
    
    
      <category term="Computer Graphics" scheme="https://xungerrrr.github.io/tags/Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>软件的本质与软件工程科学</title>
    <link href="https://xungerrrr.github.io/2019/03/03/%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%A7%91%E5%AD%A6/"/>
    <id>https://xungerrrr.github.io/2019/03/03/软件的本质与软件工程科学/</id>
    <published>2019-03-03T05:04:15.000Z</published>
    <updated>2019-03-13T09:22:36.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件工程的定义"><a href="#软件工程的定义" class="headerlink" title="软件工程的定义"></a>软件工程的定义</h2><blockquote><p>Software engineering is “(1) the application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software, that is, the application of engineering to software,” and “(2) the study of approaches as in (1).” – IEEE Standard 610.12</p></blockquote><p>软件工程是，系统化、规范化、可度量化的方法在软件开发、运行和维护中的应用，即工程化方法在软件中的应用，以及对这些方法的研究。</p><h2 id="解释导致software-crisis本质原因、表现，述说克服软件危机的方法"><a href="#解释导致software-crisis本质原因、表现，述说克服软件危机的方法" class="headerlink" title="解释导致software crisis本质原因、表现，述说克服软件危机的方法"></a>解释导致software crisis本质原因、表现，述说克服软件危机的方法</h2><h3 id="本质原因"><a href="#本质原因" class="headerlink" title="本质原因"></a>本质原因</h3><p>导致软件危机的本质原因是计算机硬件的飞速发展。根据软件构造性成本模型COCOMO（Constructive Cost Model），软件的成本与代码行的数量成指数关系。计算机的能力越强大，软件编程就越复杂，软件成本呈指数爆炸式增长，软件开发的效率也逐渐变低。传统的软件开发方法不能适应硬件的高速发展，导致了软件危机的出现。</p><h3 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h3><ul><li>项目运行超出预算</li><li>项目运行超出时间</li><li>软件效率低</li><li>软件质量差</li><li>软件不匹配需求</li><li>项目难以管理和维护</li><li>软件无法交付</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>克服软件危机的方法有：构建软件工程知识体系（SWEBoK）、对企业的能力成熟度进行评估、制定软件工程管理标准、使用实践管理工具总结实践经验等等。</p><h2 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h2><p>在软件工程中，软件生命周期是指将软件开发工作在时间维度上分割成不同部分，来提高设计、产品管理和项目管理水平的过程，也称为软件开发过程，其各个阶段实现了软件的需求定义与分析、设计、实现、测试、交付和维护。常见的过程模型有瀑布模型、螺旋模型、敏捷的模型等等。其具体过程有：</p><ul><li>问题定义：确定解决的具体问题是什么。</li><li>可行性研究：从经济、技术、法律等多方面进行可行性分析。</li><li>需求分析：详细分析项目的需求和约束条件。</li><li>开发阶段<ul><li>概要设计：设计整体框架，定义模块和接口。</li><li>详细设计：设计每个模块的具体要求。</li><li>实现：具体的代码实现。</li><li>测试</li></ul></li><li>维护：包含改正性维护、适应性维护、完善性维护、预防性维护等方面。</li></ul><h2 id="SWEBoK的15个知识域"><a href="#SWEBoK的15个知识域" class="headerlink" title="SWEBoK的15个知识域"></a>SWEBoK的15个知识域</h2><ul><li>实践知识域（11个）<ul><li>软件需求：为解决真实问题，软件产品所需的要求和约束。</li><li>软件设计：软件设计包含了需求分析、架构设计、成分设计、接口设计等设计过程以及设计的结果。</li><li>软件构建：结合详细设计、编码、单元测试、集成测试等过程，对软件进行具体的构建和调试。</li><li>软件测试：评估产品质量并通过识别缺陷来改进产品质量。具体包括测试的基础知识、测试技术、人机交互接口测试、测试手段和现状分析等。</li><li>软件维护：提升性能、更新软件和错误修正，分别对应完善性、适应性和改正性维护。</li><li>软件配置管理：是在不同时间点识别系统配置的规则，用于系统地控制配置的改变，以及在整个软件生命周期中维持配置的完整性和可追溯性。</li><li>软件工程管理：涉及计划、协调、测量、报告和控制项目，以确保软件的开发和维护是系统化、规范化和量化的。</li><li>软件工程过程：也叫软件生命周期，涵盖其定义、实施、评估、测量、管理和改进。</li><li>软件工程模型和方法：也叫软件开发模型，覆盖多个软件生命周期阶段。能直观表达软件开发的全过程。</li><li>软件质量：包括软件质量基础知识、质量管理的流程和现实考虑。</li><li>软件工程专业实践：软件工程师必备的软件工程知识、技能和态度，要求工程师做到专业化、负责任和符合道德准则。</li></ul></li><li>教育需求知识域（4个）<ul><li>软件工程经济学：关注的是在软件业务环境中的决策，是商业决策与技术决策的统一。</li><li>计算基础：覆盖了计算机科学的基础知识，例如算法、抽象、编程基础、计算机组成、操作系统和网络等。</li><li>数学基础：数学基础知识，包括线性代数、离散数学、概率论、数论等。</li><li>工程基础：工程化技术的基础知识，例如统计方法、测量方法、仿真与建模等。</li></ul></li></ul><h2 id="简单解释CMMI的五个级别"><a href="#简单解释CMMI的五个级别" class="headerlink" title="简单解释CMMI的五个级别"></a>简单解释CMMI的五个级别</h2><ul><li>Level 1 – Initial：无序，自发生产模式。</li><li>Level 2 – Managed：有活力，项目级管理模式。</li><li>Level 3 – Defined：受控，企业级组织方式。</li><li>Level 4 – Quantitatively Managed：量化，数据化管理模式，精准管理。</li><li>Level 5 – Optimizing：优化，大型企业运行方式，高效率完成大项目开发。</li></ul><img src="/2019/03/03/软件的本质与软件工程科学/Maturity%20levels.png" title="Maturity Levels"><h2 id="用自己语言简述SWEBok或CMMI"><a href="#用自己语言简述SWEBok或CMMI" class="headerlink" title="用自己语言简述SWEBok或CMMI"></a>用自己语言简述SWEBok或CMMI</h2><p>CMMI（Capability Maturity Model Integration），能力成熟度模型集成，是度量一个企业或组织在开发、服务、采购等层面上的成熟度的集成方法，最早主要面向软件工程领域。CMMI的目的在于帮助企业进行能力评估，并协助提升企业的绩效。在不同的成熟度中，CMMI给出了对应的过程区域，这些过程区域有助于企业维持最佳的运作效率，同时有利于企业向更高的成熟度进步。许多企业在进行CMMI评价的过程中，了解了自己所处的位置，也发现了自己发展的潜力所在。</p><p>CMMI存在持续和分阶段两种表现方式。其中，分阶段式中有五个等级，对应的等级有不同的过程区域。CMMI一共有16个核心过程区域，覆盖了企业开发、服务、采购等层面的大部分内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;软件工程的定义&quot;&gt;&lt;a href=&quot;#软件工程的定义&quot; class=&quot;headerlink&quot; title=&quot;软件工程的定义&quot;&gt;&lt;/a&gt;软件工程的定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Software engineering is “(1) the appl
      
    
    </summary>
    
    
      <category term="SE" scheme="https://xungerrrr.github.io/tags/SE/"/>
    
  </entry>
  
  <entry>
    <title>Git日常使用总结</title>
    <link href="https://xungerrrr.github.io/2018/09/16/Git%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://xungerrrr.github.io/2018/09/16/Git日常使用总结/</id>
    <published>2018-09-16T05:44:10.000Z</published>
    <updated>2019-03-14T05:49:43.263Z</updated>
    
    <content type="html"><![CDATA[<h3 id="取得项目的-Git-仓库"><a href="#取得项目的-Git-仓库" class="headerlink" title="取得项目的 Git 仓库"></a>取得项目的 Git 仓库</h3><ul><li><p>在工作目录中初始化新仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></li><li><p>从现有仓库克隆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone &lt;url&gt;</span><br></pre></td></tr></table></figure><p>也可以自定义项目目录名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone &lt;url&gt; &lt;name&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="将更新记录到仓库"><a href="#将更新记录到仓库" class="headerlink" title="将更新记录到仓库"></a>将更新记录到仓库</h3><ul><li><p>检查当前文件状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><p>查看尚未暂存的文件更新了哪些部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure><p>加上-cached选项，查看已经暂存起来的文件和上次提交时的快照之间的差异：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached</span><br></pre></td></tr></table></figure></li><li><p>跟踪新文件和暂存已修改文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add &lt;file&gt;</span><br></pre></td></tr></table></figure></li><li><p>忽略某些文件</p><p>创建.gitignore文件。.gitignore文件的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line"># 忽略所有 .a 结尾的文件</span><br><span class="line">*.a</span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!lib.a</span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"># 忽略 build/ 目录下的所有文件</span><br><span class="line">build/</span><br><span class="line"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># 忽略 doc/ 目录下所有扩展名为 txt 的文件</span><br><span class="line">doc/**/*.txt</span><br></pre></td></tr></table></figure></li><li><p>提交更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;&lt;message&gt;&quot;</span><br></pre></td></tr></table></figure><p>加上-a选项，跳过使用暂存区域：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -m &quot;&lt;message&gt;&quot;</span><br></pre></td></tr></table></figure></li><li><p>移除文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm &lt;file&gt;</span><br></pre></td></tr></table></figure><p>加上–cached选项，移除跟踪但不删除文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached &lt;file&gt;</span><br></pre></td></tr></table></figure></li><li><p>移动文件（重命名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv &lt;file_from&gt; &lt;file_to&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-p                # 按补丁格式显示每个更新之间的差异。</span><br><span class="line">--word-diff       # 按 word diff 格式显示差异。</span><br><span class="line">--stat            # 显示每次更新的文件修改统计信息。</span><br><span class="line">--shortstat       # 只显示 --stat 中最后的行数修改添加移除统计。</span><br><span class="line">--name-only       # 仅在提交信息后显示已修改的文件清单。</span><br><span class="line">--name-status     # 显示新增、修改、删除的文件清单。</span><br><span class="line">--abbrev-commit   # 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</span><br><span class="line">--relative-date   # 使用较短的相对时间显示（比如，“2 weeks ago”）。</span><br><span class="line">--graph           # 显示 ASCII 图形表示的分支合并历史。</span><br><span class="line">--pretty          # 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</span><br><span class="line">--oneline         # --pretty=oneline --abbrev-commit 的简化用法。</span><br><span class="line">-(n)              # 仅显示最近的 n 条提交</span><br><span class="line">--since, --after  # 仅显示指定时间之后的提交。</span><br><span class="line">--until, --before # 仅显示指定时间之前的提交。</span><br><span class="line">--author          # 仅显示指定作者相关的提交。</span><br><span class="line">--committer       # 仅显示指定提交者相关的提交。</span><br></pre></td></tr></table></figure><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><ul><li><p>重新提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure></li><li><p>取消已经暂存的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure></li><li><p>取消对文件的修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul><li><p>查看当前的远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br></pre></td></tr></table></figure><p>加上-v选项，显示对应的克隆地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure></li><li><p>添加远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &lt;shortname&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></li><li><p>从远程仓库抓取数据</p><p>不合并分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch &lt;remote-name&gt;</span><br></pre></td></tr></table></figure><p>合并分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;remote-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>推送数据到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看远程仓库的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show &lt;remote-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>远程仓库的删除和重命名</p><p>重命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename &lt;old-name&gt; &lt;new-name&gt;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm &lt;remote-name&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;取得项目的-Git-仓库&quot;&gt;&lt;a href=&quot;#取得项目的-Git-仓库&quot; class=&quot;headerlink&quot; title=&quot;取得项目的 Git 仓库&quot;&gt;&lt;/a&gt;取得项目的 Git 仓库&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在工作目录中初始化新仓库&lt;/p&gt;
&lt;fig
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Learning</title>
    <link href="https://xungerrrr.github.io/2018/09/10/Android-Learning/"/>
    <id>https://xungerrrr.github.io/2018/09/10/Android-Learning/</id>
    <published>2018-09-10T06:16:49.000Z</published>
    <updated>2019-03-14T06:31:09.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android开发项目汇总"><a href="#Android开发项目汇总" class="headerlink" title="Android开发项目汇总"></a>Android开发项目汇总</h1><blockquote><p>这是中山大学2018秋季学期「手机平台应用开发」的项目汇总。</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="Project-1"><a href="#Project-1" class="headerlink" title="Project 1"></a>Project 1</h3><ul><li><a href="https://github.com/Xungerrrr/SYSU-Android/tree/master/Project%201" target="_blank" rel="noopener">个人项目 1 - 中山大学智慧健康服务平台应用开发</a></li></ul><h3 id="Project-2"><a href="#Project-2" class="headerlink" title="Project 2"></a>Project 2</h3><ul><li><a href="https://github.com/Xungerrrr/SYSU-Android/tree/master/Project%202" target="_blank" rel="noopener">个人项目 2 - 中山大学智慧健康服务平台应用开发</a></li></ul><h3 id="Project-3"><a href="#Project-3" class="headerlink" title="Project 3"></a>Project 3</h3><ul><li><a href="https://github.com/Xungerrrr/SYSU-Android/tree/master/Project%203" target="_blank" rel="noopener">个人项目 3 - 数据存储应用开发</a></li></ul><h3 id="Project-4"><a href="#Project-4" class="headerlink" title="Project 4"></a>Project 4</h3><ul><li><a href="https://github.com/Xungerrrr/SYSU-Android/tree/master/Project%204" target="_blank" rel="noopener">个人项目 4 - 简单音乐播放器应用开发</a></li></ul><h3 id="Project-5"><a href="#Project-5" class="headerlink" title="Project 5"></a>Project 5</h3><ul><li><a href="https://github.com/Xungerrrr/SYSU-Android/tree/master/Project%205" target="_blank" rel="noopener">个人项目 5 - 网络与Web服务</a></li></ul><h3 id="Midterm-Project"><a href="#Midterm-Project" class="headerlink" title="Midterm Project"></a>Midterm Project</h3><ul><li><a href="https://github.com/Xungerrrr/SYSU-Android/tree/master/Midterm" target="_blank" rel="noopener">期中项目 - 王者荣耀英雄大全</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android开发项目汇总&quot;&gt;&lt;a href=&quot;#Android开发项目汇总&quot; class=&quot;headerlink&quot; title=&quot;Android开发项目汇总&quot;&gt;&lt;/a&gt;Android开发项目汇总&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这是中山大学2018秋季学
      
    
    </summary>
    
    
      <category term="Android" scheme="https://xungerrrr.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Unity 3D - 人机坦克大战</title>
    <link href="https://xungerrrr.github.io/2018/06/19/Unity-3D-%E4%BA%BA%E6%9C%BA%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98/"/>
    <id>https://xungerrrr.github.io/2018/06/19/Unity-3D-人机坦克大战/</id>
    <published>2018-06-19T15:22:32.000Z</published>
    <updated>2018-06-20T01:26:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="游戏要求"><a href="#游戏要求" class="headerlink" title="游戏要求"></a>游戏要求</h2><ul><li>使用 “感知 - 思考 - 行为” 模型，建模 AI 坦克</li><li>场景中要放置一些障碍阻挡对手视线</li><li>坦克需要放置一个矩阵包围盒触发器，以保证 AI 坦克能使用射线探测对手方位</li><li>AI 坦克必须在有目标条件下使用导航，并能绕过障碍。（失去目标时策略自己思考）</li><li>实现人机对战</li></ul><h2 id="游戏实现"><a href="#游戏实现" class="headerlink" title="游戏实现"></a>游戏实现</h2><p>未完待续……</p><h2 id="游戏视频"><a href="#游戏视频" class="headerlink" title="游戏视频"></a>游戏视频</h2><p><a href="http://www.iqiyi.com/w_19ryzvaf0t.html" target="_blank" rel="noopener">http://www.iqiyi.com/w_19ryzvaf0t.html</a></p><h2 id="游戏项目"><a href="#游戏项目" class="headerlink" title="游戏项目"></a>游戏项目</h2><p><a href="https://github.com/Xungerrrr/3D-Game-Programming-and-Design/tree/Homework-9" target="_blank" rel="noopener">传送门</a></p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>[1] <a href="http://www.chenxd59.cn/?p=213" target="_blank" rel="noopener">Unity3D Note8——使用 NavMesh 实现坦克大战游戏</a></p><p><em><a href="/2018/03/30/Unity-3D-Learning/" title="返回 Unity 3D Learning">返回 Unity 3D Learning</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;游戏要求&quot;&gt;&lt;a href=&quot;#游戏要求&quot; class=&quot;headerlink&quot; title=&quot;游戏要求&quot;&gt;&lt;/a&gt;游戏要求&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用 “感知 - 思考 - 行为” 模型，建模 AI 坦克&lt;/li&gt;
&lt;li&gt;场景中要放置一些障碍阻挡对手视线&lt;
      
    
    </summary>
    
      <category term="Unity" scheme="https://xungerrrr.github.io/categories/Unity/"/>
    
    
      <category term="Unity" scheme="https://xungerrrr.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity 3D - 汽车尾气模拟</title>
    <link href="https://xungerrrr.github.io/2018/05/29/Unity-3D-%E6%B1%BD%E8%BD%A6%E5%B0%BE%E6%B0%94%E6%A8%A1%E6%8B%9F/"/>
    <id>https://xungerrrr.github.io/2018/05/29/Unity-3D-汽车尾气模拟/</id>
    <published>2018-05-29T15:06:53.000Z</published>
    <updated>2018-06-19T15:25:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="粒子系统设计"><a href="#粒子系统设计" class="headerlink" title="粒子系统设计"></a>粒子系统设计</h1><p>新建粒子系统，设定粒子材料为 ParticleSmokeBlack ，并修改参数如下：</p><h2 id="修改-Shape-的-形状和半径参数"><a href="#修改-Shape-的-形状和半径参数" class="headerlink" title="修改 Shape 的 形状和半径参数"></a>修改 Shape 的 形状和半径参数</h2><img src="/2018/05/29/Unity-3D-汽车尾气模拟/Shape.png" title="Shape"><h2 id="修改粒子模块基本参数如下"><a href="#修改粒子模块基本参数如下" class="headerlink" title="修改粒子模块基本参数如下"></a>修改粒子模块基本参数如下</h2><img src="/2018/05/29/Unity-3D-汽车尾气模拟/Module.png" title="Module"><h2 id="修改-Size-over-Lifetime-曲线如下，使尾气烟雾逐渐扩散出去"><a href="#修改-Size-over-Lifetime-曲线如下，使尾气烟雾逐渐扩散出去" class="headerlink" title="修改 Size over Lifetime 曲线如下，使尾气烟雾逐渐扩散出去"></a>修改 Size over Lifetime 曲线如下，使尾气烟雾逐渐扩散出去</h2><img src="/2018/05/29/Unity-3D-汽车尾气模拟/Size.png" title="Size"><h2 id="在-CarCollide-类中，根据碰撞速度，调整车辆的损坏程度。"><a href="#在-CarCollide-类中，根据碰撞速度，调整车辆的损坏程度。" class="headerlink" title="在 CarCollide 类中，根据碰撞速度，调整车辆的损坏程度。"></a>在 CarCollide 类中，根据碰撞速度，调整车辆的损坏程度。</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CarCollide</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> damage = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params">Collision collision</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 速度越大，损坏越大</span></span><br><span class="line">        damage += <span class="keyword">this</span>.gameObject.GetComponent&lt;Rigidbody&gt;().velocity.magnitude;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在-SmokeController-类中控制尾气随引擎负荷、车辆损坏程度的变化"><a href="#在-SmokeController-类中控制尾气随引擎负荷、车辆损坏程度的变化" class="headerlink" title="在 SmokeController 类中控制尾气随引擎负荷、车辆损坏程度的变化"></a>在 SmokeController 类中控制尾气随引擎负荷、车辆损坏程度的变化</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityStandardAssets.Vehicles.Car;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SmokeController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> engineRevs;            <span class="comment">// 引擎负荷</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> exhaustRate;           <span class="comment">// 尾气变化率</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> damage;                <span class="comment">// 车辆损坏情况</span></span><br><span class="line">    <span class="keyword">public</span> GameObject car;              <span class="comment">// 车辆</span></span><br><span class="line">    <span class="keyword">public</span> CarController carController; <span class="comment">// 车辆控制器</span></span><br><span class="line">    <span class="keyword">public</span> CarCollide carCollide;       <span class="comment">// 车辆碰撞检测</span></span><br><span class="line"></span><br><span class="line">    ParticleSystem exhaust;             <span class="comment">// 尾气粒子系统</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        exhaust = GetComponent&lt;ParticleSystem&gt;();</span><br><span class="line">        car = <span class="keyword">this</span>.transform.parent.parent.gameObject;</span><br><span class="line">        carController = car.GetComponent&lt;CarController&gt;();</span><br><span class="line">        carCollide = car.GetComponent&lt;CarCollide&gt;();</span><br><span class="line">        exhaustRate = <span class="number">5000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        engineRevs = carController.Revs;</span><br><span class="line">        damage = carCollide.damage;</span><br><span class="line">        <span class="comment">// 动态修改 emissionRate。引擎负荷越大，粒子产生率越大。</span></span><br><span class="line">        exhaust.emissionRate = Mathf.Pow(engineRevs, <span class="number">5</span>) * exhaustRate + <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> col = exhaust.colorOverLifetime;</span><br><span class="line">        Gradient grad = <span class="keyword">new</span> Gradient();</span><br><span class="line">        <span class="comment">// 根据车辆损坏程度修改尾气深浅。损坏越大，颜色越深。</span></span><br><span class="line">        grad.SetKeys(<span class="keyword">new</span> GradientColorKey[] &#123; <span class="keyword">new</span> GradientColorKey(Color.white, <span class="number">0.0</span>f), <span class="keyword">new</span> GradientColorKey(<span class="keyword">new</span> Color(<span class="number">214</span>, <span class="number">189</span>, <span class="number">151</span>), <span class="number">0.079</span>f), <span class="keyword">new</span> GradientColorKey(Color.white, <span class="number">1.0</span>f)&#125;,</span><br><span class="line">            <span class="keyword">new</span> GradientAlphaKey[] &#123; <span class="keyword">new</span> GradientAlphaKey(<span class="number">0.0</span>f, <span class="number">0.0</span>f), <span class="keyword">new</span> GradientAlphaKey(damage / <span class="number">255</span>f + <span class="number">10</span>f / <span class="number">255</span>f, <span class="number">0.061</span>f), <span class="keyword">new</span> GradientAlphaKey(<span class="number">0.0</span>f, <span class="number">1.0</span>f) &#125;);</span><br><span class="line">        col.color = grad;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h1><p>初始尾气效果<br><img src="/2018/05/29/Unity-3D-汽车尾气模拟/Initial.png" title="Initial"></p><p>多次碰撞后静止效果<br><img src="/2018/05/29/Unity-3D-汽车尾气模拟/Damage2.png" title="Damage2"></p><p>多次碰撞后运行效果<br><img src="/2018/05/29/Unity-3D-汽车尾气模拟/Damage.png" title="Damage"></p><h1 id="视频地址"><a href="#视频地址" class="headerlink" title="视频地址"></a>视频地址</h1><p><a href="http://v.youku.com/v_show/id_XMzYzMzg0MDgzNg==.html?spm=a2h3j.8428770.3416059.1" target="_blank" rel="noopener">http://v.youku.com/v_show/id_XMzYzMzg0MDgzNg==.html?spm=a2h3j.8428770.3416059.1</a></p><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/Xungerrrr/3D-Game-Programming-and-Design/tree/Homework-7" target="_blank" rel="noopener">GitHub</a>.</p><p><em><a href="/2018/03/30/Unity-3D-Learning/" title="返回 Unity 3D Learning">返回 Unity 3D Learning</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;粒子系统设计&quot;&gt;&lt;a href=&quot;#粒子系统设计&quot; class=&quot;headerlink&quot; title=&quot;粒子系统设计&quot;&gt;&lt;/a&gt;粒子系统设计&lt;/h1&gt;&lt;p&gt;新建粒子系统，设定粒子材料为 ParticleSmokeBlack ，并修改参数如下：&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="Unity" scheme="https://xungerrrr.github.io/categories/Unity/"/>
    
    
      <category term="Unity" scheme="https://xungerrrr.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity 3D - 智能巡逻兵</title>
    <link href="https://xungerrrr.github.io/2018/05/11/Unity-3D-%E6%99%BA%E8%83%BD%E5%B7%A1%E9%80%BB%E5%85%B5/"/>
    <id>https://xungerrrr.github.io/2018/05/11/Unity-3D-智能巡逻兵/</id>
    <published>2018-05-11T09:34:38.000Z</published>
    <updated>2018-05-29T15:09:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏要求"><a href="#游戏要求" class="headerlink" title="游戏要求"></a>游戏要求</h1><ul><li><p>游戏设计要求： </p><ul><li>创建一个地图和若干巡逻兵(使用动画)；</li><li>每个巡逻兵走一个3~5个边的凸多边型，位置数据是相对地址。即每次确定下一个目标位置，用自己当前位置为原点计算；</li><li>巡逻兵碰撞到障碍物，则会自动选下一个点为目标；</li><li>巡逻兵在设定范围内感知到玩家，会自动追击玩家；</li><li>失去玩家目标后，继续巡逻；</li><li>计分：玩家每次甩掉一个巡逻兵计一分，与巡逻兵碰撞游戏结束；</li></ul></li><li><p>程序设计要求： </p><ul><li>必须使用订阅与发布模式传消息 </li><li>工厂模式生产巡逻兵</li></ul></li></ul><h1 id="游戏操作方法"><a href="#游戏操作方法" class="headerlink" title="游戏操作方法"></a>游戏操作方法</h1><p>使用方向键或 WASD 键操控玩家，躲避巡逻兵追捕。玩家每次甩掉一个巡逻兵计一分，与巡逻兵碰撞则游戏结束，在倒计时结束后仍未死亡则游戏获胜。</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><h2 id="订阅与发布模式"><a href="#订阅与发布模式" class="headerlink" title="订阅与发布模式"></a>订阅与发布模式</h2><p>添加类 GameEventManager，并在其中定义游戏事件的处理逻辑。这是订阅及发布事件的入口。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameEventManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 玩家逃脱事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">EscapeEvent</span>(<span class="params">GameObject patrol</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> EscapeEvent OnGoalLost;</span><br><span class="line">    <span class="comment">// 巡逻兵追击事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">FollowEvent</span>(<span class="params">GameObject patrol</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> FollowEvent OnFollowing;</span><br><span class="line">    <span class="comment">// 游戏失败事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">GameOverEvent</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> GameOverEvent GameOver;</span><br><span class="line">    <span class="comment">// 游戏胜利事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">WinEvent</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> WinEvent Win;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 玩家逃脱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayerEscape</span>(<span class="params">GameObject patrol</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (OnGoalLost != <span class="literal">null</span>) &#123;</span><br><span class="line">            OnGoalLost(patrol);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 巡逻兵追击</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FollowPlayer</span>(<span class="params">GameObject patrol</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (OnFollowing != <span class="literal">null</span>) &#123;</span><br><span class="line">            OnFollowing(patrol);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 玩家被捕</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPlayerCatched</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GameOver != <span class="literal">null</span>) &#123;</span><br><span class="line">            GameOver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间结束</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TimeIsUP</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Win != <span class="literal">null</span>) &#123;</span><br><span class="line">            Win();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 FirstSceneController 中订阅事件，将不同的事件交给场记进行响应和处理。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FirstSceneController.cs</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 订阅游戏事件</span></span><br><span class="line">    GameEventManager.OnGoalLost += OnGoalLost;</span><br><span class="line">    GameEventManager.OnFollowing += OnFollowing;</span><br><span class="line">    GameEventManager.GameOver += GameOver;</span><br><span class="line">    GameEventManager.Win += Win;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    GameEventManager.OnGoalLost -= OnGoalLost;</span><br><span class="line">    GameEventManager.OnFollowing -= OnFollowing;</span><br><span class="line">    GameEventManager.GameOver -= GameOver;</span><br><span class="line">    GameEventManager.Win -= Win;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的方法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FirstSceneController.cs</span></span><br><span class="line"><span class="comment">// 失去目标，巡逻兵放弃追击</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnGoalLost</span>(<span class="params">GameObject patrol</span>) </span>&#123;</span><br><span class="line">    patrolActionManager.Patrol(patrol);</span><br><span class="line">    scoreRecorder.Record();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家进入范围，巡逻兵开始追击</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnFollowing</span>(<span class="params">GameObject patrol</span>) </span>&#123;</span><br><span class="line">    patrolActionManager.Follow(player, patrol);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 失败</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GameOver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gameState = GameState.LOSE;</span><br><span class="line">    StopAllCoroutines();</span><br><span class="line">    patrolFactory.PausePatrol();</span><br><span class="line">    player.GetComponent&lt;Animator&gt;().SetTrigger(<span class="string">"death"</span>);</span><br><span class="line">    patrolActionManager.DestroyAllActions();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 胜利</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Win</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gameState = GameState.WIN;</span><br><span class="line">    StopAllCoroutines();</span><br><span class="line">    patrolFactory.PausePatrol();</span><br><span class="line">    player.GetComponent&lt;Animator&gt;().SetBool(<span class="string">"pause"</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="游戏地图"><a href="#游戏地图" class="headerlink" title="游戏地图"></a>游戏地图</h2><p>利用 Plane, Cube 和下载的栅栏资源，设计一个具有九个正方形区域的地图。如下图：</p><img src="/2018/05/11/Unity-3D-智能巡逻兵/plane.png" title="地图"><p>在地图的每个区域中，放置一个空对象，并在对象上添加一个 Box Collider。通过空对象的 EnterRegion 脚本代码，检测玩家或巡逻兵进出区域的事件，并进行相应的操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnterRegion</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> region;                         <span class="comment">// 当前区域的区域编号</span></span><br><span class="line">    FirstSceneController sceneController;      <span class="comment">// 当前的场记</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider collider</span>) </span>&#123;</span><br><span class="line">        sceneController = Director.GetInstance().CurrentSceneController <span class="keyword">as</span> FirstSceneController;</span><br><span class="line">        <span class="keyword">if</span> (collider.gameObject.tag == <span class="string">"Player"</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果玩家进入区域，则标记玩家当前区域为该区域</span></span><br><span class="line">            sceneController.playerRegion = region;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit</span>(<span class="params">Collider collider</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (collider.gameObject.tag == <span class="string">"Patrol"</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果巡逻兵尝试离开区域，则标记巡逻兵发生了碰撞，以控制转向</span></span><br><span class="line">            collider.gameObject.GetComponent&lt;PatrolData&gt;().isCollided = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="巡逻兵"><a href="#巡逻兵" class="headerlink" title="巡逻兵"></a>巡逻兵</h2><p>在 Asset Store 中搜索 soldier，找到了一个骨骼、动画和贴图都不错的士兵模型包。其中有三种士兵可以选择。</p><img src="/2018/05/11/Unity-3D-智能巡逻兵/asset%20store.png" title="巡逻兵模型"><p>巡逻兵预制的结构如下，由头部和身体两大部分组成：</p><img src="/2018/05/11/Unity-3D-智能巡逻兵/patrol.png" title="巡逻兵结构"><p>在 Patrol 上添加一个 Capsule Collider，用于检测巡逻兵与障碍物、玩家的碰撞。在 Bip001 上添加一个 Capsule Collider，用于感知玩家。自定义 Collider 的形状，使巡逻兵具有一定视线范围，只能发现前方区域的玩家。如下图：</p><img src="/2018/05/11/Unity-3D-智能巡逻兵/patrol%20collider.png" title="巡逻兵搜索范围"><h3 id="巡逻兵数据"><a href="#巡逻兵数据" class="headerlink" title="巡逻兵数据"></a>巡逻兵数据</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PatrolData</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> isPlayerInRange;    <span class="comment">// 玩家是否在侦测范围里</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> isFollowing;        <span class="comment">// 是否正在追击</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> isCollided;         <span class="comment">// 是否发生碰撞</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> patrolRegion;        <span class="comment">// 巡逻兵所在区域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> playerRegion;        <span class="comment">// 玩家所在区域</span></span><br><span class="line">    <span class="keyword">public</span> GameObject player;       <span class="comment">// 所追击的玩家</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="巡逻兵动画控制"><a href="#巡逻兵动画控制" class="headerlink" title="巡逻兵动画控制"></a>巡逻兵动画控制</h3><p>利用 shoot 和 pause 两个变量来控制巡逻兵的动画播放。</p><img src="/2018/05/11/Unity-3D-智能巡逻兵/patrol%20animator.png" title="巡逻兵动画"><h3 id="使用工厂模式生产巡逻兵"><a href="#使用工厂模式生产巡逻兵" class="headerlink" title="使用工厂模式生产巡逻兵"></a>使用工厂模式生产巡逻兵</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PatrolFactory</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject patrol = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;PatrolData&gt; used = <span class="keyword">new</span> List&lt;PatrolData&gt;(); <span class="comment">// 正在使用的巡逻兵</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;GameObject&gt; <span class="title">GetPatrols</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        List&lt;GameObject&gt; patrols = <span class="keyword">new</span> List&lt;GameObject&gt;();</span><br><span class="line">        <span class="keyword">float</span>[] pos_x = &#123; <span class="number">-4.5</span>f, <span class="number">1.5</span>f, <span class="number">7.5</span>f &#125;;</span><br><span class="line">        <span class="keyword">float</span>[] pos_z = &#123; <span class="number">7.5</span>f, <span class="number">1.5</span>f, <span class="number">-4.5</span>f &#125;;</span><br><span class="line">        <span class="comment">// 生产九个巡逻兵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                patrol = Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">"Prefabs/Patrol"</span>));</span><br><span class="line">                patrol.transform.position = <span class="keyword">new</span> Vector3(pos_x[j], <span class="number">0</span>, pos_z[i]);</span><br><span class="line">                patrol.GetComponent&lt;PatrolData&gt;().patrolRegion = i * <span class="number">3</span> + j + <span class="number">1</span>;</span><br><span class="line">                patrol.GetComponent&lt;PatrolData&gt;().playerRegion = <span class="number">4</span>;</span><br><span class="line">                patrol.GetComponent&lt;PatrolData&gt;().isPlayerInRange = <span class="literal">false</span>;</span><br><span class="line">                patrol.GetComponent&lt;PatrolData&gt;().isFollowing = <span class="literal">false</span>;</span><br><span class="line">                patrol.GetComponent&lt;PatrolData&gt;().isCollided = <span class="literal">false</span>;</span><br><span class="line">                patrol.GetComponent&lt;Animator&gt;().SetBool(<span class="string">"pause"</span>, <span class="literal">true</span>);</span><br><span class="line">                used.Add(patrol.GetComponent&lt;PatrolData&gt;());</span><br><span class="line">                patrols.Add(patrol);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> patrols;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PausePatrol</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 暂停所有侦查兵的动画</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; used.Count; i++) &#123;</span><br><span class="line">            used[i].gameObject.GetComponent&lt;Animator&gt;().SetBool(<span class="string">"pause"</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartPatrol</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 开始所有侦查兵的动画</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; used.Count; i++) &#123;</span><br><span class="line">            used[i].gameObject.GetComponent&lt;Animator&gt;().SetBool(<span class="string">"pause"</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检测巡逻兵的碰撞"><a href="#检测巡逻兵的碰撞" class="headerlink" title="检测巡逻兵的碰撞"></a>检测巡逻兵的碰撞</h3><p>在 Patrol 上添加 PatrolCollide，检测巡逻兵的碰撞事件。若巡逻兵碰撞玩家，则游戏结束；若巡逻兵碰撞其他障碍物，则标记碰撞状态，以便在巡逻兵动作中做相应的处理。此处也用到了订阅与发布模式，在游戏结束时发布玩家被捕事件，使订阅了事件的场记能做出相应的操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PatrolCollide</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params">Collision collision</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (collision.gameObject.tag == <span class="string">"Player"</span>) &#123;</span><br><span class="line">            <span class="comment">// 当玩家与巡逻兵相撞</span></span><br><span class="line">            <span class="keyword">this</span>.GetComponent&lt;Animator&gt;().SetTrigger(<span class="string">"shoot"</span>);</span><br><span class="line">            Singleton&lt;GameEventManager&gt;.Instance.OnPlayerCatched();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当巡逻兵碰到其他障碍物</span></span><br><span class="line">            <span class="keyword">this</span>.GetComponent&lt;PatrolData&gt;().isCollided = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="感知玩家"><a href="#感知玩家" class="headerlink" title="感知玩家"></a>感知玩家</h3><p>在 Bip001 上添加 PlayerInRange，利用 Bip001 上的 Capsule Collider 感知玩家进入追击范围。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerInRange</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider collider</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (collider.gameObject.tag == <span class="string">"Player"</span>) &#123;</span><br><span class="line">            <span class="comment">// 玩家进入巡逻兵追捕范围</span></span><br><span class="line">            <span class="keyword">this</span>.gameObject.transform.parent.GetComponent&lt;PatrolData&gt;().isPlayerInRange = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.gameObject.transform.parent.GetComponent&lt;PatrolData&gt;().player = collider.gameObject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTriggerExit</span>(<span class="params">Collider collider</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (collider.gameObject.tag == <span class="string">"Player"</span>) &#123;</span><br><span class="line">            <span class="comment">// 玩家离开巡逻兵追捕范围</span></span><br><span class="line">            <span class="keyword">this</span>.gameObject.transform.parent.GetComponent&lt;PatrolData&gt;().isPlayerInRange = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.gameObject.transform.parent.GetComponent&lt;PatrolData&gt;().player = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="巡逻兵动作"><a href="#巡逻兵动作" class="headerlink" title="巡逻兵动作"></a>巡逻兵动作</h3><p>巡逻兵巡逻动作如下。巡逻兵每次寻找新位置时，会随机选择其附近的一个位置，然后转向并移动到新的位置。若移动过程中碰到障碍物，则向后转，重新选择新的位置。其中采用了订阅与发布模式。当玩家进入追捕范围，巡逻兵开始追捕时，触发 FollowPlayer 事件，通知订阅者采取相应的操作（这里对应的操作是巡逻兵停止巡逻）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PatrolAction</span> : <span class="title">Action</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pos_x, pos_z;                 <span class="comment">// 移动前的初始x和z方向坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> turn = <span class="literal">true</span>;                   <span class="comment">// 是否选择新方向</span></span><br><span class="line">    <span class="keyword">private</span> PatrolData data;                    <span class="comment">// 巡逻兵的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PatrolAction <span class="title">GetAction</span>(<span class="params">Vector3 location</span>) </span>&#123;</span><br><span class="line">        PatrolAction action = CreateInstance&lt;PatrolAction&gt;();</span><br><span class="line">        action.pos_x = location.x;</span><br><span class="line">        action.pos_z = location.z;</span><br><span class="line">        <span class="keyword">return</span> action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        data = <span class="keyword">this</span>.gameObject.GetComponent&lt;PatrolData&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Director.GetInstance().CurrentSceneController.getGameState().Equals(GameState.RUNNING)) &#123;</span><br><span class="line">            <span class="comment">// 巡逻兵巡逻</span></span><br><span class="line">            Patrol();</span><br><span class="line">            <span class="comment">// 如果满足要求，而巡逻兵未开始追击，则停止巡逻，开始追击</span></span><br><span class="line">            <span class="keyword">if</span> (!data.isFollowing &amp;&amp; data.isPlayerInRange &amp;&amp; data.patrolRegion == data.playerRegion &amp;&amp; !data.isCollided) &#123;</span><br><span class="line">                <span class="keyword">this</span>.destroy = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.enable = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">this</span>.callback.ActionEvent(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">this</span>.gameObject.GetComponent&lt;PatrolData&gt;().isFollowing = <span class="literal">true</span>;</span><br><span class="line">                Singleton&lt;GameEventManager&gt;.Instance.FollowPlayer(<span class="keyword">this</span>.gameObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Patrol</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (turn) &#123;</span><br><span class="line">        <span class="comment">// 随机选择新位置</span></span><br><span class="line">            pos_x = <span class="keyword">this</span>.transform.position.x + Random.Range(<span class="number">-5</span>f, <span class="number">5</span>f);</span><br><span class="line">            pos_z = <span class="keyword">this</span>.transform.position.z + Random.Range(<span class="number">-5</span>f, <span class="number">5</span>f);</span><br><span class="line">            <span class="keyword">this</span>.transform.LookAt(<span class="keyword">new</span> Vector3(pos_x, <span class="number">0</span>, pos_z));</span><br><span class="line">            <span class="keyword">this</span>.gameObject.GetComponent&lt;PatrolData&gt;().isCollided = <span class="literal">false</span>;</span><br><span class="line">            turn = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">float</span> distance = Vector3.Distance(transform.position, <span class="keyword">new</span> Vector3(pos_x, <span class="number">0</span>, pos_z));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.gameObject.GetComponent&lt;PatrolData&gt;().isCollided) &#123;</span><br><span class="line">            <span class="comment">// 碰撞，则向后转，寻找新位置</span></span><br><span class="line">            <span class="keyword">this</span>.transform.Rotate(Vector3.up, <span class="number">180</span>);</span><br><span class="line">            GameObject temp = <span class="keyword">new</span> GameObject();</span><br><span class="line">            temp.transform.position = <span class="keyword">this</span>.transform.position;</span><br><span class="line">            temp.transform.rotation = <span class="keyword">this</span>.transform.rotation;</span><br><span class="line">            temp.transform.Translate(<span class="number">0</span>, <span class="number">0</span>, Random.Range(<span class="number">0.5</span>f, <span class="number">3</span>f));</span><br><span class="line">            pos_x = temp.transform.position.x;</span><br><span class="line">            pos_z = temp.transform.position.z;</span><br><span class="line">            <span class="keyword">this</span>.transform.LookAt(<span class="keyword">new</span> Vector3(pos_x, <span class="number">0</span>, pos_z));</span><br><span class="line">            <span class="keyword">this</span>.gameObject.GetComponent&lt;PatrolData&gt;().isCollided = <span class="literal">false</span>;</span><br><span class="line">            Destroy(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (distance &lt;= <span class="number">0.1</span>) &#123;</span><br><span class="line">        <span class="comment">// 到达目的，重新选择位置</span></span><br><span class="line">            turn = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 向前移动巡逻兵</span></span><br><span class="line">            <span class="keyword">this</span>.transform.Translate(<span class="number">0</span>, <span class="number">0</span>, Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>巡逻兵追捕玩家的动作如下。其中采用了订阅与发布模式。当玩家离开追捕范围，巡逻兵放弃追捕时，触发 PlayerEscape 事件，通知订阅者采取相应的操作（这里对应的操作是巡逻兵开始巡逻，游戏增加一分）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PatrolFollowAction</span> : <span class="title">Action</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> speed = <span class="number">1.5</span>f;          <span class="comment">// 跟随玩家的速度</span></span><br><span class="line">    <span class="keyword">private</span> GameObject player;           <span class="comment">// 玩家</span></span><br><span class="line">    <span class="keyword">private</span> PatrolData data;             <span class="comment">// 巡逻兵数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PatrolFollowAction <span class="title">GetAction</span>(<span class="params">GameObject player</span>) </span>&#123;</span><br><span class="line">        PatrolFollowAction action = CreateInstance&lt;PatrolFollowAction&gt;();</span><br><span class="line">        action.player = player;</span><br><span class="line">        <span class="keyword">return</span> action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        data = <span class="keyword">this</span>.gameObject.GetComponent&lt;PatrolData&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Director.GetInstance().CurrentSceneController.getGameState().Equals(GameState.RUNNING)) &#123;</span><br><span class="line">            <span class="comment">// 追击玩家</span></span><br><span class="line">            transform.position = Vector3.MoveTowards(<span class="keyword">this</span>.transform.position, player.transform.position, speed * Time.deltaTime);</span><br><span class="line">            <span class="keyword">this</span>.transform.LookAt(player.transform.position);</span><br><span class="line">            <span class="comment">// 如果满足要求，而巡逻兵正在追击，则停止追击，开始巡逻</span></span><br><span class="line">            <span class="keyword">if</span> (data.isFollowing &amp;&amp; (!(data.isPlayerInRange &amp;&amp; data.patrolRegion == data.playerRegion) || data.isCollided)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.destroy = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.enable = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">this</span>.callback.ActionEvent(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">this</span>.gameObject.GetComponent&lt;PatrolData&gt;().isFollowing = <span class="literal">false</span>;</span><br><span class="line">                Singleton&lt;GameEventManager&gt;.Instance.PlayerEscape(<span class="keyword">this</span>.gameObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 PatrolActionManager 统一管理巡逻兵的两个动作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class PatrolActionManager : ActionManager, ActionCallback</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> PatrolAction patrol;</span><br><span class="line">    <span class="keyword">public</span> PatrolFollowAction follow;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 巡逻</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Patrol</span>(<span class="params">GameObject ptrl</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.patrol = PatrolAction.GetAction(ptrl.transform.position);</span><br><span class="line">        <span class="keyword">this</span>.RunAction(ptrl, patrol, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追击</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Follow</span>(<span class="params">GameObject player, GameObject patrol</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.follow = PatrolFollowAction.GetAction(player);</span><br><span class="line">        <span class="keyword">this</span>.RunAction(patrol, follow, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止所有动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DestroyAllActions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        DestroyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ActionEvent</span>(<span class="params">Action source, ActionEventType events = ActionEventType.Completed, <span class="keyword">int</span> intParam = <span class="number">0</span>, <span class="keyword">string</span> strParam = <span class="literal">null</span>, <span class="keyword">object</span> objectParam = <span class="literal">null</span></span>)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="玩家"><a href="#玩家" class="headerlink" title="玩家"></a>玩家</h2><p>玩家预制的结构如下，由头部、身体和背包三大部分组成。在顶层添加 Capsule Collider，检测玩家的碰撞。</p><img src="/2018/05/11/Unity-3D-智能巡逻兵/player.png" title="玩家结构"><h3 id="玩家动画控制"><a href="#玩家动画控制" class="headerlink" title="玩家动画控制"></a>玩家动画控制</h3><p>利用 run、pause 和 death 变量来控制玩家动画播放。</p><img src="/2018/05/11/Unity-3D-智能巡逻兵/player%20animator.png" title="玩家动画"><h3 id="移动玩家"><a href="#移动玩家" class="headerlink" title="移动玩家"></a>移动玩家</h3><p>在 UserGUI 类中的 Update 方法获取键盘方向输入，并调用 UserAction 中的 MovePlayer 方法实现玩家的移动。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserGUI.cs</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    action = Director.GetInstance().CurrentSceneController <span class="keyword">as</span> UserAction;</span><br><span class="line">    controller = Director.GetInstance().CurrentSceneController <span class="keyword">as</span> SceneController;</span><br><span class="line">    <span class="keyword">if</span> (controller.getGameState().Equals(GameState.RUNNING)) &#123;</span><br><span class="line">        <span class="comment">// 获取键盘输入</span></span><br><span class="line">        <span class="keyword">float</span> translationX = Input.GetAxis(<span class="string">"Horizontal"</span>);</span><br><span class="line">        <span class="keyword">float</span> translationZ = Input.GetAxis(<span class="string">"Vertical"</span>);</span><br><span class="line">        <span class="comment">//移动玩家</span></span><br><span class="line">        action.MovePlayer(translationX, translationZ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 FirstSceneController 中实现 MovePlayer 方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FirstSceneController.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MovePlayer</span>(<span class="params"><span class="keyword">float</span> translationX, <span class="keyword">float</span> translationZ</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (translationX != <span class="number">0</span> || translationZ != <span class="number">0</span>) &#123;</span><br><span class="line">        player.GetComponent&lt;Animator&gt;().SetBool(<span class="string">"run"</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        player.GetComponent&lt;Animator&gt;().SetBool(<span class="string">"run"</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    translationX *= Time.deltaTime;</span><br><span class="line">    translationZ *= Time.deltaTime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转向指定的方向并向前移动</span></span><br><span class="line">    player.transform.LookAt(<span class="keyword">new</span> Vector3(player.transform.position.x + translationX, player.transform.position.y, player.transform.position.z + translationZ));</span><br><span class="line">    <span class="keyword">if</span> (translationX == <span class="number">0</span>)</span><br><span class="line">        player.transform.Translate(<span class="number">0</span>, <span class="number">0</span>, Mathf.Abs(translationZ) * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (translationZ == <span class="number">0</span>)</span><br><span class="line">        player.transform.Translate(<span class="number">0</span>, <span class="number">0</span>, Mathf.Abs(translationX) * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        player.transform.Translate(<span class="number">0</span>, <span class="number">0</span>, Mathf.Abs(translationZ) + Mathf.Abs(translationX));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="游戏倒计时"><a href="#游戏倒计时" class="headerlink" title="游戏倒计时"></a>游戏倒计时</h2><p>在导演中控制游戏倒计时，初始时间为 60 秒。当倒计时结束时，发布 TimeIsUp 事件，使订阅了事件的场记能够做出响应（游戏胜利）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Director : System.Object</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> leaveSeconds = <span class="number">60</span>;                               <span class="comment">// 当前剩余时间</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 游戏倒计时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">CountDown</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (leaveSeconds &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> return new <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span>f</span>)</span>;</span><br><span class="line">            leaveSeconds--;</span><br><span class="line">            <span class="keyword">if</span> (leaveSeconds == <span class="number">0</span>) &#123;</span><br><span class="line">                Singleton&lt;GameEventManager&gt;.Instance.TimeIsUP();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="镜头跟随"><a href="#镜头跟随" class="headerlink" title="镜头跟随"></a>镜头跟随</h2><p>在 CameraFollowAction 中控制镜头跟随玩家移动<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraFollowAction</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject player;            <span class="comment">//相机跟随的物体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> smothing = <span class="number">5</span>f;          <span class="comment">//相机跟随的平滑速度</span></span><br><span class="line">    Vector3 offset;                      <span class="comment">//相机与物体相对偏移位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        offset = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">5</span>, <span class="number">-5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 设置摄像机目标位置</span></span><br><span class="line">        Vector3 target = player.transform.position + offset;</span><br><span class="line">        <span class="comment">// 摄像机自身位置到目标位置平滑过渡</span></span><br><span class="line">        transform.position = Vector3.Lerp(transform.position, target, smothing * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="游戏效果预览"><a href="#游戏效果预览" class="headerlink" title="游戏效果预览"></a>游戏效果预览</h1><img src="/2018/05/11/Unity-3D-智能巡逻兵/game.gif" title="游戏预览"><h1 id="游戏视频"><a href="#游戏视频" class="headerlink" title="游戏视频"></a>游戏视频</h1><p><a href="http://v.youku.com/v_show/id_XMzYwNTg1OTA1Mg==.html?spm=a2h3j.8428770.3416059.1" target="_blank" rel="noopener">http://v.youku.com/v_show/id_XMzYwNTg1OTA1Mg==.html?spm=a2h3j.8428770.3416059.1</a></p><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/Xungerrrr/3D-Game-Programming-and-Design/tree/Homework-6" target="_blank" rel="noopener">GitHub</a>.</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p>[1] <a href="https://blog.csdn.net/c486c/article/details/80153548" target="_blank" rel="noopener">Unity3d 学习之路 - 简单巡逻兵</a>.</p><p>[2] <a href="https://blog.csdn.net/qq_33000225/article/details/70045292" target="_blank" rel="noopener">[Unity3D 课堂作业] 巡逻兵 GetAwayFromPatrols</a>.</p><p><em><a href="/2018/03/30/Unity-3D-Learning/" title="返回 Unity 3D Learning">返回 Unity 3D Learning</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;游戏要求&quot;&gt;&lt;a href=&quot;#游戏要求&quot; class=&quot;headerlink&quot; title=&quot;游戏要求&quot;&gt;&lt;/a&gt;游戏要求&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;游戏设计要求： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个地图和若干巡逻兵(使用动画)；&lt;/li&gt;
&lt;li&gt;每个
      
    
    </summary>
    
      <category term="Unity" scheme="https://xungerrrr.github.io/categories/Unity/"/>
    
    
      <category term="Unity" scheme="https://xungerrrr.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>UWP - Media Player</title>
    <link href="https://xungerrrr.github.io/2018/05/05/UWP-Media-Player/"/>
    <id>https://xungerrrr.github.io/2018/05/05/UWP-Media-Player/</id>
    <published>2018-05-05T07:31:38.000Z</published>
    <updated>2019-03-14T17:52:50.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><ol><li>在Visual Studio中新建Media Player项目，创建Player页面；</li><li>在Player页面中使用Grid布局页面，第一行放置MediaPlayerElement以及包含歌曲标题和封面的StrollViewer等元素，第二行放置自行设计的媒体控制栏，其中包含媒体进度条、开始暂停按钮、停止按钮、选取文件按钮、全屏按钮等元素。</li><li>在cs文件中，使用MediaPlayer和MediaTimelineController控制媒体播放，并在相关函数中实现读取文件、提取媒体信息、绑定媒体位置与进度条位置、控制封面旋转动画等功能。</li></ol><h2 id="关键步骤截图"><a href="#关键步骤截图" class="headerlink" title="关键步骤截图"></a>关键步骤截图</h2><p>图1. 音乐播放器启动界面:</p><img src="/2018/05/05/UWP-Media-Player/1.png" title="demo1"><p>图2. 音乐播放示例:</p><img src="/2018/05/05/UWP-Media-Player/2.png" title="demo2"><p>图3. 视频播放示例:</p><img src="/2018/05/05/UWP-Media-Player/3.png" title="demo3"><h2 id="亮点与改进"><a href="#亮点与改进" class="headerlink" title="亮点与改进"></a>亮点与改进</h2><ol><li><p>选择本地媒体的功能</p><p>媒体播放器实现了选择本地媒体的功能，能够打开本地的音乐和视频进行播放。</p></li><li><p>美化界面</p><p>设计上，加入了很有质感的Acrylic材质，使应用透明化。在媒体播放器中播放音乐时，专辑封面会做毛玻璃模糊处理，使应用背景能够根据专辑封面动态改变。另外，用Acrylic材质实现了媒体控制栏颜色自动跟随系统主题颜色。</p><p>注：要实现此效果，必须使用最新版Windows 10 SDK（版本16299）生成解决方案，否则会提示找不到相关资源，无法运行。</p><img src="/2018/05/05/UWP-Media-Player/4.png" title="demo4"><img src="/2018/05/05/UWP-Media-Player/5.png" title="demo5"></li><li><p>实现封面旋转</p><p>在播放音乐时，封面旋转；播放结束时，封面复位；暂停时，封面的旋转动作暂停；在播放视频时，封面隐藏。</p></li><li><p>显示媒体的缩略图、标题、艺术家、专辑等信息</p><p>实现了媒体信息的提取，能够根据媒体动态显示标题等信息。</p></li><li><p>显示媒体时间进度</p><p>在媒体控制栏中实现了媒体当前时间和总时间的显示。</p></li><li><p>实现了应用的真正全屏效果</p><p>点击全屏按钮，应用能够真正全屏显示，而不只是将视频元素填满当前窗口。</p></li><li><p>播放音乐时，音乐信息能动态显示在磁贴上</p><img src="/2018/05/05/UWP-Media-Player/6.png" title="demo6"></li></ol><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul><li><p>问题：请求返回的XML存在中文乱码的问题</p><p>  解决方案：查阅相关资料后，将命名空间Windows.Web.Http更改为命名空间System.Net.Http，成功解决问题。</p></li></ul><h2 id="思考与总结"><a href="#思考与总结" class="headerlink" title="思考与总结"></a>思考与总结</h2><p>在本次实验中，我实现了UWP应用的媒体播放功能，能够播放本地的媒体资源。</p><p>在实验中，我学到了许多有趣而实用的知识，例如控制媒体播放，并且参考了一些成熟的媒体播放器的设计，对播放器进行了多重美化，很好地锻炼了UI设计的能力。经过这次实验，我的应用摆脱了简单的本地文本内容，进入了多媒体的世界，具有了更好的实用性和可扩展性。</p><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p><a href="https://github.com/Xungerrrr/SYSU-UWP/tree/master/Media%20Player" target="_blank" rel="noopener">https://github.com/Xungerrrr/SYSU-UWP/tree/master/Media%20Player</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.microsoft.com/zh-cn/windows/uwp/design/style/acrylic" target="_blank" rel="noopener">亚克力材料</a></li><li><a href="https://docs.microsoft.com/en-us/uwp/api/Windows.Media.Playback.MediaPlayer" target="_blank" rel="noopener">MediaPlayer类</a></li><li><a href="https://docs.microsoft.com/zh-cn/uwp/api/Windows.UI.Xaml.Controls.MediaPlayerElement" target="_blank" rel="noopener">MediaPlayerElement类</a></li><li><a href="https://docs.microsoft.com/en-us/uwp/api/windows.storage.fileproperties.musicproperties" target="_blank" rel="noopener">MusicProperties类</a></li><li><a href="https://stackoverflow.com/questions/18807320/get-albumart-in-mp3-file-for-windows-store-app?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" target="_blank" rel="noopener">Get Albumart in .mp3 file for Windows Store App</a></li><li><a href="https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.media.rotatetransform" target="_blank" rel="noopener">RotateTransform类</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实验步骤&quot;&gt;&lt;a href=&quot;#实验步骤&quot; class=&quot;headerlink&quot; title=&quot;实验步骤&quot;&gt;&lt;/a&gt;实验步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在Visual Studio中新建Media Player项目，创建Player页面；&lt;/li&gt;
&lt;li&gt;在Pl
      
    
    </summary>
    
    
      <category term="UWP" scheme="https://xungerrrr.github.io/tags/UWP/"/>
    
  </entry>
  
  <entry>
    <title>UWP - Networking</title>
    <link href="https://xungerrrr.github.io/2018/05/05/UWP-Networking/"/>
    <id>https://xungerrrr.github.io/2018/05/05/UWP-Networking/</id>
    <published>2018-05-05T06:54:11.000Z</published>
    <updated>2019-03-14T17:52:26.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><ol><li>在Visual Studio中新建Networking项目，创建MainPage、Weather和Finance三个空白页面。在MainPage中放置两个AppBarButton，分别导航到Weather和Finance页面；</li><li>在Weather页面上放置TextBox控件用于输入城市名称，并添加两个AppBarButton，分别进行JSON查询和XML查询；在Finance页面，放置两个ComboBox，用于选择需要查询汇率的两种货币，并添加两个AppBarButton，分别进行JSON查询和XML查询；</li><li>在cs文件中，使用HttpClient请求url“<a href="http://api.k780.com”，完成对天气或汇率的查询，再用系统自带解析器分别解析收到的JSON和XML，将信息呈现在页面上。" target="_blank" rel="noopener">http://api.k780.com”，完成对天气或汇率的查询，再用系统自带解析器分别解析收到的JSON和XML，将信息呈现在页面上。</a></li></ol><h2 id="关键步骤截图"><a href="#关键步骤截图" class="headerlink" title="关键步骤截图"></a>关键步骤截图</h2><p>图1. 天气查询示例</p><img src="/2018/05/05/UWP-Networking/1.png" title="demo1"><p>图2. 汇率查询示例</p><img src="/2018/05/05/UWP-Networking/2.png" title="demo2"><h2 id="亮点与改进"><a href="#亮点与改进" class="headerlink" title="亮点与改进"></a>亮点与改进</h2><ol><li><p>完成了两种API，并且分别完成对JSON和XML的解析</p><p>实现了天气查询和汇率查询两种功能，并且都分别采用了两种解析方式。</p></li></ol><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul><li><p>问题：请求返回的XML存在中文乱码的问题</p><p>  解决方案：查阅相关资料后，将命名空间Windows.Web.Http更改为命名空间System.Net.Http，成功解决问题。</p></li></ul><h2 id="思考与总结"><a href="#思考与总结" class="headerlink" title="思考与总结"></a>思考与总结</h2><p>在本次实验中，我实现了UWP应用的网络访问功能，能够查询天气和货币汇率。</p><p>在实验中，我学到了许多有趣而实用的知识，例如http请求、XML和JSON解析等等，很好地锻炼了标记语言解析能力。经过这次实验，我的应用摆脱了简单的本地文本内容，进入了互联网世界，具有了更好的实用性和可扩展性。</p><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p><a href="https://github.com/Xungerrrr/SYSU-UWP/tree/master/Networking" target="_blank" rel="noopener">https://github.com/Xungerrrr/SYSU-UWP/tree/master/Networking</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实验步骤&quot;&gt;&lt;a href=&quot;#实验步骤&quot; class=&quot;headerlink&quot; title=&quot;实验步骤&quot;&gt;&lt;/a&gt;实验步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在Visual Studio中新建Networking项目，创建MainPage、Weather和Finance
      
    
    </summary>
    
    
      <category term="UWP" scheme="https://xungerrrr.github.io/tags/UWP/"/>
    
  </entry>
  
  <entry>
    <title>Unity 3D - Hit UFO 2.0</title>
    <link href="https://xungerrrr.github.io/2018/04/24/Unity-3D-Hit-UFO-2-0/"/>
    <id>https://xungerrrr.github.io/2018/04/24/Unity-3D-Hit-UFO-2-0/</id>
    <published>2018-04-24T10:55:43.000Z</published>
    <updated>2018-05-16T14:48:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="改进飞碟（Hit-UFO）游戏："><a href="#改进飞碟（Hit-UFO）游戏：" class="headerlink" title="改进飞碟（Hit UFO）游戏："></a>改进飞碟（Hit UFO）游戏：</h1><ul><li>游戏内容要求：<ul><li>按 adapter 模式设计图修改飞碟游戏</li><li>使它同时支持物理运动与运动学（变换）运动</li></ul></li></ul><h2 id="适配器（adapter）模式"><a href="#适配器（adapter）模式" class="headerlink" title="适配器（adapter）模式"></a>适配器（adapter）模式</h2><p>在<a href="/2018/04/17/Unity-3D-Hit-UFO/" title="上一版游戏">上一版游戏</a>的基础上，我们希望加入飞碟的物理运动，使游戏能在运动学运动和物理运动这两种模式下运行。为了重用代码，我们需要增加一个适配器，来完成从通用接口（飞碟运动）到两个不同的类（物理运动和运动学运动）的转换。在这里，我采用了<a href="https://blog.csdn.net/zxt0601/article/details/52848004#t4" target="_blank" rel="noopener">对象的适配器模式</a>，在适配器中包含两个不同类的实例，来完成特定飞碟运动接口的转换。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="实现物理运动"><a href="#实现物理运动" class="headerlink" title="实现物理运动"></a>实现物理运动</h3><p>参考运动学飞行的实现方式，定义一个物理运动的类 PhysicsAction，实现飞碟的物理运动。在 Start() 方法中，用 Rigidbody 组件设定初速度并添加重力，模拟物理运动。由于需要处理 Rigidbody 的物理运动，这里应使用FixedUpdate()方法进行更新，防止受到游戏帧率的影响。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> PhysicsAction.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PhysicsAction</span> : <span class="title">Action</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3 startDirection;                     <span class="comment">// 初速度方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> power;                                <span class="comment">// 控制飞碟速度的变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PhysicsAction <span class="title">GetAction</span>(<span class="params">Vector3 direction, <span class="keyword">float</span> angle, <span class="keyword">float</span> power</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化飞碟的初速度方向</span></span><br><span class="line">        PhysicsAction action = CreateInstance&lt;PhysicsAction&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (direction.x == <span class="number">-1</span>) &#123;</span><br><span class="line">            action.startDirection = Quaternion.Euler(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, -angle)) * Vector3.left * power;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            action.startDirection = Quaternion.Euler(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, angle)) * Vector3.right * power;</span><br><span class="line">        &#125;</span><br><span class="line">        action.power = power;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定初速度并添加重力</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        gameObject.GetComponent&lt;Rigidbody&gt;().velocity = startDirection * power / <span class="number">10</span>;</span><br><span class="line">        gameObject.GetComponent&lt;Rigidbody&gt;().useGravity = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.transform.position.y &lt; <span class="number">-20</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.destroy = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.enable = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.callback.ActionEvent(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够重写上面的 FixedUpdate() 方法，需要在 Action 类中添加方法原型：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> Action.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> System.NotImplementedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时，还需要在 ActionManager 中添加 FixedUpdate() 方法，来调用 Action 的 FixedUpdate() 方法：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> ActionManager.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Action action <span class="keyword">in</span> waitingAdd) &#123;</span><br><span class="line">        actions[action.GetInstanceID()] = action;</span><br><span class="line">    &#125;</span><br><span class="line">    waitingAdd.Clear();</span><br><span class="line">    <span class="keyword">foreach</span> (KeyValuePair&lt;<span class="keyword">int</span>, Action&gt; kv <span class="keyword">in</span> actions) &#123;</span><br><span class="line">        Action action = kv.Value;</span><br><span class="line">        <span class="keyword">if</span> (action.enable) &#123;</span><br><span class="line">            action.FixedUpdate(); <span class="comment">// fix update action</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (action.destroy) &#123;</span><br><span class="line">            waitingDelete.Add(action.GetInstanceID()); <span class="comment">// release action</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">int</span> key <span class="keyword">in</span> waitingDelete) &#123;</span><br><span class="line">        Action action = actions[key];</span><br><span class="line">        actions.Remove(key);</span><br><span class="line">        DestroyObject(action);</span><br><span class="line">    &#125;</span><br><span class="line">    waitingDelete.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="定义物理运动的管理器"><a href="#定义物理运动的管理器" class="headerlink" title="定义物理运动的管理器"></a>定义物理运动的管理器</h3><p>参考 FlyActionManager，定义物理运动的管理器，来管理和执行物理运动。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> PhysicsActionManager.cs</span></span><br><span class="line">public class PhysicsActionManager : ActionManager, ActionCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PhysicsAction physics; <span class="comment">// 物理动作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 管理飞行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>(<span class="params">GameObject disk, <span class="keyword">float</span> angle, <span class="keyword">float</span> power</span>) </span>&#123;</span><br><span class="line">        physics = PhysicsAction.GetAction(disk.GetComponent&lt;DiskData&gt;().direction, angle, power);</span><br><span class="line">        <span class="keyword">this</span>.RunAction(disk, physics, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ActionEvent</span>(<span class="params">Action source, ActionEventType events = ActionEventType.Completed,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> intParam = <span class="number">0</span>, <span class="keyword">string</span> strParam = <span class="literal">null</span>, <span class="keyword">object</span> objectParam = <span class="literal">null</span></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="修改原有的飞行运动管理器"><a href="#修改原有的飞行运动管理器" class="headerlink" title="修改原有的飞行运动管理器"></a>修改原有的飞行运动管理器</h3><p>删除飞行管理器中的 SceneController 实例。实现方法与上面的物理运动管理器类似。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> FlyActionManager.cs</span></span><br><span class="line">public class FlyActionManager : ActionManager, ActionCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FlyAction fly; <span class="comment">// 飞行动作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 管理飞行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span> (<span class="params">GameObject disk, <span class="keyword">float</span> angle, <span class="keyword">float</span> power</span>) </span>&#123;</span><br><span class="line">        fly = FlyAction.GetAction(disk.GetComponent&lt;DiskData&gt;().direction, angle, power);</span><br><span class="line">        <span class="keyword">this</span>.RunAction(disk, fly, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ActionEvent</span>(<span class="params">Action source, ActionEventType events = ActionEventType.Completed,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> intParam = <span class="number">0</span>, <span class="keyword">string</span> strParam = <span class="literal">null</span>, <span class="keyword">object</span> objectParam = <span class="literal">null</span></span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="定义通用接口"><a href="#定义通用接口" class="headerlink" title="定义通用接口"></a>定义通用接口</h3><p>添加一个飞碟运动管理的通用接口。适配器继承这个接口来进行运动的适配。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> Interfaces.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IActionManager</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>(<span class="params">GameObject disk, <span class="keyword">float</span> angle, <span class="keyword">float</span> power, <span class="keyword">bool</span> physics</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="实现适配器"><a href="#实现适配器" class="headerlink" title="实现适配器"></a>实现适配器</h3><p>适配器中包含两个运动管理器的实例，根据变量 physics 来调用不同的运动管理器，实现不同的运动模式。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> ActionManagerAdapter.cs</span></span><br><span class="line">public class ActionManagerAdapter : MonoBehaviour, IActionManager &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FlyActionManager flyActionManager;</span><br><span class="line">    <span class="keyword">public</span> PhysicsActionManager physicsActionManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        flyActionManager = (FlyActionManager)gameObject.AddComponent&lt;FlyActionManager&gt;();</span><br><span class="line">        physicsActionManager = (PhysicsActionManager)gameObject.AddComponent&lt;PhysicsActionManager&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>(<span class="params">GameObject disk, <span class="keyword">float</span> angle, <span class="keyword">float</span> power, <span class="keyword">bool</span> physics</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 物理运动</span></span><br><span class="line">        <span class="keyword">if</span> (physics) &#123;</span><br><span class="line">            physicsActionManager.Fly(disk, angle, power);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 运动学运动</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            flyActionManager.Fly(disk, angle, power);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="修改-FirstSceneController"><a href="#修改-FirstSceneController" class="headerlink" title="修改 FirstSceneController"></a>修改 FirstSceneController</h3><ol><li>将原有的 FlyActionManager 实例修改为 ActionManagerAdapter 实例；</li><li>修改 ThrowDisk() 方法，调用通用接口提供的 Fly 方法，利用 physics 变量来控制不同的运动模式；</li><li>修改 Pause() 和 Begin() 方法，利用 Time.timeScale 实现物理运动的暂停（可恢复）。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> FirstSceneController.cs</span></span><br><span class="line">public class FirstSceneController : MonoBehaviour, SceneController, UserAction &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> ActionManagerAdapter actionManager;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> physics = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        actionManager = gameObject.AddComponent&lt;ActionManagerAdapter&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛出飞碟</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ThrowDisk</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> position_x = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">if</span> (diskQueue.Count != <span class="number">0</span>) &#123;</span><br><span class="line">            diskNumber--;</span><br><span class="line">            GameObject disk = diskQueue.Dequeue(); <span class="comment">// 取出飞碟</span></span><br><span class="line">            diskNotshot.Add(disk);</span><br><span class="line">            disk.SetActive(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置飞碟的随机位置</span></span><br><span class="line">            <span class="keyword">float</span> ran_y = Random.Range(<span class="number">1</span>f, <span class="number">4</span>f);</span><br><span class="line">            <span class="keyword">float</span> ran_x = Random.Range(<span class="number">-1</span>f, <span class="number">1</span>f) &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">            disk.GetComponent&lt;DiskData&gt;().direction = <span class="keyword">new</span> Vector3(ran_x, ran_y, <span class="number">0</span>);</span><br><span class="line">            Vector3 position = <span class="keyword">new</span> Vector3(-disk.GetComponent&lt;DiskData&gt;().direction.x * position_x, ran_y, <span class="number">0</span>);</span><br><span class="line">            disk.transform.position = position;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置飞碟初始所受的力和角度</span></span><br><span class="line">            <span class="keyword">float</span> power = Random.Range(<span class="number">10</span>f, <span class="number">15</span>f);</span><br><span class="line">            <span class="keyword">float</span> angle = Random.Range(<span class="number">15</span>f, <span class="number">28</span>f);</span><br><span class="line">            <span class="comment">// 通过 physics 变量控制运动模式</span></span><br><span class="line">            actionManager.Fly(disk, angle, power, physics);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diskNotshot.Count; i++) &#123;</span><br><span class="line">            GameObject temp = diskNotshot[i];</span><br><span class="line">            <span class="comment">//飞碟飞出摄像机视野也没被打中</span></span><br><span class="line">            <span class="keyword">if</span> (temp.transform.position.y &lt; <span class="number">-20</span> &amp;&amp; temp.gameObject.activeSelf == <span class="literal">true</span>) &#123;</span><br><span class="line">                diskFactory.FreeDisk(diskNotshot[i]);</span><br><span class="line">                diskNotshot.Remove(diskNotshot[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停游戏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Pause</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        gameState = GameState.PAUSE;</span><br><span class="line">        Time.timeScale = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始游戏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Begin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        gameState = GameState.START;</span><br><span class="line">        Time.timeScale = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="游戏运行方法"><a href="#游戏运行方法" class="headerlink" title="游戏运行方法"></a>游戏运行方法</h2><ol><li>在飞碟预制上添加 Rigidbody 组件，取消勾选重力（运动学运动不需要重力）；<img src="/2018/04/24/Unity-3D-Hit-UFO-2-0/rigidbody.png" title="rigidbody"></li><li>将 FirstSceneController.cs、DiskFactory.cs 和 ScoreRecorder.cs 挂在 Main Camera 上，利用 First Scene Controller 的 Physics 属性控制运动模式。运行后结果：<img src="/2018/04/24/Unity-3D-Hit-UFO-2-0/physics.png" title="physics"></li></ol><h2 id="游戏视频"><a href="#游戏视频" class="headerlink" title="游戏视频"></a>游戏视频</h2><p><a href="http://v.youku.com/v_show/id_XMzU2MjMxMDgyOA==.html?spm=a2hzp.8244740.0.0" target="_blank" rel="noopener">物理运动</a></p><p><a href="http://v.youku.com/v_show/id_XMzU0NTU3OTg5Ng==.html?spm=a2hzp.8244740.0.0" target="_blank" rel="noopener">运动学运动</a></p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/Xungerrrr/3D-Game-Programming-and-Design/tree/master/Homework%205/Hit%20UFO%20(Physics)" target="_blank" rel="noopener">传送门</a></p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>[1] <a href="https://blog.csdn.net/c486c/article/details/80052862" target="_blank" rel="noopener">Unity3d 学习之路 - 简单打飞碟 (适配器模式)</a>.</p><p>[2] <a href="https://blog.csdn.net/zxt0601/article/details/52848004" target="_blank" rel="noopener">设计模式 (二) 三种适配器模式 总结和使用场景</a>.</p><p>[3] <a href="https://blog.csdn.net/x2_yt/article/details/69049672" target="_blank" rel="noopener">Unity3D 学习笔记（6）– 打飞碟游戏改进版</a>.</p><a href="/2018/03/30/Unity-3D-Learning/" title="返回 Unity 3D Learning">返回 Unity 3D Learning</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;改进飞碟（Hit-UFO）游戏：&quot;&gt;&lt;a href=&quot;#改进飞碟（Hit-UFO）游戏：&quot; class=&quot;headerlink&quot; title=&quot;改进飞碟（Hit UFO）游戏：&quot;&gt;&lt;/a&gt;改进飞碟（Hit UFO）游戏：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;游戏内容要求：&lt;
      
    
    </summary>
    
      <category term="Unity" scheme="https://xungerrrr.github.io/categories/Unity/"/>
    
    
      <category term="Unity" scheme="https://xungerrrr.github.io/tags/Unity/"/>
    
  </entry>
  
</feed>
